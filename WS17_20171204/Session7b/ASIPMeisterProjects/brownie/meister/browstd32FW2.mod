// Copyright (C) 2011 ASIP Solutions, Inc. All rights reserved. 
// Generated by ASIP Meister 2.3 on 2017/10/20 21:07:01 
Design{
Version{"2.3"},

Abstract_level_architecture{
Fhm_workname{"FHM_work"},
Priority{"Area"},
CPU_type{"Pipeline"},
Pipeline_architecture{Number_of_stages{"4"},
Number_of_common_stages{"0"},
stage{stage1{"IF,1,fetch"},
stage2{"ID,1,decode"},
stage3{"EXE,1,exec"},
stage4{"WB,1,memory_read & memory_write"}},
Multi_cycle_interlock{"Yes"},
Data_hazard_interlock{"No"},
Register_bypass{"No"},
Delayed_branch{"No"}},
MAX_instruction_bit_width{"32"},
MAX_data_width{"32"},
Processor_design{"Base Processor Design"},
Use_compiler{"Yes"}},

Port_declaration{
entity_name{"BrownieSTD32"},Port{"CLK"{direction{"in"},signal_type{"1"},signal_attribute{"clock"}},
"RESET"{direction{"in"},signal_type{"1"},signal_attribute{"reset"}},
"IMEM_ADDR_OUT"{direction{"out"},signal_type{"32"},signal_attribute{"instruction_memory_address_bus"}},
"IMEM_DATA_IN"{direction{"in"},signal_type{"32"},signal_attribute{"instruction_memory_data_in_bus"}},
"IMEM_ADDRERR_IN"{direction{"in"},signal_type{"1"},signal_attribute{"instruction_memory_address_error_bus"}},
"DMEM_ADDR_OUT"{direction{"out"},signal_type{"32"},signal_attribute{"data_memory_address_bus"}},
"DMEM_DATA_IN"{direction{"in"},signal_type{"32"},signal_attribute{"data_memory_data_in_bus"}},
"DMEM_DATA_OUT"{direction{"out"},signal_type{"32"},signal_attribute{"data_memory_data_out_bus"}},
"DMEM_REQ_OUT"{direction{"out"},signal_type{"1"},signal_attribute{"data_memory_request_bus"}},
"DMEM_ACK_IN"{direction{"in"},signal_type{"1"},signal_attribute{"data_memory_acknowledge_bus"}},
"DMEM_RW_OUT"{direction{"out"},signal_type{"1"},signal_attribute{"data_memory_rw_bus"}},
"DMEM_WMODE_OUT"{direction{"out"},signal_type{"2"},signal_attribute{"data_memory_write_mode_bus"}},
"DMEM_EMODE_OUT"{direction{"out"},signal_type{"1"},signal_attribute{"data_memory_ext_mode_bus"}},
"DMEM_ADDRERR_IN"{direction{"in"},signal_type{"1"},signal_attribute{"data_memory_address_error_bus"}},
"DMEM_CANCEL_OUT"{direction{"out"},signal_type{"1"},signal_attribute{"data_memory_cancel_bus"}},
"EXTINT_IN"{direction{"in"},signal_type{"1"},signal_attribute{"interrupt"}},
"EXTCATCH_OUT"{direction{"out"},signal_type{"1"},signal_attribute{"unspecified"}}
}},

Instruction_type{
sub_field_name{NO_VLIW{width{"31","0"},type{"RR"{
"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"name"{"f_type"},width{"16","14"}},
"OP-code"{"name"{"func"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
}
,"RI"{
"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"name"{"op"},width{"5","0"}}
}
,"MA_ST"{
"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"name"{"op"},width{"5","0"}}
}
,"MA_LD"{
"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"name"{"op"},width{"5","0"}}
}
,"BR"{
"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Dont_care"{"name"{"unused"},width{"10","6"}},
"OP-code"{"name"{"op"},width{"5","0"}}
}
,"JP"{
"Operand"{"name"{"const"},width{"31","6"}},
"OP-code"{"name"{"op"},width{"5","0"}}
}
,"JPR"{
"Dont_care"{"name"{"unused"},width{"31","11"}},
"Operand"{"name"{"rs1"},width{"10","6"}},
"OP-code"{"name"{"op"},width{"5","0"}}
}
,"SP"{
"Dont_care"{"name"{"unused"},width{"31","11"}},
"OP-code"{"name"{"func"},width{"10","6"}},
"OP-code"{"binary"{"000000"},width{"5","0"}}
}
,"RT"{
"Operand"{"name"{"rd"},width{"31","27"}},
"Operand"{"name"{"rs1"},width{"26","22"}},
"OP-code"{"name"{"func"},width{"21","11"}},
"OP-code"{"binary"{"00010"},width{"10","6"}},
"OP-code"{"binary"{"000000"},width{"5","0"}}
}
,"BR2"{
"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rs2"},width{"10","6"}},
"OP-code"{"name"{"op"},width{"5","0"}}
}
,"RR1"{
"Operand"{"name"{"rs"},width{"31","27"}},
"OP-code"{"binary"{"00000"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"00000000000"},width{"16","6"}},
"OP-code"{"binary"{"010001"},width{"5","0"}}
}
,"RR2"{
"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rdMin"},width{"21","17"}},
"Operand"{"name"{"rdMax"},width{"16","12"}},
"OP-code"{"binary"{"000000"},width{"11","6"}},
"OP-code"{"binary"{"010010"},width{"5","0"}}
}
}}}},

Instruction{NO_VLIW{"ADD"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"000"},width{"16","14"}},
"OP-code"{"binary"{"00000000"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"SUB"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"000"},width{"16","14"}},
"OP-code"{"binary"{"00000001"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"MUL"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"000"},width{"16","14"}},
"OP-code"{"binary"{"00000010"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"DIV"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"000"},width{"16","14"}},
"OP-code"{"binary"{"00000011"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"DIVU"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"000"},width{"16","14"}},
"OP-code"{"binary"{"00000101"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"MOD"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"000"},width{"16","14"}},
"OP-code"{"binary"{"00000100"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"MODU"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"000"},width{"16","14"}},
"OP-code"{"binary"{"00000110"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"AND"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"001"},width{"16","14"}},
"OP-code"{"binary"{"00000000"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"NAND"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"001"},width{"16","14"}},
"OP-code"{"binary"{"00000011"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"OR"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"001"},width{"16","14"}},
"OP-code"{"binary"{"00000001"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"NOR"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"001"},width{"16","14"}},
"OP-code"{"binary"{"00000100"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"XOR"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"001"},width{"16","14"}},
"OP-code"{"binary"{"00000010"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"LLS"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"010"},width{"16","14"}},
"OP-code"{"binary"{"00000000"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"LRS"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"010"},width{"16","14"}},
"OP-code"{"binary"{"00000001"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"ARS"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"010"},width{"16","14"}},
"OP-code"{"binary"{"00000010"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"ELT"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"011"},width{"16","14"}},
"OP-code"{"binary"{"00000000"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"ELTU"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"011"},width{"16","14"}},
"OP-code"{"binary"{"00000001"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"EEQ"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"011"},width{"16","14"}},
"OP-code"{"binary"{"00000010"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"ENEQ"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"011"},width{"16","14"}},
"OP-code"{"binary"{"00000011"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"ADDI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100000"},width{"5","0"}}
},"SUBI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100001"},width{"5","0"}}
},"ANDI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100010"},width{"5","0"}}
},"ORI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100011"},width{"5","0"}}
},"XORI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100100"},width{"5","0"}}
},"LLSI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100101"},width{"5","0"}}
},"LRSI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100110"},width{"5","0"}}
},"ARSI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"100111"},width{"5","0"}}
},"LSOI"{type{"RI"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"101000"},width{"5","0"}}
},"LB"{type{"MA_LD"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"000010"},width{"5","0"}}
},"LH"{type{"MA_LD"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"000011"},width{"5","0"}}
},"LW"{type{"MA_LD"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"000100"},width{"5","0"}}
},"SB"{type{"MA_ST"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"000101"},width{"5","0"}}
},"SH"{type{"MA_ST"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"000110"},width{"5","0"}}
},"SW"{type{"MA_ST"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rd"},width{"10","6"}},
"OP-code"{"binary"{"000111"},width{"5","0"}}
},"BRZ"{type{"BR"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Dont_care"{"name"{"unused"},width{"10","6"}},
"OP-code"{"binary"{"001001"},width{"5","0"}}
},"BRNZ"{type{"BR"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Dont_care"{"name"{"unused"},width{"10","6"}},
"OP-code"{"binary"{"001010"},width{"5","0"}}
},"JP"{type{"JP"},"Operand"{"name"{"const"},width{"31","6"}},
"OP-code"{"binary"{"001011"},width{"5","0"}}
},"JPL"{type{"JP"},"Operand"{"name"{"const"},width{"31","6"}},
"OP-code"{"binary"{"001100"},width{"5","0"}}
},"TRAP"{type{"JP"},"Operand"{"name"{"const"},width{"31","6"}},
"OP-code"{"binary"{"001101"},width{"5","0"}}
},"JPR"{type{"JPR"},"Dont_care"{"name"{"unused"},width{"31","11"}},
"Operand"{"name"{"rs1"},width{"10","6"}},
"OP-code"{"binary"{"001110"},width{"5","0"}}
},"JPRL"{type{"JPR"},"Dont_care"{"name"{"unused"},width{"31","11"}},
"Operand"{"name"{"rs1"},width{"10","6"}},
"OP-code"{"binary"{"001111"},width{"5","0"}}
},"NOP"{type{"SP"},"Dont_care"{"name"{"unused"},width{"31","11"}},
"OP-code"{"binary"{"00000"},width{"10","6"}},
"OP-code"{"binary"{"000000"},width{"5","0"}}
},"RETI"{type{"SP"},"Dont_care"{"name"{"unused"},width{"31","11"}},
"OP-code"{"binary"{"00001"},width{"10","6"}},
"OP-code"{"binary"{"000000"},width{"5","0"}}
},"EXBW"{type{"RT"},"Operand"{"name"{"rd"},width{"31","27"}},
"Operand"{"name"{"rs1"},width{"26","22"}},
"OP-code"{"binary"{"00000000000"},width{"21","11"}},
"OP-code"{"binary"{"00010"},width{"10","6"}},
"OP-code"{"binary"{"000000"},width{"5","0"}}
},"EXHW"{type{"RT"},"Operand"{"name"{"rd"},width{"31","27"}},
"Operand"{"name"{"rs1"},width{"26","22"}},
"OP-code"{"binary"{"00000000001"},width{"21","11"}},
"OP-code"{"binary"{"00010"},width{"10","6"}},
"OP-code"{"binary"{"000000"},width{"5","0"}}
},"NXOR"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"001"},width{"16","14"}},
"OP-code"{"binary"{"00000101"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"BGEU"{type{"BR2"},"Operand"{"name"{"const"},width{"31","16"}},
"Operand"{"name"{"rs1"},width{"15","11"}},
"Operand"{"name"{"rs2"},width{"10","6"}},
"OP-code"{"binary"{"010000"},width{"5","0"}}
},"AVG"{type{"RR"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"001"},width{"16","14"}},
"OP-code"{"binary"{"00000110"},width{"13","6"}},
"OP-code"{"binary"{"000001"},width{"5","0"}}
},"SWAP"{type{"RR1"},"Operand"{"name"{"rs"},width{"31","27"}},
"OP-code"{"binary"{"00000"},width{"26","22"}},
"Operand"{"name"{"rd"},width{"21","17"}},
"OP-code"{"binary"{"00000000000"},width{"16","6"}},
"OP-code"{"binary"{"010001"},width{"5","0"}}
},"MINMAX"{type{"RR2"},"Operand"{"name"{"rs1"},width{"31","27"}},
"Operand"{"name"{"rs2"},width{"26","22"}},
"Operand"{"name"{"rdMin"},width{"21","17"}},
"Operand"{"name"{"rdMax"},width{"16","12"}},
"OP-code"{"binary"{"000000"},width{"11","6"}},
"OP-code"{"binary"{"010010"},width{"5","0"}}
}}},

Operation{NO_VLIW{}},

Resource{"PC"{class{"pcu"},classpath{"/workdb/FHM_work/"},use{"Prog. Counter"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
increment_step{"4"},
adder_algorithm{"default"}}}
,"IR"{class{"register"},classpath{"/basicfhmdb/storage/"},use{"Inst. Register"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"}}}
,"IMAU"{class{"mifu"},classpath{"/workdb/FHM_work/"},use{"Inst. Memory"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
address_space{"32"},
access_width{"32"},
access_mode{"single_cycle"},
type{"read_only"}}}
,"DMAU"{class{"mifu"},classpath{"/workdb/FHM_work/"},use{"Data Memory"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
address_space{"32"},
access_width{"8"},
access_mode{"multi_cycle"},
type{"read_write"}}}
,"ALU"{class{"alu"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
algorithm{"default"}}}
,"MUL"{class{"multiplier"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
algorithm{"seq"},
adder_algorithm{"default"},
data_type{"two_complement"}}}
,"DIV"{class{"divider"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
algorithm{"seq"},
adder_algorithm{"default"},
data_type{"two_complement"}}}
,"EXT8TO32"{class{"extender"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"8"},
bit_width_out{"32"}}}
,"EXT16TO32"{class{"extender"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"16"},
bit_width_out{"32"}}}
,"EXT26TO32"{class{"extender"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"26"},
bit_width_out{"32"}}}
,"SFTvar"{class{"shifter"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
amount{"variable"}}}
,"EXTINT"{class{"wire_in"},classpath{"/workdb/FHM_work/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"1"}}}
,"EXTCATCH_OUT"{class{"wire_out"},classpath{"/workdb/FHM_work/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"1"},
default_output{"fix_to_0"}}}
,"TRAP_HAND_REG"{class{"register"},classpath{"/basicfhmdb/storage/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"}}}
,"FWU0"{class{"fwu"},classpath{"/workdb/FHM_work/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
addr_width{"5"},
stage_number{"2"}}}
,"FWU1"{class{"fwu"},classpath{"/workdb/FHM_work/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
addr_width{"5"},
stage_number{"2"}}}
,"DUMMY_STREG"{class{"dummy_register"},classpath{"/workdb/FHM_work/"},use{"Mask Register"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"}}}
,"GPR"{class{"browregfile"},classpath{"/workdb/FHM_work/"},use{"Register File"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
num_register{"32"},
num_read_port{"2"},
num_write_port{"2"},
num_bank{"1"}}}
,"EXT16TO32A"{class{"extender"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"16"},
bit_width_out{"32"}}}
,"ALU1"{class{"alu"},classpath{"/basicfhmdb/computational/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
algorithm{"default"}}}
,"FWU2"{class{"fwu"},classpath{"/workdb/FHM_work/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
addr_width{"5"},
stage_number{"2"}}}
,"FWU3"{class{"fwu"},classpath{"/workdb/FHM_work/"},use{"(unspecified)"},
parameter{
abstraction_level{for_simulation{"Behavior"},for_synthesis{"Gate"}},
bit_width{"32"},
addr_width{"5"},
stage_number{"2"}}}
},

Exception{"EXTINT"{
Mask{Maskable{"YES"},Register_Name{"DUMMY_STREG"},Position{"8"},Register_Value{"0"}},
Condition{Internal_Condition{""},"EXTINT_IN"{Active_Value{"1"}}},
Type{"External"},
Cycles{""},
Behavior{""},
Assert{""},
Comment{""},
MOD{variable{"wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire        one;"},clk(1){"ret_addr     = saved_pc;                           // Get saved pc
//handler_addr = \"00001111111111100000010000000000\"; // 0x0FFE0400 (fixed)
handler_addr = \"00000000000000000011010000000000\"; // 0x0FFE0400 (fixed)
mask         = \"11111111111111111011110011111111\"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
rsave        = \"00010\";                            // R2 (Interrupt Return)
rstatus      = \"00001\";                            // R1 (Status Register)
one          = '1';

current_st   = DUMMY_STREG.read();                 // load current status
new_st       = current_st & mask;                  // masking interrupts

null = EXTCATCH_OUT.write(one);                    // output catch signal for 1 cycle
null = GPR.write0(rsave, ret_addr);                // write return address
null = GPR.status_write(new_st);                   // write masked status
null = PC.write(handler_addr);                     // jump to the handler"}
}}
,"RESET"{
Mask{Maskable{"NO"},Register_Name{""},Position{""},Register_Value{""}},
Condition{Internal_Condition{""},"RESET"{Active_Value{"1"}}},
Type{"Reset"},
Cycles{""},
Behavior{""},
Assert{""},
Comment{""},
MOD{variable{"wire [31:0] reset_handler;"},clk(1){"// set the pc 0x0FFE0000
//reset_handler = \"00001111111111100000000000000000\";
reset_handler = \"00000000000000000011000000000000\";
null = PC.write(reset_handler);

// reset all memories
null = GPR.reset();
null = IR.reset();
null = DIV.reset();
null = MUL.reset();
null = TRAP_HAND_REG.reset();"}
}}
,"TRAPINT"{
Mask{Maskable{"YES"},Register_Name{"DUMMY_STREG"},Position{"9"},Register_Value{"0"}},
Condition{Internal_Condition{"instr_specific"}},
Type{"Internal"},
Cycles{""},
Behavior{""},
Assert{""},
Comment{""},
MOD{variable{"wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire [31:0] trap_factor;
wire [31:0] trap_base;
wire [3:0]  trap_alu_flag;"},clk(1){"ret_addr     = saved_pc;                           // Get saved pc
//trap_base    = \"00001111111111100000100000000000\"; // 0x0FFE0800 (fixed)
trap_base    = \"00000000000000000011100000000000\"; // 0x0FFE0800 (fixed)
mask         = \"11111111111111111011110011111111\"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
rsave        = \"00010\";                            // R2 (Interrupt Return)
rstatus      = \"00001\";                            // R1 (Status Register)

current_st   = DUMMY_STREG.read();                 // load current status
new_st       = current_st & mask;                  // masking interrupts

trap_factor  = TRAP_HAND_REG.read();               // get trap factor
<handler_addr, trap_alu_flag>
             = ALU.add(trap_base, trap_factor);    // calculate dest. addr.


null = GPR.write0(rsave, ret_addr);                // write return address
null = GPR.status_write(new_st);                   // write masked status
null = PC.write(handler_addr);                     // jump to the handler"}
}}
},

MOT{mnemonic{"ADD"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [4:0] update_streg_flag_stfl_in;
wire       update_streg_flag_reserved_bits;

// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source2);
update_streg_flag_reserved_bits = '0';
update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;

// we can update flag using the function of flag_update
null                            = GPR.flag_update(update_streg_flag_stfl_in);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"SUB"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [4:0] update_streg_flag_stfl_in;
wire       update_streg_flag_reserved_bits;

// execute operation[sub] using data arg1 and arg2
<alu_result, alu_flag> = ALU.sub(source1, source2);
update_streg_flag_reserved_bits = '0';
update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;

// we can update flag using the function of flag_update
null                            = GPR.flag_update(update_streg_flag_stfl_in);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"MUL"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  mul_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [63:0]  mul_exec_tmp_result;

// multiplier execution
mul_exec_tmp_result = MUL.mul(source1, source2);
mul_result          = mul_exec_tmp_result[31:0];
// foward mul_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, mul_result);
null = FWU1.forward1(rd, mul_result);"},
clk(4){"null = GPR.write0(rd, mul_result);        // write mul_result[arg2] to GPR[arg1]
// foward mul_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, mul_result);
null = FWU1.forward2(rd, mul_result);"}
}
,"DIV"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  div_result;
wire [31:0]  mod_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire div_exec_div_flag;

// division execution
<div_result, mod_result, div_exec_div_flag> = DIV.div(source1, source2);
// foward div_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, div_result);
null = FWU1.forward1(rd, div_result);"},
clk(4){"null = GPR.write0(rd, div_result);        // write div_result[arg2] to GPR[arg1]
// foward div_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, div_result);
null = FWU1.forward2(rd, div_result);"}
}
,"DIVU"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  div_result;
wire [31:0]  mod_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire div_exec_div_flag;

// division execution
<div_result, mod_result, div_exec_div_flag> = DIV.divu(source1, source2);
// foward div_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, div_result);
null = FWU1.forward1(rd, div_result);"},
clk(4){"null = GPR.write0(rd, div_result);        // write div_result[arg2] to GPR[arg1]
// foward div_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, div_result);
null = FWU1.forward2(rd, div_result);"}
}
,"MOD"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  div_result;
wire [31:0]  mod_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire div_exec_div_flag;

// division execution
<div_result, mod_result, div_exec_div_flag> = DIV.div(source1, source2);
// foward mod_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, mod_result);
null = FWU1.forward1(rd, mod_result);"},
clk(4){"null = GPR.write0(rd, mod_result);        // write mod_result[arg2] to GPR[arg1]
// foward mod_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, mod_result);
null = FWU1.forward2(rd, mod_result);"}
}
,"MODU"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  div_result;
wire [31:0]  mod_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire div_exec_div_flag;

// division execution
<div_result, mod_result, div_exec_div_flag> = DIV.divu(source1, source2);
// foward mod_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, mod_result);
null = FWU1.forward1(rd, mod_result);"},
clk(4){"null = GPR.write0(rd, mod_result);        // write mod_result[arg2] to GPR[arg1]
// foward mod_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, mod_result);
null = FWU1.forward2(rd, mod_result);"}
}
,"AND"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"// execute operation[and] using data arg1 and arg2
<alu_result, alu_flag> = ALU.and(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"NAND"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"// execute operation[nand] using data arg1 and arg2
<alu_result, alu_flag> = ALU.nand(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"OR"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"// execute operation[or] using data arg1 and arg2
<alu_result, alu_flag> = ALU.or(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"NOR"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"// execute operation[nor] using data arg1 and arg2
<alu_result, alu_flag> = ALU.nor(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"XOR"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"// execute operation[xor] using data arg1 and arg2
<alu_result, alu_flag> = ALU.xor(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"LLS"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  sft_result;
wire [4:0] sft_amt;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
sft_amt = source2[4:0];"},
clk(3){"// shift execution
sft_result       = SFTvar.sll(source1, sft_amt);
// foward sft_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, sft_result);
null = FWU1.forward1(rd, sft_result);"},
clk(4){"null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
// foward sft_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, sft_result);
null = FWU1.forward2(rd, sft_result);"}
}
,"LRS"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  sft_result;
wire [4:0] sft_amt;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
sft_amt = source2[4:0];"},
clk(3){"// shift execution
sft_result       = SFTvar.srl(source1, sft_amt);
// foward sft_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, sft_result);
null = FWU1.forward1(rd, sft_result);"},
clk(4){"null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
// foward sft_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, sft_result);
null = FWU1.forward2(rd, sft_result);"}
}
,"ARS"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  sft_result;
wire [4:0] sft_amt;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
sft_amt = source2[4:0];"},
clk(3){"// shift execution
sft_result       = SFTvar.sra(source1, sft_amt);
// foward sft_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, sft_result);
null = FWU1.forward1(rd, sft_result);"},
clk(4){"null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
// foward sft_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, sft_result);
null = FWU1.forward2(rd, sft_result);"}
}
,"ELT"{variable{"wire [31:0] cmp_result;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
/* we can use only cmp_flags corresponding chosen operation */

wire cmp_equal;  /* equal to */
wire cmp_nequal; /* not equal to */
wire cmp_lt;     /* less than */
wire cmp_ult;    /* unsigned less than */"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [30:0] zero;
wire [3:0] alu_cmp_alu_flag;
wire [1:0] alu_cmp_tmp_flag;
wire       alu_cmp_lt_cond1;
wire       alu_cmp_lt_cond2;
wire       alu_cmp_carry;

alu_cmp_alu_flag = ALU.cmp(source1, source2);

// calculate each flag
// equal to is evaluated depending on zero flag
cmp_equal  = alu_cmp_alu_flag[2];

// not equal to is negative of cmp_equal
cmp_nequal = ~cmp_equal;

// signed less than is either sign bit is 1 with no overflow
//                     or     sign bit is 0 with overflow
alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];

alu_cmp_lt_cond1   = alu_cmp_tmp_flag == \"10\";
alu_cmp_lt_cond2   = alu_cmp_tmp_flag == \"01\";
cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;

// unsigned less than is negative carry
alu_cmp_carry      = alu_cmp_alu_flag[3];
cmp_ult            = ~alu_cmp_carry;
zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_lt>;                    // zero extension
// foward cmp_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, cmp_result);
null = FWU1.forward1(rd, cmp_result);"},
clk(4){"null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
// foward cmp_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, cmp_result);
null = FWU1.forward2(rd, cmp_result);"}
}
,"ELTU"{variable{"wire [31:0] cmp_result;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
/* we can use only cmp_flags corresponding chosen operation */

wire cmp_equal;  /* equal to */
wire cmp_nequal; /* not equal to */
wire cmp_lt;     /* less than */
wire cmp_ult;    /* unsigned less than */"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [30:0] zero;
wire [3:0] alu_cmp_alu_flag;
wire [1:0] alu_cmp_tmp_flag;
wire       alu_cmp_lt_cond1;
wire       alu_cmp_lt_cond2;
wire       alu_cmp_carry;

alu_cmp_alu_flag = ALU.cmp(source1, source2);

// calculate each flag
// equal to is evaluated depending on zero flag
cmp_equal  = alu_cmp_alu_flag[2];

// not equal to is negative of cmp_equal
cmp_nequal = ~cmp_equal;

// signed less than is either sign bit is 1 with no overflow
//                     or     sign bit is 0 with overflow
alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];

alu_cmp_lt_cond1   = alu_cmp_tmp_flag == \"10\";
alu_cmp_lt_cond2   = alu_cmp_tmp_flag == \"01\";
cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;

// unsigned less than is negative carry
alu_cmp_carry      = alu_cmp_alu_flag[3];
cmp_ult            = ~alu_cmp_carry;
zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_ult>;                   // zero extension
// foward cmp_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, cmp_result);
null = FWU1.forward1(rd, cmp_result);"},
clk(4){"null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
// foward cmp_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, cmp_result);
null = FWU1.forward2(rd, cmp_result);"}
}
,"EEQ"{variable{"wire [31:0] cmp_result;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
/* we can use only cmp_flags corresponding chosen operation */

wire cmp_equal;  /* equal to */
wire cmp_nequal; /* not equal to */
wire cmp_lt;     /* less than */
wire cmp_ult;    /* unsigned less than */"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [30:0] zero;
wire [3:0] alu_cmp_alu_flag;
wire [1:0] alu_cmp_tmp_flag;
wire       alu_cmp_lt_cond1;
wire       alu_cmp_lt_cond2;
wire       alu_cmp_carry;

alu_cmp_alu_flag = ALU.cmp(source1, source2);

// calculate each flag
// equal to is evaluated depending on zero flag
cmp_equal  = alu_cmp_alu_flag[2];

// not equal to is negative of cmp_equal
cmp_nequal = ~cmp_equal;

// signed less than is either sign bit is 1 with no overflow
//                     or     sign bit is 0 with overflow
alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];

alu_cmp_lt_cond1   = alu_cmp_tmp_flag == \"10\";
alu_cmp_lt_cond2   = alu_cmp_tmp_flag == \"01\";
cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;

// unsigned less than is negative carry
alu_cmp_carry      = alu_cmp_alu_flag[3];
cmp_ult            = ~alu_cmp_carry;
zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_equal>;                 // zero extension
// foward cmp_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, cmp_result);
null = FWU1.forward1(rd, cmp_result);"},
clk(4){"null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
// foward cmp_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, cmp_result);
null = FWU1.forward2(rd, cmp_result);"}
}
,"ENEQ"{variable{"wire [31:0] cmp_result;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
/* we can use only cmp_flags corresponding chosen operation */

wire cmp_equal;  /* equal to */
wire cmp_nequal; /* not equal to */
wire cmp_lt;     /* less than */
wire cmp_ult;    /* unsigned less than */"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [30:0] zero;
wire [3:0] alu_cmp_alu_flag;
wire [1:0] alu_cmp_tmp_flag;
wire       alu_cmp_lt_cond1;
wire       alu_cmp_lt_cond2;
wire       alu_cmp_carry;

alu_cmp_alu_flag = ALU.cmp(source1, source2);

// calculate each flag
// equal to is evaluated depending on zero flag
cmp_equal  = alu_cmp_alu_flag[2];

// not equal to is negative of cmp_equal
cmp_nequal = ~cmp_equal;

// signed less than is either sign bit is 1 with no overflow
//                     or     sign bit is 0 with overflow
alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];

alu_cmp_lt_cond1   = alu_cmp_tmp_flag == \"10\";
alu_cmp_lt_cond2   = alu_cmp_tmp_flag == \"01\";
cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;

// unsigned less than is negative carry
alu_cmp_carry      = alu_cmp_alu_flag[3];
cmp_ult            = ~alu_cmp_carry;
zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
cmp_result = <zero, cmp_nequal>;                // zero extension
// foward cmp_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, cmp_result);
null = FWU1.forward1(rd, cmp_result);"},
clk(4){"null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
// foward cmp_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, cmp_result);
null = FWU1.forward2(rd, cmp_result);"}
}
,"ADDI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"wire [4:0] update_streg_flag_stfl_in;
wire       update_streg_flag_reserved_bits;

// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source2);
update_streg_flag_reserved_bits = '0';
update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;

// we can update flag using the function of flag_update
null                            = GPR.flag_update(update_streg_flag_stfl_in);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"SUBI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"wire [4:0] update_streg_flag_stfl_in;
wire       update_streg_flag_reserved_bits;

// execute operation[sub] using data arg1 and arg2
<alu_result, alu_flag> = ALU.sub(source1, source2);
update_streg_flag_reserved_bits = '0';
update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;

// we can update flag using the function of flag_update
null                            = GPR.flag_update(update_streg_flag_stfl_in);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"ANDI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"// execute operation[and] using data arg1 and arg2
<alu_result, alu_flag> = ALU.and(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"ORI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"// execute operation[or] using data arg1 and arg2
<alu_result, alu_flag> = ALU.or(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"XORI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"// execute operation[xor] using data arg1 and arg2
<alu_result, alu_flag> = ALU.xor(source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"LLSI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0] source1;
wire [31:0]  sft_result;
wire [4:0] sft_amt;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs1);
source1        = FWU0.forward(rs1, gpr_read_stmp1);
sft_amt = const[4:0];"},
clk(3){"// shift execution
sft_result       = SFTvar.sll(source1, sft_amt);
// foward sft_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, sft_result);
null = FWU1.forward1(rd, sft_result);"},
clk(4){"null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
// foward sft_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, sft_result);
null = FWU1.forward2(rd, sft_result);"}
}
,"LRSI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0] source1;
wire [31:0]  sft_result;
wire [4:0] sft_amt;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs1);
source1        = FWU0.forward(rs1, gpr_read_stmp1);
sft_amt = const[4:0];"},
clk(3){"// shift execution
sft_result       = SFTvar.srl(source1, sft_amt);
// foward sft_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, sft_result);
null = FWU1.forward1(rd, sft_result);"},
clk(4){"null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
// foward sft_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, sft_result);
null = FWU1.forward2(rd, sft_result);"}
}
,"ARSI"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0] source1;
wire [31:0]  sft_result;
wire [4:0] sft_amt;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs1);
source1        = FWU0.forward(rs1, gpr_read_stmp1);
sft_amt = const[4:0];"},
clk(3){"// shift execution
sft_result       = SFTvar.sra(source1, sft_amt);
// foward sft_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, sft_result);
null = FWU1.forward1(rd, sft_result);"},
clk(4){"null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
// foward sft_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, sft_result);
null = FWU1.forward2(rd, sft_result);"}
}
,"LSOI"{variable{"wire [31:0] shifted_source1;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [15:0] lower_bits;
wire [15:0] zeros;
// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;
// shift source data before OR
lower_bits      = source1[15:0];
zeros           = \"0000000000000000\";
shifted_source1 = <lower_bits, zeros>;"},
clk(3){"// execute operation[or] using data arg1 and arg2
<alu_result, alu_flag> = ALU.or(shifted_source1, source2);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"LB"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;
wire [31:0] load_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source2);"},
clk(4){"wire        load_alu_result_err;

// result is 32bit data. already extended
<load_result, load_alu_result_err> = DMAU.ld_8(alu_result);
null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
// foward load_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, load_result);
null = FWU1.forward2(rd, load_result);"}
}
,"LH"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;
wire [31:0] load_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source2);"},
clk(4){"wire        load_alu_result_err;

// result is 32bit data. already extended
<load_result, load_alu_result_err> = DMAU.ld_16(alu_result);
null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
// foward load_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, load_result);
null = FWU1.forward2(rd, load_result);"}
}
,"LW"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;
wire [31:0] load_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source2);"},
clk(4){"wire        load_alu_result_err;

// result is 32bit data. already extended
<load_result, load_alu_result_err> = DMAU.ld_32(alu_result);
null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
// foward load_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, load_result);
null = FWU1.forward2(rd, load_result);"}
}
,"SB"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  source3;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_ext16to32_stmp1;
wire [31:0]  gpr_double_read_ext16to32_stmp2;
wire [31:0]  gpr_double_read_ext16to32_stmp3;

// prefetch GPR data to stmp1/stmp2
// and also, STATUS_REG data to stmp3
gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
source3 = gpr_double_read_ext16to32_stmp3;"},
clk(3){"// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source3);"},
clk(4){"wire         store_alu_result_err;

// result is 32bit source2. already extended
store_alu_result_err = DMAU.s_8(alu_result, source2);"}
}
,"SH"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  source3;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_ext16to32_stmp1;
wire [31:0]  gpr_double_read_ext16to32_stmp2;
wire [31:0]  gpr_double_read_ext16to32_stmp3;

// prefetch GPR data to stmp1/stmp2
// and also, STATUS_REG data to stmp3
gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
source3 = gpr_double_read_ext16to32_stmp3;"},
clk(3){"// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source3);"},
clk(4){"wire         store_alu_result_err;

// result is 32bit source2. already extended
store_alu_result_err = DMAU.s_16(alu_result, source2);"}
}
,"SW"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  source3;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_ext16to32_stmp1;
wire [31:0]  gpr_double_read_ext16to32_stmp2;
wire [31:0]  gpr_double_read_ext16to32_stmp3;

// prefetch GPR data to stmp1/stmp2
// and also, STATUS_REG data to stmp3
gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
source3 = gpr_double_read_ext16to32_stmp3;"},
clk(3){"// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source3);"},
clk(4){"wire         store_alu_result_err;

// result is 32bit source2. already extended
store_alu_result_err = DMAU.s_32(alu_result, source2);"}
}
,"BRZ"{variable{"/* these variables can be used in following stages of all instructions */
/* these variables can be used in following stages of all instructions */
wire [31:0] pcread_result;
wire [31:0]  source1;
wire [31:0]  source2;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

pcread_result = PC.read();
// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"wire [31:0] relative_branchz_abs_addr;
wire [3:0]  relative_branchz_alu_flag;
wire        relative_branchz_cond;

// evaluate source1 equal or not equal to zero
relative_branchz_cond = source1 == \"00000000000000000000000000000000\";

// branch according to the cond
<relative_branchz_abs_addr, relative_branchz_alu_flag> 
                     = ALU.add(pcread_result, source2);  // calu. absolute address
null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch"},
clk(4){""}
}
,"BRNZ"{variable{"/* these variables can be used in following stages of all instructions */
/* these variables can be used in following stages of all instructions */
wire [31:0] pcread_result;
wire [31:0]  source1;
wire [31:0]  source2;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0] gpr_read_ext16to32_stmp1;
wire [31:0] gpr_read_ext16to32_stmp2;

pcread_result = PC.read();
// prefetch GPR data to stmp1/stmp2
gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
source2 = gpr_read_ext16to32_stmp2;"},
clk(3){"wire [31:0] relative_branchz_abs_addr;
wire [3:0]  relative_branchz_alu_flag;
wire        relative_branchz_cond;

// evaluate source1 equal or not equal to zero
relative_branchz_cond = source1 != \"00000000000000000000000000000000\";

// branch according to the cond
<relative_branchz_abs_addr, relative_branchz_alu_flag> 
                     = ALU.add(pcread_result, source2);  // calu. absolute address
null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch"},
clk(4){""}
}
,"JP"{variable{"/* these variables can be used in following stages of all instructions */
/* these variables can be used in following stages of all instructions */
wire [31:0] pcread_result;
wire [31:0] ext26to32_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"pcread_result = PC.read();
ext26to32_result = EXT26TO32.sign(const);"},
clk(3){"wire [31:0] relative_jump_abs_addr;
wire [3:0]  relative_jump_alu_flag;

<relative_jump_abs_addr, relative_jump_alu_flag> 
                     = ALU.add(pcread_result, ext26to32_result);         // calu. absolute address
null                 = PC.write(relative_jump_abs_addr); // jump"},
clk(4){""}
}
,"JPL"{variable{"/* these variables can be used in following stages of all instructions */
/* these variables can be used in following stages of all instructions */
wire [31:0] pcread_result;
wire [31:0] ext26to32_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"pcread_result = PC.read();
ext26to32_result = EXT26TO32.sign(const);"},
clk(3){"wire [4:0] linkreg_idx;
wire [31:0] relative_jump_abs_addr;
wire [3:0]  relative_jump_alu_flag;

linkreg_idx = \"00011\";
<relative_jump_abs_addr, relative_jump_alu_flag> 
                     = ALU.add(pcread_result, ext26to32_result);         // calu. absolute address
null                 = PC.write(relative_jump_abs_addr); // jump
// foward pcread_result to as GPR[linkreg_idx] from stage EXE
null = FWU0.forward1(linkreg_idx, pcread_result);
null = FWU1.forward1(linkreg_idx, pcread_result);"},
clk(4){"wire [4:0] linkreg_idx;

linkreg_idx = \"00011\";
null = GPR.write0(linkreg_idx, pcread_result);        // write pcread_result[arg2] to GPR[arg1]
// foward pcread_result to as GPR[linkreg_idx] from stage WB
null = FWU0.forward2(linkreg_idx, pcread_result);
null = FWU1.forward2(linkreg_idx, pcread_result);"}
}
,"TRAP"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0] ext26to32_result;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"ext26to32_result = EXT26TO32.zero(const);
// store handler address
// this address will be used in TRAP_INT
null = TRAP_HAND_REG.write(ext26to32_result);"},
clk(3){"// throw exception
throw TRAPINT;"},
clk(4){""}
}
,"JPR"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0] source1;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs1);
source1        = FWU0.forward(rs1, gpr_read_stmp1);"},
clk(3){"null = PC.write(source1); // jump according to absolute address"},
clk(4){""}
}
,"JPRL"{variable{"/* these variables can be used in following stages of all instructions */
/* these variables can be used in following stages of all instructions */
wire [31:0] pcread_result;
wire [31:0] source1;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

pcread_result = PC.read();
// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs1);
source1        = FWU0.forward(rs1, gpr_read_stmp1);"},
clk(3){"wire [4:0] linkreg_idx;

linkreg_idx = \"00011\";
null = PC.write(source1); // jump according to absolute address
// foward pcread_result to as GPR[linkreg_idx] from stage EXE
null = FWU0.forward1(linkreg_idx, pcread_result);
null = FWU1.forward1(linkreg_idx, pcread_result);"},
clk(4){"wire [4:0] linkreg_idx;

linkreg_idx = \"00011\";
null = GPR.write0(linkreg_idx, pcread_result);        // write pcread_result[arg2] to GPR[arg1]
// foward pcread_result to as GPR[linkreg_idx] from stage WB
null = FWU0.forward2(linkreg_idx, pcread_result);
null = FWU1.forward2(linkreg_idx, pcread_result);"}
}
,"NOP"{variable{"/* these variables can be used in following stages of all instructions */"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){""},
clk(3){""},
clk(4){""}
}
,"RETI"{variable{"/* these variables can be used in following stages of all instructions */
/* these variables can be used in following stages of all instructions */
wire [31:0] streg_read_result;
wire [31:0] source1;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [4:0] ret_idx;
wire [31:0] gpr_read_stmp1;

ret_idx = \"00010\";                // interrupt return address is stored in GPR2
// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(ret_idx);
source1        = FWU0.forward(ret_idx, gpr_read_stmp1);
// get return address
streg_read_result = DUMMY_STREG.read();"},
clk(3){"wire [31:0] new_st;
wire [31:0] mask;

mask         = \"00000000000000000100001100000000\"; // clear interrupt mask and move to user mode
new_st       = streg_read_result | mask;           // 
null         = GPR.status_write(new_st);           // update status register (interrupt will be enabled at next cycle)
null = PC.write(source1); // jump according to absolute address"},
clk(4){""}
}
,"EXBW"{variable{"wire [31:0] extended_data;
/* these variables can be used in following stages of all instructions */
wire [31:0] source1;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs1);
source1        = FWU0.forward(rs1, gpr_read_stmp1);"},
clk(3){"wire [7:0] target;

target        = source1[7:0];
extended_data = EXT8TO32.sign(target);
// foward extended_data to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, extended_data);
null = FWU1.forward1(rd, extended_data);"},
clk(4){"null = GPR.write0(rd, extended_data);        // write extended_data[arg2] to GPR[arg1]
// foward extended_data to as GPR[rd] from stage WB
null = FWU0.forward2(rd, extended_data);
null = FWU1.forward2(rd, extended_data);"}
}
,"EXHW"{variable{"wire [31:0] extended_data;
/* these variables can be used in following stages of all instructions */
wire [31:0] source1;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs1);
source1        = FWU0.forward(rs1, gpr_read_stmp1);"},
clk(3){"wire [15:0] target;

target        = source1[15:0];
extended_data = EXT16TO32A.sign(target);
// foward extended_data to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, extended_data);
null = FWU1.forward1(rd, extended_data);"},
clk(4){"null = GPR.write0(rd, extended_data);        // write extended_data[arg2] to GPR[arg1]
// foward extended_data to as GPR[rd] from stage WB
null = FWU0.forward2(rd, extended_data);
null = FWU1.forward2(rd, extended_data);"}
}
,"NXOR"{variable{"wire [31:0]  alu_result2;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"// execute operation[xor] using data arg1 and arg2
<alu_result, alu_flag> = ALU.xor(source1, source2);
alu_result2 = ~alu_result;
// foward alu_result2 to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result2);
null = FWU1.forward1(rd, alu_result2);"},
clk(4){"null = GPR.write0(rd, alu_result2);        // write alu_result2[arg2] to GPR[arg1]
// foward alu_result2 to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result2);
null = FWU1.forward2(rd, alu_result2);"}
}
,"BGEU"{variable{"/* these variables can be used in following stages of all instructions */
wire [31:0] pcread_result;
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  source3;
/* these variables can be used in following stages of all instructions */"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;
wire [31:0]  gpr_read_ext16to32_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);
gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
source3  = gpr_read_ext16to32_stmp2;

//PCRead()
pcread_result = PC.read();"},
clk(3){"wire [31:0] relative_branchz_abs_addr;
wire [3:0]  relative_branchz_alu_flag;
wire        relative_branchz_cond;

wire [30:0] zero;
//wire cmp_ult;    /* unsigned less than */
wire cmp_ugte;    /* unsigned greater than or equal to*/
wire [3:0] alu_cmp_alu_flag;
wire       alu_cmp_carry;
wire [31:0] cmp_result;

alu_cmp_alu_flag = ALU.cmp(source1, source2);

// unsigned less than is negative carry
alu_cmp_carry      = alu_cmp_alu_flag[3];
//cmp_ult            = ~alu_cmp_carry;
cmp_ugte		   = alu_cmp_carry;

zero       = \"0000000000000000000000000000000\"; // 31 bits zeros
//cmp_result = <zero, cmp_ult>;                   // zero extension
cmp_result = <zero, cmp_ugte>;                   // zero extension

//Branching
//RelativeBranchZ(!=, cmp_result, pcread_result, source3)

// evaluate refdata equal or not equal to zero
relative_branchz_cond = cmp_result != \"00000000000000000000000000000000\";

// branch according to the cond
<relative_branchz_abs_addr, relative_branchz_alu_flag> 
                     = ALU1.add(pcread_result, source3);  // calu. absolute address
null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch"},
clk(4){""}
}
,"AVG"{variable{"wire [31:0]  sft_result;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;
wire [31:0]  alu_result;
wire [3:0]   alu_flag;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [4:0] sft_amt;
wire [4:0] update_streg_flag_stfl_in;
wire       update_streg_flag_reserved_bits;

sft_amt = \"00001\";
// execute operation[add] using data arg1 and arg2
<alu_result, alu_flag> = ALU.add(source1, source2);
update_streg_flag_reserved_bits = '0';
update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;

// we can update flag using the function of flag_update
null                            = GPR.flag_update(update_streg_flag_stfl_in);
// shift execution
sft_result = SFTvar.sra(alu_result, sft_amt);
// foward sft_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, sft_result);
null = FWU1.forward1(rd, sft_result);"},
clk(4){"null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
// foward sft_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, sft_result);
null = FWU1.forward2(rd, sft_result);"}
}
,"SWAP"{variable{"wire [31:0]  alu_result;
wire [3:0]   alu_flag;
/* these variables can be used in following stages of all instructions */
wire [31:0] source1;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"wire [31:0] gpr_read_stmp1;

// prefetch data from GPR,
// then choose either the data or the forwarded one
gpr_read_stmp1 = GPR.read0(rs);
source1        = FWU0.forward(rs, gpr_read_stmp1);"},
clk(3){"wire [15:0] zero;
wire [15:0] lsb;
wire [15:0] msb;
wire [31:0] lsb_new;
wire [31:0] msb_new;

zero = \"0000000000000000\";
lsb = source1[15:0];
msb = source1[31:16];

lsb_new = <zero, msb>;
msb_new = <lsb , zero>;

<alu_result, alu_flag> = ALU.or(lsb_new, msb_new);
// foward alu_result to as GPR[rd] from stage EXE
null = FWU0.forward1(rd, alu_result);
null = FWU1.forward1(rd, alu_result);"},
clk(4){"null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
// foward alu_result to as GPR[rd] from stage WB
null = FWU0.forward2(rd, alu_result);
null = FWU1.forward2(rd, alu_result);"}
}
,"MINMAX"{variable{"//wire [31:0] cmp_result;
wire [31:0] min;
wire [31:0] max;
/* these variables can be used in following stages of all instructions */
wire [31:0]  source1;
wire [31:0]  source2;"},clk(1){"wire [31:0]  fetch_current_pc;                              // current pc
wire [31:0]  fetch_inst;                                    // opecode
wire         fetch_addrerr;                                 // address err. from IM
wire [31:0]  fetch_status_data;

// the value of status register

fetch_current_pc            = PC.read();                    // reading PC
<fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
null                        = IR.write(fetch_inst);         // writing opecode to IR
null                        = PC.inc();                     // incrementing PC

// pull out the current value of status register
// and connect to the dummy_register so that used as mask register
fetch_status_data           = GPR.status_read();
null                        = DUMMY_STREG.write(fetch_status_data);"},
clk(2){"// prefetched data
wire [31:0]  gpr_double_read_stmp1;
wire [31:0]  gpr_double_read_stmp2;

// prefetch GPR data to stmp1/stmp2
gpr_double_read_stmp1   = GPR.read0(rs1);
gpr_double_read_stmp2   = GPR.read1(rs2);

// get source value
// from GPR or forwarded value selectively
source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
source2  = FWU1.forward(rs2, gpr_double_read_stmp2);"},
clk(3){"wire [3:0] flag;
wire [2:0] tmp_flag;
wire  cond1;
wire  cond2;
wire  cond;

flag = ALU.cmp(source1, source2);

tmp_flag = flag[2:0];
cond1 = tmp_flag == \"010\";
cond2 =     flag == \"1001\";
cond = cond1 | cond2;

min = (cond) ? source1:source2;
max = (cond) ? source2:source1;

//Two Register Forwarding:
// foward min to as GPR[rdMin] from stage EXE
null = FWU0.forward1(rdMin, min);
null = FWU1.forward1(rdMin, min);
// foward max to as GPR[rdMax] from stage EXE
null = FWU2.forward1(rdMax, max);
null = FWU3.forward1(rdMax, max);"},
clk(4){"null = GPR.write0(rdMin, min);
null = GPR.write1(rdMax, max);

//Two Register Forwarding:
// foward min to as GPR[rdMin] from stage WB
null = FWU0.forward2(rdMin, min);
null = FWU1.forward2(rdMin, min);
// foward max to as GPR[rdMax] from stage WB
null = FWU2.forward2(rdMax, max);
null = FWU3.forward2(rdMax, max);"}
}
}}

}
