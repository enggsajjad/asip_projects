// Copyright (C) 2011 ASIP Solutions, Inc. All rights reserved. 
// Generated by ASIP Meister 2.3 on 2018/12/03 18:20:41 
mod "browstd32"
{
/* Architecture Parameter */
  num_stages 4;
  stage IF : fetch_stage;
  stage ID : decode_stage;
  stage EXE : exec_stage;
  stage WB : memory_read_stage,memory_write_stage;

/* Resource */
  resource PC : program_counter
  {
    model "pcu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 increment_step=4 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 increment_step=4 adder_algorithm=default";
    };
  };
  resource IR : instr_register
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource IMAU : instr_memory
  {
    model "mifu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 address_space=32 access_width=32 access_mode=single_cycle type=read_only";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 address_space=32 access_width=32 access_mode=single_cycle type=read_only";
    };
  };
  resource DMAU : data_memory
  {
    model "mifu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 address_space=32 access_width=8 access_mode=multi_cycle type=read_write";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 address_space=32 access_width=8 access_mode=multi_cycle type=read_write";
    };
  };
  resource ALU
  {
    model "alu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 ";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=default";
    };
  };
  resource MUL
  {
    model "multiplier";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 algorithm=seq data_type=two_complement";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=seq adder_algorithm=default data_type=two_complement";
    };
  };
  resource DIV
  {
    model "divider";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 algorithm=seq data_type=two_complement";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 algorithm=seq adder_algorithm=default data_type=two_complement";
    };
  };
  resource EXT8TO32
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=8 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=8 bit_width_out=32";
    };
  };
  resource EXT16TO32
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=16 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=16 bit_width_out=32";
    };
  };
  resource EXT26TO32
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=26 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=26 bit_width_out=32";
    };
  };
  resource SFTvar
  {
    model "shifter";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 amount=variable";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 amount=variable";
    };
  };
  resource EXTINT
  {
    model "wire_in";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1";
    };
  };
  resource EXTCATCH_OUT
  {
    model "wire_out";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=1 default_output=fix_to_0";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=1 default_output=fix_to_0";
    };
  };
  resource TRAP_HAND_REG
  {
    model "register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource FWU0
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
  };
  resource FWU1
  {
    model "fwu";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 addr_width=5 stage_number=2";
    };
  };
  resource DUMMY_STREG : mask_register
  {
    model "dummy_register";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32";
    };
  };
  resource GPR : register_file
  {
    model "browregfile";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=32 num_register=32 num_read_port=2 num_write_port=1 num_bank=1";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=32 num_register=32 num_read_port=2 num_write_port=1 num_bank=1";
    };
  };
  resource EXT16TO32A
  {
    model "extender";
    for_simulation
    {
      design_level "Behavior";
      parameter "bit_width=16 bit_width_out=32";
    };
    for_synthesis
    {
      design_level "Synthesis";
      parameter "bit_width=16 bit_width_out=32";
    };
  };

/* Instruction Type */
  instr_type RR
  {
    operand [31:27] rs1;
    operand [26:22] rs2;
    operand [21:17] rd;
    opecode [16:14] f_type;
    opecode [13:6] func;
    opecode [5:0] bin000="000001";
  };
  instr_type RI
  {
    operand [31:16] const;
    operand [15:11] rs1;
    operand [10:6] rd;
    opecode [5:0] op;
  };
  instr_type MA_ST
  {
    operand [31:16] const;
    operand [15:11] rs1;
    operand [10:6] rd;
    opecode [5:0] op;
  };
  instr_type MA_LD
  {
    operand [31:16] const;
    operand [15:11] rs1;
    operand [10:6] rd;
    opecode [5:0] op;
  };
  instr_type BR
  {
    operand [31:16] const;
    operand [15:11] rs1;
    dont_care [10:6] unused;
    opecode [5:0] op;
  };
  instr_type JP
  {
    operand [31:6] const;
    opecode [5:0] op;
  };
  instr_type JPR
  {
    dont_care [31:11] unused;
    operand [10:6] rs1;
    opecode [5:0] op;
  };
  instr_type SP
  {
    dont_care [31:11] unused;
    opecode [10:6] func;
    opecode [5:0] bin000="000000";
  };
  instr_type RT
  {
    operand [31:27] rd;
    operand [26:22] rs1;
    opecode [21:11] func;
    opecode [10:6] bin000="00010";
    opecode [5:0] bin001="000000";
  };

/* I/O Port */
  top_module BrownieSTD32;
  clock_port CLK;
  reset_port RESET;
  port [31:0] IMEM_ADDR_OUT {
    direction out;
    connect_to IMAU.addr2mem;
  };
  port [31:0] IMEM_DATA_IN {
    direction in;
    connect_to IMAU.data2cpu;
  };
  port IMEM_ADDRERR_IN {
    direction in;
    connect_to IMAU.aderr2cpu;
  };
  port [31:0] DMEM_ADDR_OUT {
    direction out;
    connect_to DMAU.addr2mem;
  };
  port [31:0] DMEM_DATA_IN {
    direction in;
    connect_to DMAU.data2cpu;
  };
  port [31:0] DMEM_DATA_OUT {
    direction out;
    connect_to DMAU.data2mem;
  };
  port DMEM_REQ_OUT {
    direction out;
    connect_to DMAU.req2mem;
  };
  port DMEM_ACK_IN {
    direction in;
    connect_to DMAU.ack2cpu;
  };
  port DMEM_RW_OUT {
    direction out;
    connect_to DMAU.rw2mem;
  };
  port [1:0] DMEM_WMODE_OUT {
    direction out;
    connect_to DMAU.mode2mem;
  };
  port DMEM_EMODE_OUT {
    direction out;
    connect_to DMAU.ext2mem;
  };
  port DMEM_ADDRERR_IN {
    direction in;
    connect_to DMAU.aderr2cpu;
  };
  port DMEM_CANCEL_OUT {
    direction out;
    connect_to DMAU.cancel2mem;
  };
  port EXTINT_IN {
    direction in;
    connect_to internal_controller;
  };
  port EXTCATCH_OUT {
    direction out;
    connect_to EXTCATCH_OUT.ext_port;
  };

/* Exception */
  reset_interrupt RESET {
    cause_condition {
      port RESET;
      active_value '1';
    };
  };
  external_interrupt EXTINT {
    cause_condition {
      port EXTINT_IN;
      active_value '1';
    };
    mask_condition {
      mask_register DUMMY_STREG;
      mask_bitpos 8;
      active_value '0';
    };
  };
  internal_interrupt TRAPINT {
    cause_condition_type instr_specific;
    mask_condition {
      mask_register DUMMY_STREG;
      mask_bitpos 9;
      active_value '0';
    };
  };

  catch_interrupt EXTINT {
    wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire        one;

    ret_addr     = saved_pc;                           // Get saved pc
    //handler_addr = "00001111111111100000010000000000"; // 0x0FFE0400 (fixed)
    //handler_addr = "00000000000000000011010000000000"; // 0x0FFE0400 (fixed)
    handler_addr = "00000000000000001111010000000000"; // 0x0000F400 (fixed)
    mask         = "11111111111111111011110011111111"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
    rsave        = "00010";                            // R2 (Interrupt Return)
    rstatus      = "00001";                            // R1 (Status Register)
    one          = '1';
    
    current_st   = DUMMY_STREG.read();                 // load current status
    new_st       = current_st & mask;                  // masking interrupts
    
    null = EXTCATCH_OUT.write(one);                    // output catch signal for 1 cycle
    null = GPR.write0(rsave, ret_addr);                // write return address
    null = GPR.status_write(new_st);                   // write masked status
    null = PC.write(handler_addr);                     // jump to the handler
  };
  catch_interrupt RESET {
    wire [31:0] reset_handler;

    // set the pc 0x0FFE0000
    //reset_handler = "00001111111111100000000000000000";
    //reset_handler = "00000000000000000011000000000000";
    reset_handler = "00000000000000001111000000000000"; // 0x0000F000 (fixed)
    null = PC.write(reset_handler);
    
    // reset all memories
    null = GPR.reset();
    null = IR.reset();
    null = DIV.reset();
    null = MUL.reset();
    null = TRAP_HAND_REG.reset();
  };
  catch_interrupt TRAPINT {
    wire [31:0] ret_addr;
wire [31:0] handler_addr;
wire [4:0]  rsave;
wire [4:0]  rstatus;
wire [31:0] mask;
wire [31:0] current_st;
wire [31:0] new_st;
wire [31:0] trap_factor;
wire [31:0] trap_base;
wire [3:0]  trap_alu_flag;

    ret_addr     = saved_pc;                           // Get saved pc
    //trap_base    = "00001111111111100000100000000000"; // 0x0FFE0800 (fixed)
    //trap_base    = "00000000000000000011100000000000"; // 0x0FFE0800 (fixed)
    trap_base    = "00000000000000001111100000000000"; // 0x0000F800 (fixed)
    mask         = "11111111111111111011110011111111"; // clear 8,9 bit and 14 bit (interrupt mask and set the mode kernel)
    rsave        = "00010";                            // R2 (Interrupt Return)
    rstatus      = "00001";                            // R1 (Status Register)
    
    current_st   = DUMMY_STREG.read();                 // load current status
    new_st       = current_st & mask;                  // masking interrupts
    
    trap_factor  = TRAP_HAND_REG.read();               // get trap factor
    <handler_addr, trap_alu_flag>
                 = ALU.add(trap_base, trap_factor);    // calculate dest. addr.
    
    
    null = GPR.write0(rsave, ret_addr);                // write return address
    null = GPR.status_write(new_st);                   // write masked status
    null = PC.write(handler_addr);                     // jump to the handler
  };

/* Instruction */
  instruction ADD : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction SUB : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[sub] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.sub(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction MUL : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  mul_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [63:0]  mul_exec_tmp_result;
      
      // multiplier execution
      mul_exec_tmp_result = MUL.mul(source1, source2);
      mul_result          = mul_exec_tmp_result[31:0];
      // foward mul_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, mul_result);
      null = FWU1.forward1(rd, mul_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, mul_result);        // write mul_result[arg2] to GPR[arg1]
      // foward mul_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, mul_result);
      null = FWU1.forward2(rd, mul_result);
    };
  };
  instruction DIV : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.div(source1, source2);
      // foward div_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, div_result);
      null = FWU1.forward1(rd, div_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, div_result);        // write div_result[arg2] to GPR[arg1]
      // foward div_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, div_result);
      null = FWU1.forward2(rd, div_result);
    };
  };
  instruction DIVU : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.divu(source1, source2);
      // foward div_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, div_result);
      null = FWU1.forward1(rd, div_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, div_result);        // write div_result[arg2] to GPR[arg1]
      // foward div_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, div_result);
      null = FWU1.forward2(rd, div_result);
    };
  };
  instruction MOD : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.div(source1, source2);
      // foward mod_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, mod_result);
      null = FWU1.forward1(rd, mod_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, mod_result);        // write mod_result[arg2] to GPR[arg1]
      // foward mod_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, mod_result);
      null = FWU1.forward2(rd, mod_result);
    };
  };
  instruction MODU : RR
  {
    opecode  f_type = "000";
    opecode  func = "00000110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  div_result;
    wire [31:0]  mod_result; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire div_exec_div_flag;
      
      // division execution
      <div_result, mod_result, div_exec_div_flag> = DIV.divu(source1, source2);
      // foward mod_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, mod_result);
      null = FWU1.forward1(rd, mod_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, mod_result);        // write mod_result[arg2] to GPR[arg1]
      // foward mod_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, mod_result);
      null = FWU1.forward2(rd, mod_result);
    };
  };
  instruction AND : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[and] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.and(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction NAND : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[nand] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.nand(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction OR : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[or] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.or(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction NOR : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[nor] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.nor(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction XOR : RR
  {
    opecode  f_type = "001";
    opecode  func = "00000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      // execute operation[xor] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.xor(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction LLS : RR
  {
    opecode  f_type = "010";
    opecode  func = "00000000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
      sft_amt = source2[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sll(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction LRS : RR
  {
    opecode  f_type = "010";
    opecode  func = "00000001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
      sft_amt = source2[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.srl(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction ARS : RR
  {
    opecode  f_type = "010";
    opecode  func = "00000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
      sft_amt = source2[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sra(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction ELT : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000000";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_lt>;                    // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction ELTU : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000001";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_ult>;                   // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction EEQ : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000010";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_equal>;                 // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction ENEQ : RR
  {
    opecode  f_type = "011";
    opecode  func = "00000011";

    wire [31:0] cmp_result;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    /* we can use only cmp_flags corresponding chosen operation */
    
    wire cmp_equal;  /* equal to */
    wire cmp_nequal; /* not equal to */
    wire cmp_lt;     /* less than */
    wire cmp_ult;    /* unsigned less than */ wire [4:0] rs1; wire [4:0] rs2; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_stmp1;
      wire [31:0]  gpr_double_read_stmp2;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[31:27]; rs2 = tmp_ir[26:22]; rd = tmp_ir[21:17]; // prefetch GPR data to stmp1/stmp2
      gpr_double_read_stmp1   = GPR.read0(rs1);
      gpr_double_read_stmp2   = GPR.read1(rs2);
      
      // get source value
      // from GPR or forwarded value selectively
      source1  = FWU0.forward(rs1, gpr_double_read_stmp1);
      source2  = FWU1.forward(rs2, gpr_double_read_stmp2);
    };

    stage 3 :
    {
      wire [30:0] zero;
      wire [3:0] alu_cmp_alu_flag;
      wire [1:0] alu_cmp_tmp_flag;
      wire       alu_cmp_lt_cond1;
      wire       alu_cmp_lt_cond2;
      wire       alu_cmp_carry;
      
      alu_cmp_alu_flag = ALU.cmp(source1, source2);
      
      // calculate each flag
      // equal to is evaluated depending on zero flag
      cmp_equal  = alu_cmp_alu_flag[2];
      
      // not equal to is negative of cmp_equal
      cmp_nequal = ~cmp_equal;
      
      // signed less than is either sign bit is 1 with no overflow
      //                     or     sign bit is 0 with overflow
      alu_cmp_tmp_flag   = alu_cmp_alu_flag[1:0];
      
      alu_cmp_lt_cond1   = alu_cmp_tmp_flag == "10";
      alu_cmp_lt_cond2   = alu_cmp_tmp_flag == "01";
      cmp_lt             = alu_cmp_lt_cond1 | alu_cmp_lt_cond2;
      
      // unsigned less than is negative carry
      alu_cmp_carry      = alu_cmp_alu_flag[3];
      cmp_ult            = ~alu_cmp_carry;
      zero       = "0000000000000000000000000000000"; // 31 bits zeros
      cmp_result = <zero, cmp_nequal>;                // zero extension
      // foward cmp_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, cmp_result);
      null = FWU1.forward1(rd, cmp_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, cmp_result);        // write cmp_result[arg2] to GPR[arg1]
      // foward cmp_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, cmp_result);
      null = FWU1.forward2(rd, cmp_result);
    };
  };
  instruction ADDI : RI
  {
    opecode  op = "100000";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction SUBI : RI
  {
    opecode  op = "100001";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [4:0] update_streg_flag_stfl_in;
      wire       update_streg_flag_reserved_bits;
      
      // execute operation[sub] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.sub(source1, source2);
      update_streg_flag_reserved_bits = '0';
      update_streg_flag_stfl_in       = <update_streg_flag_reserved_bits, alu_flag>;
      
      // we can update flag using the function of flag_update
      null                            = GPR.flag_update(update_streg_flag_stfl_in);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction ANDI : RI
  {
    opecode  op = "100010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[and] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.and(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction ORI : RI
  {
    opecode  op = "100011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[or] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.or(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction XORI : RI
  {
    opecode  op = "100100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[xor] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.xor(source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction LLSI : RI
  {
    opecode  op = "100101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
      sft_amt = const[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sll(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction LRSI : RI
  {
    opecode  op = "100110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
      sft_amt = const[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.srl(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction ARSI : RI
  {
    opecode  op = "100111";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1;
    wire [31:0]  sft_result;
    wire [4:0] sft_amt; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
      sft_amt = const[4:0];
    };

    stage 3 :
    {
      // shift execution
      sft_result       = SFTvar.sra(source1, sft_amt);
      // foward sft_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, sft_result);
      null = FWU1.forward1(rd, sft_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, sft_result);        // write sft_result[arg2] to GPR[arg1]
      // foward sft_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, sft_result);
      null = FWU1.forward2(rd, sft_result);
    };
  };
  instruction LSOI : RI
  {
    opecode  op = "101000";

    wire [31:0] shifted_source1;
    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [15:0] lower_bits;
      wire [15:0] zeros;
      // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.zero(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
      // shift source data before OR
      lower_bits      = source1[15:0];
      zeros           = "0000000000000000";
      shifted_source1 = <lower_bits, zeros>;
    };

    stage 3 :
    {
      // execute operation[or] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.or(shifted_source1, source2);
      // foward alu_result to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, alu_result);
      null = FWU1.forward1(rd, alu_result);
    };

    stage 4 :
    {
      null = GPR.write0(rd, alu_result);        // write alu_result[arg2] to GPR[arg1]
      // foward alu_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, alu_result);
      null = FWU1.forward2(rd, alu_result);
    };
  };
  instruction LB : MA_LD
  {
    opecode  op = "000010";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag;
    wire [31:0] load_result; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
    };

    stage 4 :
    {
      wire        load_alu_result_err;
      
      // result is 32bit data. already extended
      <load_result, load_alu_result_err> = DMAU.ld_8(alu_result);
      null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
      // foward load_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, load_result);
      null = FWU1.forward2(rd, load_result);
    };
  };
  instruction LH : MA_LD
  {
    opecode  op = "000011";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag;
    wire [31:0] load_result; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
    };

    stage 4 :
    {
      wire        load_alu_result_err;
      
      // result is 32bit data. already extended
      <load_result, load_alu_result_err> = DMAU.ld_16(alu_result);
      null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
      // foward load_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, load_result);
      null = FWU1.forward2(rd, load_result);
    };
  };
  instruction LW : MA_LD
  {
    opecode  op = "000100";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag;
    wire [31:0] load_result; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source2);
    };

    stage 4 :
    {
      wire        load_alu_result_err;
      
      // result is 32bit data. already extended
      <load_result, load_alu_result_err> = DMAU.ld_32(alu_result);
      null = GPR.write0(rd, load_result);        // write load_result[arg2] to GPR[arg1]
      // foward load_result to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, load_result);
      null = FWU1.forward2(rd, load_result);
    };
  };
  instruction SB : MA_ST
  {
    opecode  op = "000101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  source3;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_ext16to32_stmp1;
      wire [31:0]  gpr_double_read_ext16to32_stmp2;
      wire [31:0]  gpr_double_read_ext16to32_stmp3;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      // and also, STATUS_REG data to stmp3
      gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
      gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
      gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
      source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
      source3 = gpr_double_read_ext16to32_stmp3;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source3);
    };

    stage 4 :
    {
      wire         store_alu_result_err;
      
      // result is 32bit source2. already extended
      store_alu_result_err = DMAU.s_8(alu_result, source2);
    };
  };
  instruction SH : MA_ST
  {
    opecode  op = "000110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  source3;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_ext16to32_stmp1;
      wire [31:0]  gpr_double_read_ext16to32_stmp2;
      wire [31:0]  gpr_double_read_ext16to32_stmp3;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      // and also, STATUS_REG data to stmp3
      gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
      gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
      gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
      source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
      source3 = gpr_double_read_ext16to32_stmp3;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source3);
    };

    stage 4 :
    {
      wire         store_alu_result_err;
      
      // result is 32bit source2. already extended
      store_alu_result_err = DMAU.s_16(alu_result, source2);
    };
  };
  instruction SW : MA_ST
  {
    opecode  op = "000111";

    /* these variables can be used in following stages of all instructions */
    wire [31:0]  source1;
    wire [31:0]  source2;
    wire [31:0]  source3;
    wire [31:0]  alu_result;
    wire [3:0]   alu_flag; wire [15:0] const; wire [4:0] rs1; wire [4:0] rd;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0]  gpr_double_read_ext16to32_stmp1;
      wire [31:0]  gpr_double_read_ext16to32_stmp2;
      wire [31:0]  gpr_double_read_ext16to32_stmp3;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; rd = tmp_ir[10:6]; // prefetch GPR data to stmp1/stmp2
      // and also, STATUS_REG data to stmp3
      gpr_double_read_ext16to32_stmp1 = GPR.read0(rd);
      gpr_double_read_ext16to32_stmp2 = GPR.read1(rs1);
      gpr_double_read_ext16to32_stmp3 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rd, gpr_double_read_ext16to32_stmp1);
      source2 = FWU1.forward(rs1, gpr_double_read_ext16to32_stmp2);
      source3 = gpr_double_read_ext16to32_stmp3;
    };

    stage 3 :
    {
      // execute operation[add] using data arg1 and arg2
      <alu_result, alu_flag> = ALU.add(source1, source3);
    };

    stage 4 :
    {
      wire         store_alu_result_err;
      
      // result is 32bit source2. already extended
      store_alu_result_err = DMAU.s_32(alu_result, source2);
    };
  };
  instruction BRZ : BR
  {
    opecode  op = "001001";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0]  source1;
    wire [31:0]  source2; wire [15:0] const; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; pcread_result = PC.read();
      // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [31:0] relative_branchz_abs_addr;
      wire [3:0]  relative_branchz_alu_flag;
      wire        relative_branchz_cond;
      
      // evaluate source1 equal or not equal to zero
      relative_branchz_cond = source1 == "00000000000000000000000000000000";
      
      // branch according to the cond
      <relative_branchz_abs_addr, relative_branchz_alu_flag> 
                           = ALU.add(pcread_result, source2);  // calu. absolute address
      null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch
    };

    stage 4 :
    {
      
    };
  };
  instruction BRNZ : BR
  {
    opecode  op = "001010";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0]  source1;
    wire [31:0]  source2; wire [15:0] const; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       // prefetched data
      wire [31:0] gpr_read_ext16to32_stmp1;
      wire [31:0] gpr_read_ext16to32_stmp2;
      
      tmp_ir = IR.read(); const = tmp_ir[31:16]; rs1 = tmp_ir[15:11]; pcread_result = PC.read();
      // prefetch GPR data to stmp1/stmp2
      gpr_read_ext16to32_stmp1 = GPR.read0(rs1);
      gpr_read_ext16to32_stmp2 = EXT16TO32.sign(const);
      
      // get source value
      // from GPR or forwarded value selectively
      source1 = FWU0.forward(rs1, gpr_read_ext16to32_stmp1);
      source2 = gpr_read_ext16to32_stmp2;
    };

    stage 3 :
    {
      wire [31:0] relative_branchz_abs_addr;
      wire [3:0]  relative_branchz_alu_flag;
      wire        relative_branchz_cond;
      
      // evaluate source1 equal or not equal to zero
      relative_branchz_cond = source1 != "00000000000000000000000000000000";
      
      // branch according to the cond
      <relative_branchz_abs_addr, relative_branchz_alu_flag> 
                           = ALU.add(pcread_result, source2);  // calu. absolute address
      null                 = [relative_branchz_cond] PC.write(relative_branchz_abs_addr); // branch
    };

    stage 4 :
    {
      
    };
  };
  instruction JP : JP
  {
    opecode  op = "001011";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0] ext26to32_result; wire [25:0] const;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); const = tmp_ir[31:6]; pcread_result = PC.read();
      ext26to32_result = EXT26TO32.sign(const);
    };

    stage 3 :
    {
      wire [31:0] relative_jump_abs_addr;
      wire [3:0]  relative_jump_alu_flag;
      
      <relative_jump_abs_addr, relative_jump_alu_flag> 
                           = ALU.add(pcread_result, ext26to32_result);         // calu. absolute address
      null                 = PC.write(relative_jump_abs_addr); // jump
    };

    stage 4 :
    {
      
    };
  };
  instruction JPL : JP
  {
    opecode  op = "001100";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0] ext26to32_result; wire [25:0] const;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); const = tmp_ir[31:6]; pcread_result = PC.read();
      ext26to32_result = EXT26TO32.sign(const);
    };

    stage 3 :
    {
      wire [4:0] linkreg_idx;
      wire [31:0] relative_jump_abs_addr;
      wire [3:0]  relative_jump_alu_flag;
      
      linkreg_idx = "00011";
      <relative_jump_abs_addr, relative_jump_alu_flag> 
                           = ALU.add(pcread_result, ext26to32_result);         // calu. absolute address
      null                 = PC.write(relative_jump_abs_addr); // jump
      // foward pcread_result to as GPR[linkreg_idx] from stage EXE
      null = FWU0.forward1(linkreg_idx, pcread_result);
      null = FWU1.forward1(linkreg_idx, pcread_result);
    };

    stage 4 :
    {
      wire [4:0] linkreg_idx;
      
      linkreg_idx = "00011";
      null = GPR.write0(linkreg_idx, pcread_result);        // write pcread_result[arg2] to GPR[arg1]
      // foward pcread_result to as GPR[linkreg_idx] from stage WB
      null = FWU0.forward2(linkreg_idx, pcread_result);
      null = FWU1.forward2(linkreg_idx, pcread_result);
    };
  };
  instruction TRAP : JP
  {
    opecode  op = "001101";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] ext26to32_result; wire [25:0] const;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); const = tmp_ir[31:6]; ext26to32_result = EXT26TO32.zero(const);
      // store handler address
      // this address will be used in TRAP_INT
      null = TRAP_HAND_REG.write(ext26to32_result);
    };

    stage 3 :
    {
      // throw exception
      throw TRAPINT;
    };

    stage 4 :
    {
      
    };
  };
  instruction JPR : JPR
  {
    opecode  op = "001110";

    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[10:6]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      null = PC.write(source1); // jump according to absolute address
    };

    stage 4 :
    {
      
    };
  };
  instruction JPRL : JPR
  {
    opecode  op = "001111";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] pcread_result;
    wire [31:0] source1; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rs1 = tmp_ir[10:6]; pcread_result = PC.read();
      // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      wire [4:0] linkreg_idx;
      
      linkreg_idx = "00011";
      null = PC.write(source1); // jump according to absolute address
      // foward pcread_result to as GPR[linkreg_idx] from stage EXE
      null = FWU0.forward1(linkreg_idx, pcread_result);
      null = FWU1.forward1(linkreg_idx, pcread_result);
    };

    stage 4 :
    {
      wire [4:0] linkreg_idx;
      
      linkreg_idx = "00011";
      null = GPR.write0(linkreg_idx, pcread_result);        // write pcread_result[arg2] to GPR[arg1]
      // foward pcread_result to as GPR[linkreg_idx] from stage WB
      null = FWU0.forward2(linkreg_idx, pcread_result);
      null = FWU1.forward2(linkreg_idx, pcread_result);
    };
  };
  instruction NOP : SP
  {
    opecode  func = "00000";

    /* these variables can be used in following stages of all instructions */

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       
      
      tmp_ir = IR.read(); 
    };

    stage 3 :
    {
      
    };

    stage 4 :
    {
      
    };
  };
  instruction RETI : SP
  {
    opecode  func = "00001";

    /* these variables can be used in following stages of all instructions */
    /* these variables can be used in following stages of all instructions */
    wire [31:0] streg_read_result;
    wire [31:0] source1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [4:0] ret_idx;
      wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); ret_idx = "00010";                // interrupt return address is stored in GPR2
      // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(ret_idx);
      source1        = FWU0.forward(ret_idx, gpr_read_stmp1);
      // get return address
      streg_read_result = DUMMY_STREG.read();
    };

    stage 3 :
    {
      wire [31:0] new_st;
      wire [31:0] mask;
      
      mask         = "00000000000000000100001100000000"; // clear interrupt mask and move to user mode
      new_st       = streg_read_result | mask;           // 
      null         = GPR.status_write(new_st);           // update status register (interrupt will be enabled at next cycle)
      null = PC.write(source1); // jump according to absolute address
    };

    stage 4 :
    {
      
    };
  };
  instruction EXBW : RT
  {
    opecode  func = "00000000000";

    wire [31:0] extended_data;
    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1; wire [4:0] rd; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rd = tmp_ir[31:27]; rs1 = tmp_ir[26:22]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      wire [7:0] target;
      
      target        = source1[7:0];
      extended_data = EXT8TO32.sign(target);
      // foward extended_data to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, extended_data);
      null = FWU1.forward1(rd, extended_data);
    };

    stage 4 :
    {
      null = GPR.write0(rd, extended_data);        // write extended_data[arg2] to GPR[arg1]
      // foward extended_data to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, extended_data);
      null = FWU1.forward2(rd, extended_data);
    };
  };
  instruction EXHW : RT
  {
    opecode  func = "00000000001";

    wire [31:0] extended_data;
    /* these variables can be used in following stages of all instructions */
    wire [31:0] source1; wire [4:0] rd; wire [4:0] rs1;

    stage 1 :
    {
      wire [31:0]  fetch_current_pc;                              // current pc
      wire [31:0]  fetch_inst;                                    // opecode
      wire         fetch_addrerr;                                 // address err. from IM
      wire [31:0]  fetch_status_data;
      
      // the value of status register
      
      fetch_current_pc            = PC.read();                    // reading PC
      <fetch_inst, fetch_addrerr> = IMAU.ld_32(fetch_current_pc); // reading instruction's opcode
      null                        = IR.write(fetch_inst);         // writing opecode to IR
      null                        = PC.inc();                     // incrementing PC
      
      // pull out the current value of status register
      // and connect to the dummy_register so that used as mask register
      fetch_status_data           = GPR.status_read();
      null                        = DUMMY_STREG.write(fetch_status_data);
    };

    stage 2 :
    {
      wire [31:0] tmp_ir;       wire [31:0] gpr_read_stmp1;
      
      tmp_ir = IR.read(); rd = tmp_ir[31:27]; rs1 = tmp_ir[26:22]; // prefetch data from GPR,
      // then choose either the data or the forwarded one
      gpr_read_stmp1 = GPR.read0(rs1);
      source1        = FWU0.forward(rs1, gpr_read_stmp1);
    };

    stage 3 :
    {
      wire [15:0] target;
      
      target        = source1[15:0];
      extended_data = EXT16TO32A.sign(target);
      // foward extended_data to as GPR[rd] from stage EXE
      null = FWU0.forward1(rd, extended_data);
      null = FWU1.forward1(rd, extended_data);
    };

    stage 4 :
    {
      null = GPR.write0(rd, extended_data);        // write extended_data[arg2] to GPR[arg1]
      // foward extended_data to as GPR[rd] from stage WB
      null = FWU0.forward2(rd, extended_data);
      null = FWU1.forward2(rd, extended_data);
    };
  };
}
