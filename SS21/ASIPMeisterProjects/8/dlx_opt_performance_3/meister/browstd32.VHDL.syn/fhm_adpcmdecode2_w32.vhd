--
-- Copyright (C) 2011 ASIP Solutions, Inc. All rights reserved. 
-- Generated by ASIP Meister 2.3 on 2021/06/29 06:22:20 
--
--   int_port : internal port
--   ext_port : external port

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

entity fhm_adpcmdecode2_w32 is
  port (
	clock    : in std_logic;
        reset    : in std_logic;
        enb      : in std_logic;
        in_1  : in std_logic_vector(31 downto 0);
        in_2  : in std_logic_vector(31 downto 0);
        index_in : in std_logic_vector(31 downto 0);
        output_in : in std_logic_vector(31 downto 0);
        out_1 : out std_logic_vector(31 downto 0);
        out_2 : out std_logic_vector(31 downto 0);
        index_out : out std_logic_vector(31 downto 0)
        );
end fhm_adpcmdecode2_w32;

architecture Behavioral of fhm_adpcmdecode2_w32 is
-- Your signal declaration here
type array_type1 is array (0 to 88) of integer; 
signal stepsizeTable : array_type1:=( 7, 8, 9, 10, 11, 12, 13, 14, 16,
  	17,
    19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
    50, 55, 60, 66, 73, 80, 88, 97, 107, 118,
    130, 143, 157, 173, 190, 209, 230, 253, 279, 307,
    337, 371, 408, 449, 494, 544, 598, 658, 724, 796,
    876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,
    2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,
    5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,
    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767);  

type array_type2 is array (0 to 15) of integer; 
signal indexTable : array_type2:=( -1, -1, -1, -1, 2, 4, 6, 8,
                                   -1, -1, -1, -1, 2, 4, 6, 8 );


begin
  -- Your vhdl code here
  process (clock, reset, enb)

  variable upper : integer := 88;
  variable lower : integer := 0;

  variable delta_1 : unsigned (3 downto 0);
  variable delta_2 : unsigned (3 downto 0);
  variable delta_3 : unsigned (3 downto 0);
  variable delta_4 : unsigned (3 downto 0);

  variable step_1 : integer;
  variable step_2 : integer;
  variable step_3 : integer;
  variable step_4 : integer;
  variable index_1 : integer;
  variable index_2 : integer;
  variable index_3 : integer;
  variable index_4 : integer;
  variable step_v : signed (31 downto 0);
  variable vpdiff : signed (31 downto 0);
  variable out_1_s : signed (31 downto 0);
  variable out_2_s : signed (31 downto 0);
  variable out_3_s : signed (31 downto 0);
  variable out_4_s : signed (31 downto 0);

  begin
  
      if (enb = '1') then

	delta_1 := unsigned(in_1(7 downto 4));
	delta_2 := unsigned(in_1(3 downto 0));
	delta_3 := unsigned(in_2(7 downto 4));
	delta_4 := unsigned(in_2(3 downto 0));

	step_1 := stepsizeTable(to_integer(unsigned(index_in)));
	index_1 := indexTable(to_integer(delta_1)) +
  	to_integer(unsigned(index_in));
	if (index_1 < lower) then
		index_1 := lower;
	elsif (index_1 > upper) then
		index_1 := upper;
	end if;

	step_2 := stepsizeTable(index_1);
	index_2 := indexTable(to_integer(delta_2)) + index_1;
	if (index_2 < lower) then
		index_2 := lower;
	elsif (index_2 > upper) then
		index_2 := upper;
	end if;

	step_3 := stepsizeTable(index_2);
	index_3 := indexTable(to_integer(delta_3)) + index_2;
	if (index_3 < lower) then
		index_3 := lower;
	elsif (index_3 > upper) then
		index_3 := upper;
	end if;

	step_4 := stepsizeTable(index_3);
	index_4 := indexTable(to_integer(delta_4)) + index_3;
	if (index_4 < lower) then
		index_4 := lower;
	elsif (index_4 > upper) then
		index_4 := upper;
	end if;
	index_out <= std_logic_vector(to_unsigned(index_4, 32));

	step_v := to_signed(step_1, 32);
	vpdiff := shift_right(step_v, 3);
	if (delta_1(2) ='1') then
		vpdiff := vpdiff + step_v;
	end if;
	if (delta_1(1) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 1);
	end if;
	if (delta_1(0) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 2);
	end if;
	if(delta_1(3)='1') then
		out_1_s := signed(output_in) - vpdiff;
	else
		out_1_s := signed(output_in) + vpdiff;
	end if;

	step_v := to_signed(step_2, 32);
	vpdiff := shift_right(step_v, 3);
	if (delta_2(2) ='1') then
		vpdiff := vpdiff + step_v;
	end if;
	if (delta_2(1) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 1);
	end if;
	if (delta_2(0) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 2);
	end if;
	if(delta_2(3)='1') then
		out_2_s := out_1_s - vpdiff;
	else
		out_2_s := out_1_s + vpdiff;
	end if;

	step_v := to_signed(step_3, 32);
	vpdiff := shift_right(step_v, 3);
	if (delta_3(2) ='1') then
		vpdiff := vpdiff + step_v;
	end if;
	if (delta_3(1) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 1);
	end if;
	if (delta_3(0) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 2);
	end if;
	if(delta_3(3)='1') then
		out_3_s := out_2_s - vpdiff;
	else
		out_3_s := out_2_s + vpdiff;
	end if;

	step_v := to_signed(step_4, 32);
	vpdiff := shift_right(step_v, 3);
	if (delta_4(2) ='1') then
		vpdiff := vpdiff + step_v;
	end if;
	if (delta_4(1) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 1);
	end if;
	if (delta_4(0) ='1') then
		vpdiff := vpdiff + shift_right(step_v, 2);
	end if;
	if(delta_4(3)='1') then
		out_4_s := out_3_s - vpdiff;
	else
		out_4_s := out_3_s + vpdiff;
	end if;

	out_1 <= std_logic_vector(out_1_s(15 downto 0) & out_2_s(15 downto
  	0));
	out_2 <= std_logic_vector(out_3_s(15 downto 0) & out_4_s(15 downto
  	0));

      end if;
  end process;

end Behavioral;


-----------------------------------------
-- Generated by ASIP Meister ver.2.3.4 --
-----------------------------------------
