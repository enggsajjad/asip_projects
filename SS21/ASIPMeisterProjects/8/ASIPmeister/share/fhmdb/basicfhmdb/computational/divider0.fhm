<?xml version="1.0" encoding="UTF-8" ?>
<FHM>
  <model_name> divider </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko UEDA ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%                 Copyright 2002 PEAS Project                    %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> two_complement </value>
        <value> abs </value>
        <value> unsigned </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp div(twoscomp a, towscomp b);
unsigned div(unsigned a, unsigned b);
twoscomp mod(twoscomp a, towscomp b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(twoscomp a, towscomp b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn div(signmagn a, signmagn b);
signmagn mod(signmagn a, signmagn b);
Boolean  flag_div(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned div(unsigned a, unsigned b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC

/** $bit_width-bit $data_type divider */
model ${data_type}_div${bit_width}{
  port{
    in reset, clear, start;
    in a[$w_1:0], b[$w_1:0];
    in mode;
    out q[$w_1:0], r[$w_1:0], flag;
    out fin;
  }
  default_control{
    reset = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in reset;
    }
    protocol{
      [reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", "twoscomp", 1, 1);
    &print_func("unsigned division", "divu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type q = div(a, b);
      $d_type r = mod(a, b);
      Boolean flag = flag_div(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
	print <<FHM_DL_SUB_SIGNED
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_SIGNED
    }
    else{
	print <<FHM_DL_SUB_NOSIGNED
    control{
      out fin;
    }
    protocol{
      [true]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_NOSIGNED
    }
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", 1, 1);
    &print_func("unsigned division", "divu", 1, 0);
    exit (0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", 0);
    exit (0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", 0);
    exit (0);
}
else{
    print "false\n";
    exit (100);
}

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $mode      = $_[2];
    $mode_val  = $_[3];

    {
	print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w_1:0] a;
    bit [$w_1:0] b;
  }

  output{
    bit [$w_1:0] q;
    bit [$w_1:0] r;
    bit        flag;
  }

  control{
FHM_DL_FUNC1
    }
  
    if ($mode == 1){
	print "    in  bit mode;\n";
    }

    print "  }\n\n  protocol{\n";

    if ($mode == 1){
	print <<FHM_DL_FUNC2
    single_cycle_protocol{
      mode = '$mode_val';
    }
FHM_DL_FUNC2
    }

    print <<FHM_DL_FUNC3
  }
}

FHM_DL_FUNC3
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generate port infomation for divider in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$data_type     = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_PORT
clock	in	bit		clock
reset	in	bit		reset
clear	in	bit		ctrl
a	in	bit_vector   $w_1   0	data
b	in	bit_vector   $w_1   0	data
start	in	bit		ctrl
mode	in	bit		mode
q	out	bit_vector   $w_1   0	data
r	out	bit_vector   $w_1   0	data
flag	out	bit		data
fin	out	bit		ctrl
FHM_DL_PORT
}
exit (0);

        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = $bit_width*2-1;
$w3 = $bit_width - 2;
$xs = 'X' x $bit_width;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n--              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

{
print <<FHM_DL_INSTANCE;
-- Module     : $bit_width-bit Divider
-- Feature    : 
-- References :
-- Author     : Designed by T.Morifuji (c) 1996,1999
--              Modified by K.Ueda (c)2002
-- Version    : 2.0  : change functionality
-- VHDL       : 87

-- Functionality : behavioral level
--  port
--   clock    : (ignore)
--   reset    : (ignore)
--   clear    : (ignore)
--   a        : dividend
--   b        : divisor
--   start    : (ignore)
--   mode     : $mode_comment
--   q        : result of a / b
--   r        : reminder of a / b
--   flag     : '1' if b = 0
--   fin      : '1' when operation is over

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_signed.all;

entity $instance_name is
  port (clock  : in  std_logic;
        reset  : in  std_logic;
	clear  : in  std_logic;
        a, b   : in  std_logic_vector($w downto 0);
        start  : in  std_logic;
        mode   : in  std_logic;
        q      : out std_logic_vector($w downto 0);
        r      : out std_logic_vector($w downto 0);
        flag   : out std_logic;
        fin    : out std_logic);
end $instance_name;

architecture behavior of $instance_name is
begin
  process (a, b, mode)
    variable tmp_a, tmp_b : std_logic_vector($w2 downto 0);
    variable tmp_result : std_logic_vector($w downto 0);
FHM_DL_INSTANCE
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    variable sign : boolean;
  begin
    if (mode='1' and ((a($w) xor b($w)) = '1')) then
      sign := true;
    else
      sign := false;
    end if;
    if (mode='1' and a($w)='1') then
      tmp_a($w downto 0) := not a + 1;
    else
      tmp_a($w downto 0) := a;
    end if;
    tmp_a($w2 downto $bit_width) := (others => '0');
    
    if (mode='1' and b($w) = '1') then
      tmp_b($w2 downto $w) := '0' & (not b + 1);
    else
      tmp_b($w2 downto $w) := '0' & b;
    end if;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
  begin
    if (a($w) = '1') then
      tmp_a($w downto 0) := not a + 1;
    else
      tmp_a($w downto 0) := a;
    end if;
    tmp_a($w2 downto $bit_width) := (others => '0');
    if (b($w) = '1') then
      tmp_b($w2 downto $w) := '0' & (not b + 1);
    else
      tmp_b($w2 downto $w) := '0' & b;
    end if;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
  begin
    tmp_a($w downto 0) := a;
    tmp_a($w2 downto $bit_width) := (others => '0');
    tmp_b($w2 downto $w) := '0' & b;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE4
}
{
    print <<FHM_DL_INSTANCE5;
    
    for i in $w downto 0 loop
      if ((tmp_a /= 0) and (tmp_a - tmp_b >= 0)) then
        tmp_result(i) := '1';
        tmp_a := tmp_a - tmp_b;
      else
        tmp_result(i) := '0';
      end if;
      tmp_b := '0' & tmp_b($w2 downto 1);
    end loop;  -- i
FHM_DL_INSTANCE5
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE6;

    if (sign) then
      tmp_result := not tmp_result + 1;
    end if;
    if (mode = '1' and a($w) = '1') then
      tmp_a := not tmp_a + 1;
    end if;
FHM_DL_INSTANCE6
}
{
	print <<FHM_DL_INSTANCE7;

    if (b = 0) then
      flag <= '1';
      q <= "$xs";
      r <= "$xs";
    else
      flag <= '0';
      -- divided
      q <= tmp_result;
      -- modulo
      r <= tmp_a($w downto 0);
    end if;
    fin <= '1';
  end process;
end behavior;
FHM_DL_INSTANCE7
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates entity for divider in behavior level
# parameter : bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_ENTITY
entity $instance_name is
  port (clock    : in  std_logic;
	reset    : in  std_logic;
        clear    : in  std_logic;
        a, b     : in  std_logic_vector($w_1 downto 0);
	start    : in  std_logic;
        mode     : in  std_logic;
        q        : out std_logic_vector($w_1 downto 0);
        r        : out std_logic_vector($w_1 downto 0);
        flag     : out std_logic;
        fin      : out std_logic );
end $instance_name;
FHM_DL_ENTITY
}
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for divider in behavior level
# parameter : instance_name priority bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$data_type     = $ARGV[3];

if ($priority eq "area"){
    $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
    $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
    $priority_const = "";
}
elsif ($priority eq "none"){
    $priority_const = "";
}
else{
    print "priority $priority is not supported.\n";
    exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
     
        <library name="OSAKA">

          <est_type name="shape">

            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 0.098831 </data>
                  <data bit_width="8"> 0.264286 </data>
                  <data bit_width="16"> 0.924646 </data>
                  <data bit_width="32"> 3.214213 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.018183 </data>
                  <data bit_width="8"> 0.083210 </data>
                  <data bit_width="16"> 0.202057 </data>
                  <data bit_width="32"> 0.412350 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 0.090421 </data>
                  <data bit_width="8"> 0.236262 </data>
                  <data bit_width="16"> 0.857676 </data>
                  <data bit_width="32"> 3.161653 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.017310 </data>
                  <data bit_width="8"> 0.071615 </data>
                  <data bit_width="16"> 0.156786 </data>
                  <data bit_width="32"> 0.313790 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 0.115504 </data>
                  <data bit_width="8"> 0.332311 </data>
                  <data bit_width="16"> 1.134840 </data>
                  <data bit_width="32"> 3.705223 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.031763 </data>
                  <data bit_width="8"> 0.108693 </data>
                  <data bit_width="16"> 0.248270 </data>
                  <data bit_width="32"> 0.500347 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="aspect_ratio">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="height">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="width">

              <!-- Dummy yet -->

            </est_index>

          </est_type>

          <est_type name="timing">

            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 7.76 </data>
                  <data bit_width="8"> 24.66 </data>
                  <data bit_width="16"> 81.43 </data>
                  <data bit_width="32"> 292.13 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.018183 </data>
                  <data bit_width="8"> 0.083210 </data>
                  <data bit_width="16"> 0.202057 </data>
                  <data bit_width="32"> 0.412350 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 6.76 </data>
                  <data bit_width="8"> 24.52 </data>
                  <data bit_width="16"> 79.80 </data>
                  <data bit_width="32"> 304.42 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.017310 </data>
                  <data bit_width="8"> 0.071615 </data>
                  <data bit_width="16"> 0.156786 </data>
                  <data bit_width="32"> 0.313790 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 8.87 </data>
                  <data bit_width="8"> 25.95 </data>
                  <data bit_width="16"> 83.97 </data>
                  <data bit_width="32"> 303.15 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.031763 </data>
                  <data bit_width="8"> 0.108693 </data>
                  <data bit_width="16"> 0.248270 </data>
                  <data bit_width="32"> 0.500347 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

            </est_index>

          </est_type>

          <est_type name="power">
            
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 318.4694 </data>
                  <data bit_width="8"> 1293.8 </data>
                  <data bit_width="16"> 3446.1 </data>
                  <data bit_width="32"> 16329.9 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.018183 </data>
                  <data bit_width="8"> 0.083210 </data>
                  <data bit_width="16"> 0.202057 </data>
                  <data bit_width="32"> 0.412350 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 1054.7 </data>
                  <data bit_width="8"> 2200 </data>
                  <data bit_width="16"> 4868.7 </data>
                  <data bit_width="32"> 27294.2 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.017310 </data>
                  <data bit_width="8"> 0.071615 </data>
                  <data bit_width="16"> 0.156786 </data>
                  <data bit_width="32"> 0.313790 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 505.5423 </data>
                  <data bit_width="8"> 1513.9 </data>
                  <data bit_width="16"> 3902.1 </data>
                  <data bit_width="32"> 14306.2 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.031763 </data>
                  <data bit_width="8"> 0.108693 </data>
                  <data bit_width="16"> 0.248270 </data>
                  <data bit_width="32"> 0.500347 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <!-- Dummy yet -->

          </est_type>

          <est_type name="function_power">

            <!-- Dummy yet -->

          </est_type>

        </library>     

      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> rt </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko UEDA ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[ (c)2001,PEAS3-Lite Project ]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> two_complement </value>
        <value> abs </value>
        <value> unsigned </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp div(twoscomp a, towscomp b);
unsigned div(unsigned a, unsigned b);
twoscomp mod(twoscomp a, towscomp b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(twoscomp a, towscomp b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn div(signmagn a, signmagn b);
signmagn mod(signmagn a, signmagn b);
Boolean  flag_div(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned div(unsigned a, unsigned b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC

/** $bit_width-bit $data_type divider */
model ${data_type}_div${bit_width}{
  port{
    in reset, clear, start;
    in a[$w_1:0], b[$w_1:0];
    in mode;
    out q[$w_1:0], r[$w_1:0], flag;
    out fin;
  }
  default_control{
    reset = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in reset;
    }
    protocol{
      [reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", "twoscomp", 1, 1);
    &print_func("unsigned division", "divu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type q = div(a, b);
      $d_type r = mod(a, b);
      Boolean flag = flag_div(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
	print <<FHM_DL_SUB_SIGNED
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_SIGNED
    }
    else{
	print <<FHM_DL_SUB_NOSIGNED
    control{
      out fin;
    }
    protocol{
      [true]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_NOSIGNED
    }
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", 1, 1);
    &print_func("unsigned division", "divu", 1, 0);
    exit (0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", 0);
    exit (0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", 0);
    exit (0);
}
else{
    print "false\n";
    exit (100);
}

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $mode      = $_[2];
    $mode_val  = $_[3];

    {
	print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w_1:0] a;
    bit [$w_1:0] b;
  }

  output{
    bit [$w_1:0] q;
    bit [$w_1:0] r;
    bit        flag;
  }

  control{
FHM_DL_FUNC1
    }
  
    if ($mode == 1){
	print "    in  bit mode;\n";
    }

    print "  }\n\n  protocol{\n";

    if ($mode == 1){
	print <<FHM_DL_FUNC2
    single_cycle_protocol{
      mode = '$mode_val';
    }
FHM_DL_FUNC2
    }

    print <<FHM_DL_FUNC3
  }
}

FHM_DL_FUNC3
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generate port infomation for divider in behavior level
# parameter : instance_name bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$data_type     = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_PORT
clock	in	bit		clock
reset	in	bit		reset
clear	in	bit		ctrl
a	in	bit_vector   $w_1   0	data
b	in	bit_vector   $w_1   0	data
start	in	bit		ctrl
mode	in	bit		mode
q	out	bit_vector   $w_1   0	data
r	out	bit_vector   $w_1   0	data
flag	out	bit		data
fin	out	bit		ctrl
FHM_DL_PORT
}
exit (0);

        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = $bit_width*2-1;
$w3 = $bit_width - 2;
$xs = 'X' x $bit_width;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n--              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

{
print <<FHM_DL_INSTANCE;
-- Module     : $bit_width-bit Divider
-- Feature    : 
-- References :
-- Author     : Designed by T.Morifuji (c) 1996,1999
--              Modified by K.Ueda (c)2002
-- Version    : 2.0  : change functionality
-- VHDL       : 87

-- Functionality : behavioral level
--  port
--   clock    : (ignore)
--   reset    : (ignore)
--   clear    : (ignore)
--   a        : dividend
--   b        : divisor
--   start    : (ignore)
--   mode     : $mode_comment
--   q        : result of a / b
--   r        : reminder of a / b
--   flag     : '1' if b = 0
--   fin      : '1' when operation is over

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_signed.all;

entity $instance_name is
  port (clock  : in  std_logic;
        reset  : in  std_logic;
	clear  : in  std_logic;
        a, b   : in  std_logic_vector($w downto 0);
        start  : in  std_logic;
        mode   : in  std_logic;
        q      : out std_logic_vector($w downto 0);
        r      : out std_logic_vector($w downto 0);
        flag   : out std_logic;
        fin    : out std_logic);
end $instance_name;

architecture behavior of $instance_name is
begin
  process (a, b, mode)
    variable tmp_a, tmp_b : std_logic_vector($w2 downto 0);
    variable tmp_result : std_logic_vector($w downto 0);
FHM_DL_INSTANCE
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    variable sign : boolean;
  begin
    if (mode='1' and ((a($w) xor b($w)) = '1')) then
      sign := true;
    else
      sign := false;
    end if;
    if (mode='1' and a($w)='1') then
      tmp_a($w downto 0) := not a + 1;
    else
      tmp_a($w downto 0) := a;
    end if;
    tmp_a($w2 downto $bit_width) := (others => '0');
    
    if (mode='1' and b($w) = '1') then
      tmp_b($w2 downto $w) := '0' & (not b + 1);
    else
      tmp_b($w2 downto $w) := '0' & b;
    end if;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
  begin
    if (a($w) = '1') then
      tmp_a($w downto 0) := not a + 1;
    else
      tmp_a($w downto 0) := a;
    end if;
    tmp_a($w2 downto $bit_width) := (others => '0');
    if (b($w) = '1') then
      tmp_b($w2 downto $w) := '0' & (not b + 1);
    else
      tmp_b($w2 downto $w) := '0' & b;
    end if;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
  begin
    tmp_a($w downto 0) := a;
    tmp_a($w2 downto $bit_width) := (others => '0');
    tmp_b($w2 downto $w) := '0' & b;
    tmp_b($w3 downto 0) := (others => '0');
FHM_DL_INSTANCE4
}
{
    print <<FHM_DL_INSTANCE5;
    
    for i in $w downto 0 loop
      if ((tmp_a /= 0) and (tmp_a - tmp_b >= 0)) then
        tmp_result(i) := '1';
        tmp_a := tmp_a - tmp_b;
      else
        tmp_result(i) := '0';
      end if;
      tmp_b := '0' & tmp_b($w2 downto 1);
    end loop;  -- i
FHM_DL_INSTANCE5
}
if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE6;

    if (sign) then
      tmp_result := not tmp_result + 1;
      if (a($w) = '1') then
        tmp_a := not tmp_a + 1;
      end if;
    end if;
FHM_DL_INSTANCE6
}
{
	print <<FHM_DL_INSTANCE7;

    if (b = 0) then
      flag <= '1';
      q <= "$xs";
      r <= "$xs";
    else
      flag <= '0';
      -- divided
      q <= tmp_result;
      -- modulo
      r <= tmp_a($w downto 0);
    end if;
    fin <= '1';
  end process;
end behavior;
FHM_DL_INSTANCE7
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# This script generates entity for divider in behavior level
# parameter : bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_ENTITY
entity $instance_name is
  port (clock    : in  std_logic;
	reset    : in  std_logic;
        clear    : in  std_logic;
        a, b     : in  std_logic_vector($w_1 downto 0);
	start    : in  std_logic;
        mode     : in  std_logic;
        q        : out std_logic_vector($w_1 downto 0);
        r        : out std_logic_vector($w_1 downto 0);
        flag     : out std_logic;
        fin      : out std_logic );
end $instance_name;
FHM_DL_ENTITY
}
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for divider in behavior level
# parameter : instance_name priority bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$data_type     = $ARGV[3];

if ($priority eq "area"){
    $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
    $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
    $priority_const = "";
}
elsif ($priority eq "none"){
    $priority_const = "";
}
else{
    print "priority $priority is not supported.\n";
    exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
     
        <library name="OSAKA">

          <est_type name="shape">

            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 0.098831 </data>
                  <data bit_width="8"> 0.264286 </data>
                  <data bit_width="16"> 0.924646 </data>
                  <data bit_width="32"> 3.214213 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.018183 </data>
                  <data bit_width="8"> 0.083210 </data>
                  <data bit_width="16"> 0.202057 </data>
                  <data bit_width="32"> 0.412350 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 0.090421 </data>
                  <data bit_width="8"> 0.236262 </data>
                  <data bit_width="16"> 0.857676 </data>
                  <data bit_width="32"> 3.161653 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.017310 </data>
                  <data bit_width="8"> 0.071615 </data>
                  <data bit_width="16"> 0.156786 </data>
                  <data bit_width="32"> 0.313790 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 0.115504 </data>
                  <data bit_width="8"> 0.332311 </data>
                  <data bit_width="16"> 1.134840 </data>
                  <data bit_width="32"> 3.705223 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.031763 </data>
                  <data bit_width="8"> 0.108693 </data>
                  <data bit_width="16"> 0.248270 </data>
                  <data bit_width="32"> 0.500347 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="aspect_ratio">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="height">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="width">

              <!-- Dummy yet -->

            </est_index>

          </est_type>

          <est_type name="timing">

            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 7.76 </data>
                  <data bit_width="8"> 24.66 </data>
                  <data bit_width="16"> 81.43 </data>
                  <data bit_width="32"> 292.13 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.018183 </data>
                  <data bit_width="8"> 0.083210 </data>
                  <data bit_width="16"> 0.202057 </data>
                  <data bit_width="32"> 0.412350 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 6.76 </data>
                  <data bit_width="8"> 24.52 </data>
                  <data bit_width="16"> 79.80 </data>
                  <data bit_width="32"> 304.42 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.017310 </data>
                  <data bit_width="8"> 0.071615 </data>
                  <data bit_width="16"> 0.156786 </data>
                  <data bit_width="32"> 0.313790 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 8.87 </data>
                  <data bit_width="8"> 25.95 </data>
                  <data bit_width="16"> 83.97 </data>
                  <data bit_width="32"> 303.15 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.031763 </data>
                  <data bit_width="8"> 0.108693 </data>
                  <data bit_width="16"> 0.248270 </data>
                  <data bit_width="32"> 0.500347 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

            </est_index>

          </est_type>

          <est_type name="power">
            
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="abs">
                <max>
                  <data bit_width="4"> 318.4694 </data>
                  <data bit_width="8"> 1293.8 </data>
                  <data bit_width="16"> 3446.1 </data>
                  <data bit_width="32"> 16329.9 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.018183 </data>
                  <data bit_width="8"> 0.083210 </data>
                  <data bit_width="16"> 0.202057 </data>
                  <data bit_width="32"> 0.412350 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="unsigned">
                <max>
                  <data bit_width="4"> 1054.7 </data>
                  <data bit_width="8"> 2200 </data>
                  <data bit_width="16"> 4868.7 </data>
                  <data bit_width="32"> 27294.2 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.017310 </data>
                  <data bit_width="8"> 0.071615 </data>
                  <data bit_width="16"> 0.156786 </data>
                  <data bit_width="32"> 0.313790 </data>
                </min>
                <typ>
                </typ>
              </parameters>

              <parameters name="two_complement">
                <max>
                  <data bit_width="4"> 505.5423 </data>
                  <data bit_width="8"> 1513.9 </data>
                  <data bit_width="16"> 3902.1 </data>
                  <data bit_width="32"> 14306.2 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.031763 </data>
                  <data bit_width="8"> 0.108693 </data>
                  <data bit_width="16"> 0.248270 </data>
                  <data bit_width="32"> 0.500347 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <!-- Dummy yet -->

          </est_type>

          <est_type name="function_power">

            <!-- Dummy yet -->

          </est_type>

        </library>     

      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Kyoko UEDA ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[ (c)2001,PEAS3-Lite Project ]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> seq </value>
        <value> array </value>
      </parameter_value>
      <parameter_value key="adder_algorithm">
        <value> rca </value>
        <value> cla </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> unsigned </value>
        <value> abs </value>
        <value> two_complement </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates function definition for divider in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp div(twoscomp a, towscomp b);
unsigned div(unsigned a, unsigned b);
twoscomp mod(twoscomp a, towscomp b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(twoscomp a, towscomp b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn div(signmagn a, signmagn b);
signmagn mod(signmagn a, signmagn b);
Boolean  flag_div(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned div(unsigned a, unsigned b);
unsigned mod(unsigned a, unsigned b);
Boolean  flag_div(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC
/** $bit_width-bit $data_type $algorithm divider : use $add_algo adder algorithm */
model ${algorithm}_${data_type}_div${bit_width}{
  port{
    clock clock;
    in reset, clear, start;
    in a[$w_1:0], b[$w_1:0];
    in mode;
    out q[$w_1:0], r[$w_1:0], flag;
    out fin;
  }
  default_control{
    reset = 0;
    clear = 0;
    start = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in start, reset, clear;
    }
    protocol{
      [start == 0 && reset == 0 && clear == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1 || clear == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
elsif ("$algorithm" eq "array"){
    $multi = 0;
}

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", "twoscomp", 1, 1);
    &print_func("unsigned division", "divu", "unsigned", 1, 0);
    print <<FHM_DL_TWOCOMP_END
  priority{ reset > ( div | divu ) }
}
FHM_DL_TWOCOMP_END
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", "signmagn", 0);
    print <<FHM_DL_ABS_END
  priority{ reset > diva }
}
FHM_DL_ABS_END
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", "unsigned", 0);
    print <<FHM_DL_UN_END
  priority{ reset > divu }
}
FHM_DL_UN_END
}
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type q = div(a, b);
      $d_type r = mod(a, b);
      Boolean flag = flag_div(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($multi == 1){
	{
	    print <<FHM_DL_SUB_SEQ1
    invariant{
      fin == 0;
    }
    control{
FHM_DL_SUB_SEQ1
        }
	if ($mode == 1){
	    print <<FHM_DL_SUB_SEQ2
      in start, clear, mode;
      out fin;
    }
    protocol{
      repeat [start == 1 && mode = 1 && hold a, b]
	until (fin == 1);

      while [start == 1]{
	fin = 1;
	valid q, r, flag;
      }
    }
  }

FHM_DL_SUB_SEQ2
	}
	else{
	    print <<FHM_DL_SUB_SEQ3
      in start, clear;
      out fin;
    }
    protocol{
      repeat [start == 1 && hold a, b]
	until (fin == 1);

      while [start == 1]{
	fin = 1;
	valid q, r, flag;
      }
    }
  }

FHM_DL_SUB_SEQ3
        }
    }
    else{
        if ($mode == 1){
	    print <<FHM_DL_SUB_AARAY1
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_AARAY1
        }
	else{
	    print <<FHM_DL_SUB_ARRAY2
    control{
      out fin;
    }
    protocol{
      [true]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_ARRAY2
        }
    }
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates AUTOGEN description for divider in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit start;
    in bit reset;
    in bit clear;
  }

  protocol{
    single_cycle_protocol{
      start = '0';
      reset = '0';
      clear = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
elsif ("$algorithm" eq "array"){
    $multi = 0;
}

$w_1 = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    &print_func("signed division", "div", 1, 1);
    &print_func("unsigned division", "divu", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs division", "diva", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned division", "divu", 0);
}
exit (0);

# ---------------------------------

sub print_func{
  $comment   = $_[0];
  $func_name = $_[1];
  $mode      = $_[2];
  $mode_val  = $_[3];

  {
    print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w_1:0] a;
    bit [$w_1:0] b;
  }

  output{
    bit [$w_1:0] q;
    bit [$w_1:0] r;
    bit flag;
  }

  control{
FHM_DL_FUNC1
  }

  if ($mode == 1){
    print "    in  bit mode;\n";
  }

  if ($multi == 1){
  print <<FHM_DL_MULTI1
    in  bit start;
    in  bit clear;
    out bit fin;
FHM_DL_MULTI1
}

{
  print <<FHM_DL_FUNC2
  }

  protocol{
FHM_DL_FUNC2
  }

  if ($multi == 1){
    {
      print <<FHM_DL_MULTI2
    multi_cycle_protocol{
      start_signal  start = '1';
      fin_signal    fin   = '1';
      cancel_signal clear = '1';
FHM_DL_MULTI2
    }
    if ($mode == 1){
      print "\n";
    }
  }
  else{
      if ($mode == 1){
	  print "    single_cycle_protocol{\n";
      }
  }

  if ($mode == 1){
      print "      mode = '$mode_val';\n";
  }

  if ($mode == 1 || $multi == 1){
      print "    }\n";
  }

  print <<FHM_DL_FUNC4
  }
}

FHM_DL_FUNC4
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generate port infomation for divider in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width     = $ARGV[0];
$algorithm     = $ARGV[1];
$add_algo      = $ARGV[2];
$data_type     = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
{
print <<FHM_DL_PORT
clock	in	bit		clock
reset	in	bit		reset
clear	in	bit		ctrl
a	in	bit_vector   $w_1   0	data
b	in	bit_vector   $w_1   0	data
start	in	bit		ctrl
mode	in	bit		mode
q	out	bit_vector   $w_1   0	data
r	out	bit_vector   $w_1   0	data
flag	out	bit		data
fin	out	bit		ctrl
FHM_DL_PORT
}
exit (0);

        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for dvider in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;
$w_2 = $bit_width - 2;

$zeros = 0 x $bit_width;
$zeros_1 = 0 x $w_1;

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

# adder generation

$instance_name_add = $instance_name."_add$bit_width";

if ("$add_algo" eq "rca"){
    {
	print <<FHM_DL_RCA
-- Module     : 1-bit full adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : carry of a + b + c

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name_add}_fa is
    port (a:    in  std_logic;
          b:    in  std_logic;
          cin:  in  std_logic;
          s:    out std_logic;
          cout: out std_logic );
end ${instance_name_add}_fa;

architecture synthesis of ${instance_name_add}_fa is
begin

   s <= (not a and b and not cin) or
	(a and not b and not cin) or
        (not a and not b and cin) or 
	(a and b and cin);

   cout <= (a and b and not cin) or 
           (not a and b and cin) or 
           (a and not b and cin) or 
           (a and b and cin);

end synthesis;

--%%

-- Module     : $bit_width-bit ripple carry adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$bit_width-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add is
    port (a, b   : in  std_logic_vector($w_1 downto 0);
          cin    : in  std_logic;
          result : out std_logic_vector($w_1 downto 0);
          cout   : out std_logic);
end $instance_name_add;

architecture synthesis of $instance_name_add is

   component ${instance_name_add}_fa
      port (a:    in  std_logic;
            b:    in  std_logic;
            cin:  in  std_logic;
            s:    out std_logic;
            cout: out std_logic);
   end component;

   signal  ctmp :  std_logic_vector($bit_width downto 0);

begin

   ctmp(0) <= cin;

   full_adder: for i in $w_1 downto 0 generate
   fan: ${instance_name_add}_fa 
      port map (a    => a(i),
                b    => b(i),
                cin  => ctmp(i),
                s    => result(i),
                cout => ctmp(i+1));
   end generate full_adder;

   cout <= ctmp($bit_width);

end synthesis;

FHM_DL_RCA
    }
}
elsif ("$add_algo" eq "cla"){
    $rem64   = $bit_width % 64;
    $count64 = ($bit_width - $rem64) / 64;
    $rem16   = $rem64 % 16;
    $count16 = ($rem64 - $rem16) / 16;
    $count1  = $rem16 % 4;
    $count4  = ($rem16 - $count1) / 4;

    $req64 = $count64;
    $req16 = $req64 + $count16;
    $req4  = $req16 + $count4;

    if ($req4 != 0){
	print <<FHM_DL_CLA4
-- Module     : Basic 4bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^4-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name_add}_cla4 is
  port (a, b       : in  std_logic_vector(3 downto 0);
        cin        : in  std_logic;
        result     : out std_logic_vector(3 downto 0);
        pout, gout : out std_logic);
end ${instance_name_add}_cla4;

architecture synthesis of ${instance_name_add}_cla4 is

  signal p, g  : std_logic_vector(3 downto 0);
  signal carry : std_logic_vector(2 downto 0);

begin  --  synthesis

  --  make carry generate
  g(0) <= a(0) and b(0);
  g(1) <= a(1) and b(1);
  g(2) <= a(2) and b(2);
  g(3) <= a(3) and b(3);

  --  make carry propagate
  p(0) <= a(0) xor b(0);
  p(1) <= a(1) xor b(1);
  p(2) <= a(2) xor b(2);
  p(3) <= a(3) xor b(3);
  
  --   make internal carry and external carry
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout  <= p(3) and p(2) and p(1) and p(0);
  gout  <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
            or (p(3) and p(2) and p(1) and g(0));

  --  make sum.
  result(0) <= p(0) xor cin;
  result(1) <= p(1) xor carry(0);
  result(2) <= p(2) xor carry(1);
  result(3) <= p(3) xor carry(2);

end synthesis;

--%%

FHM_DL_CLA4
    }
    if ($req16 != 0){
	print <<FHM_DL_CLA16
-- Module     : Basic 16bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^16-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name_add}_cla16 is
  port (a, b       : in std_logic_vector(15 downto 0);
        cin        : in std_logic;
        result     : out std_logic_vector(15 downto 0);
        pout, gout : out std_logic);
end ${instance_name_add}_cla16;

architecture synthesis of ${instance_name_add}_cla16 is

  component ${instance_name_add}_cla4
    port (a, b       : in  std_logic_vector(3 downto 0);
          cin        : in  std_logic;
          result     : out std_logic_vector(3 downto 0);
          pout, gout : out std_logic);
  end component;

  signal p, g  : std_logic_vector(3 downto 0);
  signal carry : std_logic_vector(2 downto 0);

begin  --  synthesis

  -- make internal carry and carry propagate/generate
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout <= p(3) and p(2) and p(1) and p(0);
  gout <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
          or (p(3) and p(2) and p(1) and g(0));
  
  -- work adder
  u0 : ${instance_name_add}_cla4
    port map (
      a      => a(3 downto 0),
      b      => b(3 downto 0),
      cin    => cin,
      result => result(3 downto 0),
      pout   => p(0),
      gout   => g(0));
  
  u1 : ${instance_name_add}_cla4
    port map (
      a      => a(7 downto 4),
      b      => b(7 downto 4),
      cin    => carry(0),
      result => result(7 downto 4),
      pout   => p(1),
      gout   => g(1));

  u2 : ${instance_name_add}_cla4
    port map (
      a      => a(11 downto 8),
      b      => b(11 downto 8),
      cin    => carry(1),
      result => result(11 downto 8),
      pout   => p(2),
      gout   => g(2));

  u3 : ${instance_name_add}_cla4
    port map (
      a      => a(15 downto 12),
      b      => b(15 downto 12),
      cin    => carry(2),
      result => result(15 downto 12),
      pout   => p(3),
      gout   => g(3));

end synthesis;

--%%

FHM_DL_CLA16
    }
    if ($req64 != 0){
	print <<FHM_DL_CLA64
-- Module     : Basic 64bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^64-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name_add}_cla64 is
  port (a, b       : in std_logic_vector(63 downto 0);
        cin        : in std_logic;
        result     : out std_logic_vector(63 downto 0);
        pout, gout : out std_logic);
end ${instance_name_add}_cla64;

architecture synthesis of ${instance_name_add}_cla64 is

  component ${instance_name_add}_cla16
    port (a, b       : in std_logic_vector(15 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(15 downto 0);
          pout, gout : out std_logic);
  end component;

  signal        p, g             : std_logic_vector(3 downto 0);
  signal        carry            : std_logic_vector(2 downto 0);

begin  --  synthesis 

  -- make internal carry and carry propagate/generate
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout <= p(3) and p(2) and p(1) and p(0);
  gout <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
          or (p(3) and p(2) and p(1) and g(0));
  
  -- work adder
  u0 : ${instance_name_add}_cla16
    port map (
      a      => a(15 downto 0),
      b      => b(15 downto 0),
      cin    => cin,
      result => result(15 downto 0),
      pout   => p(0),
      gout   => g(0));

  u1 : ${instance_name_add}_cla16
    port map (
      a      => a(31 downto 16),
      b      => b(31 downto 16),
      cin    => carry(0),
      result => result(31 downto 16),
      pout   => p(1),
      gout   => g(1));

  u2 : ${instance_name_add}_cla16
    port map (
      a      => a(47 downto 32),
      b      => b(47 downto 32),
      cin    => carry(1),
      result => result(47 downto 32),
      pout   => p(2),
      gout   => g(2));

  u3 : ${instance_name_add}_cla16
    port map (
      a      => a(63 downto 48),
      b      => b(63 downto 48),
      cin    => carry(2),
      result => result(63 downto 48),
      pout   => p(3),
      gout   => g(3));

end synthesis;

--%%

FHM_DL_CLA64
    }
    {
	print <<FHM_DL_CLA_BEGIN
-- Module     : $bit_width-bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^64-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add is
  port (a, b   : in  std_logic_vector($w_1 downto 0);
        cin    : in  std_logic;
        result : out std_logic_vector($w_1 downto 0);
        cout   : out std_logic);
end $instance_name_add;

architecture synthesis of $instance_name_add is

FHM_DL_CLA_BEGIN
    }
    if ($req64 != 0){
	print <<FHM_DL_CLA_COMP64
  component ${instance_name_add}_cla64
    port (a, b       : in std_logic_vector(63 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(63 downto 0);
          pout, gout : out std_logic);
  end component;
FHM_DL_CLA_COMP64
    }
    if ($req16 != 0){
	print <<FHM_DL_CLA_COMP16
  component ${instance_name_add}_cla16
    port (a, b       : in std_logic_vector(15 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(15 downto 0);
          pout, gout : out std_logic);
  end component;
FHM_DL_CLA_COMP16
    }
    if ($req4 != 0){
	print <<FHM_DL_CLA_COMP4
  component ${instance_name_add}_cla4
    port (a, b       : in std_logic_vector(3 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(3 downto 0);
          pout, gout : out std_logic);
  end component;
FHM_DL_CLA_COMP4
    }
    if ($req4 >= 1){
	$tmp = $req4 - 1;
	print "  signal p, g      : std_logic_vector($tmp downto 0);\n";
	print "  signal carry     : std_logic_vector($tmp downto 0);\n";
    }
    if ($count1 != 0){
	$tmp = $count1 - 1;
	print "  signal gres,pres : std_logic_vector($tmp downto 0);\n";
    }
    if ($count1 > 1){
	$tmp = $count1 - 2;
	print "  signal carry_res : std_logic_vector($tmp downto 0);\n\n";
    }
    print "begin\n";
    for ($carry=0; $carry<$req4; $carry++){
	print "  carry($carry) <= g($carry) or\n";
	$tmp = $carry;

	for ($g=$carry; $g>=0; $g--){
	    print "              (";

	    for ($p=$carry; $p>=$tmp; $p--){
		print "p($p) and ";
	    }
	    $tmp--;

	    if ($g == 0){
		print "cin);\n";
	    }
	    else{
		print "g($p)) or\n";
	    }
	}
    }

    print "\n";

    $bit_tmp = 0;
    $p = 0;
    $g = 0;

    $bit_tmp_63 = $bit_tmp + 63;
    for ($loop=0; $loop<=$count64-1; $loop++){
        print "    port map (\n";
        print "      a      => a($bit_tmp_63 downto $bit_tmp),\n";
        print "      b      => b($bit_tmp_63 downto $bit_tmp),\n";

	if ($bit_tmp == 0){
            print "      cin    => cin,\n";
	}
	else{
	    $tmp = $p - 1;
            print "      cin    => carry($tmp),\n";
	}

        print "      result => result($bit_tmp_63 downto $bit_tmp),\n";
        print "      pout   => p($p),\n";
        print "      gout   => g($g));\n\n";

	$bit_tmp += 64;
	$bit_tmp_63 += 64;
	$p++;
	$g++;
    }

    $bit_tmp_15 = $bit_tmp + 15;
    for ($loop=0; $loop<=$count16-1; $loop++){
	print "  u16_$loop : ${instance_name_add}_cla16\n";
        print "    port map (\n";
        print "      a      => a($bit_tmp_15 downto $bit_tmp),\n";
        print "      b      => b($bit_tmp_15 downto $bit_tmp),\n";

	if ($bit_tmp == 0){
            print "      cin    => cin,\n";
	}
	else{
	    $tmp = $p - 1;
            print "      cin    => carry($tmp),\n";
	}

        print "      result => result($bit_tmp_15 downto $bit_tmp),\n";
        print "      pout   => p($p),\n";
        print "      gout   => g($g));\n\n";

	$bit_tmp += 16;
	$bit_tmp_15 += 16;
	$p++;
	$g++;
    }

    $bit_tmp_3 = $bit_tmp + 3;
    for ($loop=0; $loop<=$count4-1; $loop++){
	print "  u4_$loop : ${instance_name_add}_cla4\n";
        print "    port map (\n";
        print "      a      => a($bit_tmp_3 downto $bit_tmp),\n";
        print "      b      => b($bit_tmp_3 downto $bit_tmp),\n";

	if ($bit_tmp == 0){
            print "      cin    => cin,\n";
	}
	else{
	    $tmp = $p - 1;
            print "      cin    => carry($tmp),\n";
	}

        print "      result => result($bit_tmp_3 downto $bit_tmp),\n";
        print "      pout   => p($p),\n";
        print "      gout   => g($g));\n\n";

	$bit_tmp += 4;
	$bit_tmp_3 += 4;
	$p++;
	$g++;
    }
    for ($loop=0,$tmp=bit_tmp; $loop<=count1-1; $loop++,$tmp++){
	print "  gres($loop) <= a($tmp) and b($tmp);\n";
    }
    for ($loop=0,$tmp=bit_tmp; $loop<=count1-1; $loop++,$tmp++){
	print "  pres($loop) <= a($tmp) xor b($tmp);\n";
    }
    print "\n";
    if (count1 == 0){
	$tmp = $req4 - 1;
	print "  cout <= carry($tmp);\n";
    }

    for ($carry=0; $carry<$count1; $carry++){
	if ($carry == $count1 - 1){
	    print "  cout <= gres($carry) or\n";
	}
	else{
	    print "  carry_res($carry) <= gres($carry) or\n";
	}
	$tmp = $carry;

	for ($g=$carry; $g>=0; $g--){
	    print "              (";
	    
	    for ($p=$carry; $p>=$tmp; $p--){
		print "pres($p) and ";
	    }
	    $tmp--;

	    if ($g == 0){
		if ($req4 == 0){
		    print "cin);\n";
		}
		else{
		    $tmp2 = $req4 - 1;
		    print "carry($tmp2));\n";
		}
	    }
	    else{
		print "gres($p)) or\n";
	    }
	}
    }
    print "\n";
    for ($loop=0,$tmp=$bit_width; $loop<=count1-1; $loop++,$tmp++){
	if ($req4 == 0){
	    if ($loop == 0){
		print "  result($tmp) <= pres($loop) xor cin;\n";
	    }
	    else{
		$tmp2 = $loop - 1;
		print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
	    }            
	}
	else{
	    if ($loop == 0){
		$tmp2 = $req4 - 1;
		print "  result($tmp) <= pres($loop) xor carry($tmp2);\n";
	    }
	    else{
		$tmp2 = $loop - 1;
		print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
	    }
	}
    }
    print "\n";
    print "end synthesis;\n";
}
else{
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

print "\n--%%\n\n";

# unsigned divider generation
if ("$algorithm" eq "seq") {
# sdiv generation

# register generation
# This script generates register instance in synthesis level

    $instance_name = $ARGV[0];
    $bit_width     = $ARGV[1];

    {
	print <<FHM_DL_SEQ_COMPS
-- Module     : $bit_width-bit positive edge trigger register
-- References :
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   clock    : clock
--   reset    : reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg$bit_width is
  port (clock    : in  std_logic;
        reset    : in  std_logic;
        enb      : in  std_logic;
        data_in  : in  std_logic_vector($w_1 downto 0);
        data_out : out std_logic_vector($w_1 downto 0) );
end ${instance_name}_reg$bit_width;

architecture synthesis of ${instance_name}_reg$bit_width is
begin

  process (clock, reset, enb)
  begin
    if (reset = '1') then
      data_out <= "$zeros";
    elsif (clock'event and clock = '1') then
      if (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : 1-bit positive edge trigger register
-- References :
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   clock    : clock
--   reset    : reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg1 is
  port (clock    : in std_logic;
        reset    : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic;
        data_out : out std_logic );
end ${instance_name}_reg1;

architecture synthesis of ${instance_name}_reg1 is
begin

  process (clock, reset, enb)
  begin
    if (reset = '1') then
      data_out <= '0';
    elsif (clock'event and clock = '1') then
      if (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : $bit_width-bit shift register for divider
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997.
--              Modified by K.Ueda (c)2002.
-- Version    : 1.0
--            : 2.0  : change algorithm
-- VHDL       : 87

-- Functionality :
--  port
--   clock  : clock
--   reset  : reset
--   ld     : load datas when '1'
--   mode   : mode of register
--            "00" : no operation (ignore ld)
--            "01" : initialize register
--            "11" : validate ld and shift data
--   ain    : represent quotient
--   pin    : represent reminder
--   cin    : represent 1-bit of reminder
--   aout   : output of ain
--   pout   : output of pin
--   cout   : output of cin

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_lsftreg$bit_width is
  port (clock, reset : in  std_logic;
        ld           : in  std_logic;
        mode         : in  std_logic_vector(1 downto 0);
        ain, pin     : in  std_logic_vector($w_1 downto 0);
        cin          : in  std_logic;
        aout, pout   : out std_logic_vector($w_1 downto 0);
        cout         : out std_logic );
end ${instance_name}_lsftreg$bit_width;

architecture synthesis of ${instance_name}_lsftreg$bit_width is

  component ${instance_name}_reg$bit_width
    port (
      clock    : in  std_logic;
      reset    : in  std_logic;
      enb      : in  std_logic;
      data_in  : in  std_logic_vector($w_1 downto 0);
      data_out : out std_logic_vector($w_1 downto 0));
  end component;

  component ${instance_name}_reg1
    port (
      clock    : in  std_logic;
      reset    : in  std_logic;
      enb      : in  std_logic;
      data_in  : in  std_logic;
      data_out : out std_logic );
  end component;

  signal pin_tmp, pout_tmp : std_logic_vector($w_1 downto 0);
  signal ain_tmp, aout_tmp : std_logic_vector($w_1 downto 0);
  signal cout_in_tmp, cout_tmp : std_logic;
  signal one : std_logic;

begin

  one <= '1';
  
  pout <= pout_tmp;
  aout <= aout_tmp;
  cout <= cout_tmp;

  pin_tmp <= "$zeros_1" & ain($w_1)
               when mode = "01" else
             pin($w_2 downto 0) & aout_tmp($w_1)
               when (mode = "11" and ld = '1') else
             pout_tmp($w_2 downto 0) & aout_tmp($w_1)
               when (mode = "11" and ld = '0') else
             pout_tmp;

  ain_tmp <= ain($w_2 downto 0) & '0'
               when mode = "01" else
             aout_tmp($w_2 downto 0) & cin
               when mode = "11" else
             aout_tmp;

  cout_in_tmp <= '0'
               when mode = "01" else
             pin($w_1)
               when (mode = "11" and ld = '1') else
             pout_tmp($w_1)
               when (mode = "11" and ld = '0') else
             cout_tmp;

  pout_reg : ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      reset    => reset,
      enb      => one,
      data_in  => pin_tmp,
      data_out => pout_tmp);

  aout_reg : ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      reset    => reset,
      enb      => one,
      data_in  => ain_tmp,
      data_out => aout_tmp);

  cout_reg : ${instance_name}_reg1
    port map (
      clock    => clock,
      reset    => reset,
      enb      => one,
      data_in  => cout_in_tmp,
      data_out => cout_tmp);

end synthesis;

--%%

FHM_DL_SEQ_COMPS
    }
    {
	print <<FHM_DL_SDIV_TOP
-- Module     : Basic $bit_width-bit sequential unsigned divider
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997,1999.
--              Modified by K.Ueda (c)2002
-- Version    : 1.1
--              2.0 : change algorithm
-- VHDL       : 87

-- Functionality :
--  port
--   clock  : clock
--   reset  : reset
--   clear  : cancel division
--   a      : dividend
--   b      : divisor
--   start  : '1' then start division
--   q      : result of a / b
--   r      : reminder of a / b
--   flag   : '1' when b = 0
--   fin    : '1' when operation is over

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  
entity ${instance_name}_sdiv$bit_width is
  port (clock : in std_logic;
        reset : in std_logic;
        clear : in std_logic;
        a, b  : in std_logic_vector($w_1 downto 0);
        start : in std_logic;
        q, r  : out std_logic_vector($w_1 downto 0);
        flag  : out std_logic;
        fin   : out std_logic);
end ${instance_name}_sdiv$bit_width;

architecture synthesis of ${instance_name}_sdiv$bit_width is

  component ${instance_name}_lsftreg$bit_width
    port (clock, reset : in  std_logic;
          ld           : in  std_logic;
          mode         : in  std_logic_vector(1 downto 0);
          ain, pin     : in  std_logic_vector($w_1 downto 0);
          cin          : in  std_logic;
          aout, pout   : out std_logic_vector($w_1 downto 0);
          cout         : out std_logic );
  end component;

  component ${instance_name_add}
    port (a, b   : in std_logic_vector($w_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w_1 downto 0);
          cout   : out std_logic );
  end component;

  component ${instance_name}_reg$bit_width
    port (clock    : in std_logic;
          reset    : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic_vector($w_1 downto 0);
          data_out : out std_logic_vector($w_1 downto 0) );
  end component;

FHM_DL_SDIV_TOP
    }

    print "  type state is (st0, ";

    $i = 1;

    while ($i <= $bit_width) {
	print "st$i, ";
	$j = $i % 7;
	if ($j == 0) {
	    print  "\n";
	    print  "                 ";
	}
	$i= $i + 1;
    }

    $i= $bit_width + 1;
    print "st$i, stend);\n";
    {
	print <<FHM_DL_SDIV_CENTER
  --
  -- signals declaration
  --
  signal sft_mode       : std_logic_vector(1 downto 0);
  signal from_latch_out : std_logic_vector($w_1 downto 0);
  signal from_sft_aout  : std_logic_vector($w_1 downto 0);
  signal from_sft_pout  : std_logic_vector($w_1 downto 0);
  signal from_sft_cout  : std_logic;
  signal from_adder     : std_logic_vector($w_1 downto 0);
  signal add_cout       : std_logic;
  signal to_sft_ain     : std_logic_vector($w_1 downto 0);
  signal to_reg_in      : std_logic_vector($w_1 downto 0);
  signal one            : std_logic;
  signal current_state : state;
  signal next_state    : state;

begin  --  synthesis 

  one <= '1';

  q <= from_sft_aout($w_1 downto 0);
  r <= from_sft_cout & from_sft_pout($w_1 downto 1);

  flag <= '1' when b = "$zeros" else
          '0';

  to_reg_in <= not b;
  to_sft_ain <= a;
 
  process (current_state, start, clear)
  begin
    case current_state is
      when st0 =>
        if (start = '1' and clear = '0') then
          next_state <= st1;
        else
          next_state <= st0;
        end if;
        sft_mode <= "00";
        fin        <= '1' and not start;
      when st1 =>
        if (clear = '1') then
          next_state <= st0;
        else
          next_state <= st2;
        end if;
        sft_mode <= "01";
        fin        <= '0';
FHM_DL_SDIV_CENTER
    }
    $i=2;

    while ($i < $bit_width + 1) {
	print  "      when st$i =>\n";
	$i++;
	print <<FHM_DL_STATE
        if (clear = '1') then
          next_state <= st0;
        else
          next_state <= st$i;
        end if;
        sft_mode <= "11";
        fin        <= '0';
FHM_DL_STATE
    }

    print "      when st$i =>\n";
    {
	print <<FHM_DL_SDIV_BOTTOM
        if (clear = '1') then
          next_state <= st0;
        else
          next_state <= stend;
        end if;
        sft_mode <= "11";
        fin        <= '0';
      when stend =>
        next_state <= st0;
        sft_mode <= "00";
        fin        <= '1';
    end case;
  end process;

  process (clock, reset)
  begin
    if (reset = '1') then
      current_state <= st0;
    elsif (clock'event and clock = '1') then
      current_state <= next_state;
    end if;
  end process;  

  lsftreg0 : ${instance_name}_lsftreg$bit_width

  port map (
    clock => clock,
    reset => reset,
    ld    => add_cout,
    mode  => sft_mode,
    ain   => to_sft_ain,
    pin   => from_adder,
    cin   => add_cout,
    aout  => from_sft_aout,
    pout  => from_sft_pout,
    cout  => from_sft_cout);
  
  add0 : ${instance_name}_add$bit_width
    port map (
      a      => from_sft_pout,
      b      => from_latch_out,
      cin    => one,
      result => from_adder,
      cout   => add_cout);

  reg0 : ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      reset    => reset,
      enb      => start,
      data_in  => to_reg_in,
      data_out => from_latch_out);

end synthesis;
FHM_DL_SDIV_BOTTOM
    }
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_ADIV
-- Module     : Basic $bit_width-bit array unsigned divider
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality :
--  port
--   a      : dividend
--   b      : divisor
--   q      : result of a / b
--   r      : reminder of a / b
--   flag   : '1' when b = 0

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  use IEEE.std_logic_arith.all;

entity ${instance_name}_adiv$bit_width is
  port (a, b : in std_logic_vector($w_1 downto 0);
        q, r : out std_logic_vector($w_1 downto 0);
        flag : out std_logic );
end ${instance_name}_adiv$bit_width;

architecture synthesis of ${instance_name}_adiv$bit_width is

  -- component declaration
  -- adder
  component ${instance_name}_add$bit_width
    port (a, b   : in std_logic_vector($w_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w_1 downto 0);
          cout   : out std_logic);
  end component;

  --  type definition
  type vectors is array (Natural range <>) of std_logic_vector($w_1 downto 0);

  --  signal declaration
  signal qout   : std_logic_vector($w_1 downto 0);
  signal conv_b	: std_logic_vector($w_1 downto 0);
  signal add_a	: vectors($w_1 downto 0);
  signal s	: vectors($w_1 downto 0);
  signal c	: std_logic_vector($w_1 downto 0);
  signal subr	: vectors(0 to $w_2);

  signal one	: std_logic;

begin  -- synthesis

  one <= '1';

  -- zero flag
  flag <= '1' when b = "$zeros" else
          '0';

  conv_b <= not b;
 
  a_connect : for i in 0 to $w_1 generate
    add_a0 : if (i = 0) generate
      input_0 : for j in $w_1 downto 1 generate
        add_a(i)(j) <= '0';
      end generate input_0;
        add_a(i)(0) <= a($w_1);

    end generate add_a0;
    
    add_as : if (0 < i and i < $w_1) generate
      input_0 : for j in $w_1 downto i+1 generate
        add_a(i)(j) <= '0';
      end generate input_0;
        add_a(i)(i downto 0) <= subr(i-1)(i-1 downto 0) & a($w_1-i);
    end generate add_as;

    add_aend : if (i = $w_1) generate
      add_a(i) <= subr($w_2)($w_2 downto 0) & a(0);
    end generate add_aend;
  end generate a_connect;

  sub_r : for i in 0 to $w_2 generate
    subs : for j in i downto 0 generate
      front : if (j /= 0) generate
	subr(i)(j) <=    (s(i)(j) and c(i))
                      or ((not c(i)) and subr(i-1)(j-1));
	
      end generate front;

      last : if (j = 0) generate
	subr(i)(j) <=    (s(i)(j) and c(i))
                     or ((not c(i)) and a($w_1-i));
      end generate last;
    end generate subs;
  end generate sub_r;

  rems : for j in $w_1 downto 0 generate
    rfront : if (j /= 0) generate
      r(j) <=    (s($w_1)(j) and c($w_1)) 
              or ((not c($w_1)) and subr($w_2)(j-1));
    end generate rfront;

    rlast : if (j = 0) generate
      r(j) <=    (s($w_1)(j) and c($w_1))
              or ((not c($w_1)) and a(0));
    end generate rlast;
  end generate rems;

  qui : for i in $w_1 downto 0 generate
    q(i) <= c($w_1-i);
  end generate qui;

  -- port mapping: adder
  add_connect : for i in 0 to $w_1 generate
   adds : ${instance_name}_add$bit_width
      port map (
        a      => add_a(i),
        b      => conv_b,
        cin    => one,
        result => s(i),
        cout   => c(i));
  end generate add_connect;

end synthesis;

FHM_DL_ADIV
}
print "\n--%%\n\n";

if ("$data_type" eq "two_complement" || "$data_type" eq "abs") {
    print <<FHM_DL_TCONV
-- Module     : $bit_width-bit 2's complement converter
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_tconv$bit_width is
  port (data_in  : in  std_logic_vector($w_1 downto 0);
        conv     : in std_logic;
        data_out : out std_logic_vector($w_1 downto 0));
end ${instance_name}_tconv$bit_width;

architecture synthesis of ${instance_name}_tconv$bit_width is

  -- adder
  component ${instance_name}_add$bit_width
    port (a, b   : in std_logic_vector($w_1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w_1 downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector($w_1 downto 0);
  signal zero         : std_logic_vector($w_1 downto 0);
  signal tmp_data_out : std_logic_vector($w_1 downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= (others => '0');

  two_conv : ${instance_name}_add$bit_width
    port map (
      a      => not_data_in,
      b      => zero,
      cin    => conv,
      result => tmp_data_out,
      cout   => tmp_cout);
  
  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

FHM_DL_TCONV
}
if ("$algorithm" eq "seq"){
    $clock = "clock";
    $reset = "reset";
    $clear = "cancel division";
    $start = "\'1\' then start division";
    $fin   = "\'1\' when operation is over";
}
elsif ("$algorithm" eq "array"){
    $clock = "(ignore)";
    $reset = "(ignore)";
    $clear = "(ignore)";
    $start = "(ignore)";
    $fin   = "(ignore)";
}
if ("$data_type" eq "two_complment"){
    $mode = "\'1\' for signed division\n--              '0' for unsigned division";
}
elsif ("$data_type" eq "abs" || "$data_type" eq "unsigned"){
    $mode = "(ignore)";
}
{    
    print <<FHM_DL_DIV_TOP
-- Module     : $bit_width-bit $algorithm $data_type divider
--              using $add_algo for adder algorithm
-- References :
-- Author     : Designed by T.Morifuji (c)1996,1997,1999
-- Version    : 1.1  :
-- VHDL       : 87

-- Functionality :
--  port
--   clock : $clock
--   reset : $reset
--   clear : $clear
--   a     : dividend
--   b     : divisor
--   start : $start
--   mode  : $mode
--   q     : result of a / b
--   r     : reminder of a / b
--   flag  : '1' if b = 0
--   fin   : $fin

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (clock    : in std_logic;
	reset    : in std_logic;
        clear    : in std_logic;
        a, b     : in std_logic_vector($w_1 downto 0);
        start    : in std_logic;
        mode     : in std_logic;
        q        : out std_logic_vector($w_1 downto 0);
        r        : out std_logic_vector($w_1 downto 0);
        flag     : out std_logic;
        fin      : out std_logic );
end $instance_name;

architecture synthesis of $instance_name is
FHM_DL_DIV_TOP
}
if ("$algorithm" eq "seq") {
    print <<FHM_DL_COMP_SDIV
  component ${instance_name}_sdiv$bit_width
    port (clock : in std_logic;
	  reset : in std_logic;
          clear : in std_logic;
          a, b  : in std_logic_vector($w_1 downto 0);
          start : in std_logic;
          q, r  : out std_logic_vector($w_1 downto 0);
          flag  : out std_logic;
          fin   : out std_logic);
  end component;

FHM_DL_COMP_SDIV
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_COMP_ADIV
  component ${instance_name}_adiv$bit_width
    port (a, b : in std_logic_vector($w_1 downto 0);
          q, r : out std_logic_vector($w_1 downto 0);
          flag : out std_logic);
  end component;

FHM_DL_COMP_ADIV
}

if ("$data_type" eq "unsigned") {
    print "begin\n";
    print "\n";

    if ("$algorithm" eq "seq") {
        print <<FHM_DL_UN_SEQ_COMP
  sdiv0 : ${instance_name}_sdiv$bit_width
    port map (
      clock => clock,
      reset => reset,
      clear => clear,
      a     => a,
      b     => b,
      start => start,
      q     => q,
      r     => r,
      flag  => flag,
      fin   => fin);
        
FHM_DL_UN_SEQ_COMP
    }
    elsif ("$algorithm" eq "array") {
        print <<FHM_DL_UN_ARRAY_COMP
  fin <= '1';

  adiv0 : ${instance_name}_adiv$bit_width
    port map (
      a    => a,
      b    => b,
      q    => q,
      r    => r,
      flag => flag);
  
FHM_DL_UN_ARRAY_COMP
    }
    print "end synthesis;\n";
}
elsif ("$data_type" eq "two_complement") {
    $mode = "mode";
    {
	print <<FHM_DL_TWOCOMP_TOP1
  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w_1 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w_1 downto 0));
  end component;

FHM_DL_TWOCOMP_TOP1
    }
    if ("$algorithm" eq "seq"){
	$mode = "tmp_mode";
	print <<FHM_DL_SEQ_REG
  component ${instance_name}_reg1
    port (
      clock    : in  std_logic;
      reset    : in  std_logic;
      enb      : in  std_logic;
      data_in  : in  std_logic;
      data_out : out std_logic);
  end component;

  signal tmp_mode : std_logic;

FHM_DL_SEQ_REG
    }
    {
	print <<FHM_DL_TWOCOMP_TOP2
  signal conved_a : std_logic_vector($w_1 downto 0);
  signal conved_b : std_logic_vector($w_1 downto 0);
  signal conved_q : std_logic_vector($w_1 downto 0);
  signal conved_r : std_logic_vector($w_1 downto 0);

  signal tmp_a    : std_logic_vector($w_1 downto 0);
  signal tmp_b    : std_logic_vector($w_1 downto 0);
  signal tmp_q    : std_logic_vector($w_1 downto 0);
  signal tmp_r    : std_logic_vector($w_1 downto 0);
  signal q_tconv_conv, r_tconv_conv : std_logic;

begin

  q_tconv_conv <= a($w_1) xor b($w_1);
  r_tconv_conv <= a($w_1);

  conv_a : ${instance_name}_tconv$bit_width
    port map (
      data_in  => a,
      conv     => a($w_1),
      data_out => conved_a);

  conv_b : ${instance_name}_tconv$bit_width
    port map (
      data_in  => b,
      conv     => b($w_1),
      data_out => conved_b);

  tmp_a <= a when $mode = '0' else
           conved_a;

  tmp_b <= b when $mode = '0' else
           conved_b;
FHM_DL_TWOCOMP_TOP2
    }
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_TWOCOMP_SEQ
  divu : ${instance_name}_sdiv$bit_width
    port map (
      clock => clock,
      reset => reset,
      clear => clear,
      a     => tmp_a,
      b     => tmp_b,
      start => start,
      q     => tmp_q,
      r     => tmp_r,
      flag  => flag,
      fin   => fin);

  reg_mode : ${instance_name}_reg1
    port map (
      clock    => clock,
      reset    => reset,
      enb      => start,
      data_in  => mode,
      data_out => tmp_mode);

FHM_DL_TWOCOMP_SEQ
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_TWOCOMP_ARRAY
  fin <= '1';

  divu : ${instance_name}_adiv$bit_width
    port map (
      a    => tmp_a,
      b    => tmp_b,
      q    => tmp_q,
      r    => tmp_r,
      flag => flag);

FHM_DL_TWOCOMP_ARRAY
    }
    print <<FHM_DL_TWOCOMP_BOTTOM
  conv_q : ${instance_name}_tconv$bit_width
    port map (
      data_in  => tmp_q,
      conv     => q_tconv_conv,
      data_out => conved_q);

  conv_r : ${instance_name}_tconv$bit_width
    port map (
      data_in  => tmp_r,
      conv     => r_tconv_conv,
      data_out => conved_r);

  q <= tmp_q when $mode = '0' else
             conved_q;
  r <= tmp_r when $mode = '0' else
             conved_r;

end synthesis;
FHM_DL_TWOCOMP_BOTTOM
}
elsif ("$data_type" eq "abs") {
    {
	print <<FHM_DL_ABS_TOP
  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w_1 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w_1 downto 0));
  end component;

  signal conved_a      : std_logic_vector($w_1 downto 0);
  signal conved_b      : std_logic_vector($w_1 downto 0);

begin

  conv_a : ${instance_name}_tconv$bit_width
    port map (
      data_in  => a,
      conv     => a($w_1),
      data_out => conved_a);

  conv_b : ${instance_name}_tconv$bit_width
    port map (
      data_in  => b,
      conv     => b($w_1),
      data_out => conved_b);

FHM_DL_ABS_TOP
    }
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_ABS_SEQ
  divu : ${instance_name}_sdiv$bit_width
    port map (
      clock => clock,
      reset => reset,
      clear => clear,
      a     => conved_a,
      b     => conved_b,
      start => start,
      q     => q,
      r     => r,
      flag  => flag,
      fin   => fin);

FHM_DL_ABS_SEQ
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ABS_ARRAY
  fin <= '1';

  divu : ${instance_name}_adiv$bit_width
    port map (
      a    => conved_a,
      b    => conved_b,
      q    => q,
      r    => r,
      flag => flag);

FHM_DL_ABS_ARRAY
    }
    print "end synthesis;\n";
    exit (0);
}
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates entity for dvider in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w_1 = $bit_width - 1;

{
print <<FHM_DL_ENTITY
entity $instance_name is
  port (clock    : in std_logic;
	reset    : in std_logic;
        clear    : in std_logic;
        a, b     : in std_logic_vector($w_1 downto 0);
        start    : in std_logic;
        mode     : in std_logic;
        q        : out std_logic_vector($w_1 downto 0);
        r        : out std_logic_vector($w_1 downto 0);
        flag     : out std_logic;
        fin      : out std_logic );
end $instance_name;
FHM_DL_ENTITY
}
exit (0);

          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for divider in synthesis level
# parameter : instance_name priority bit_width algorithm adder_algorithm data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "priority $priority is not supported.\n";
  exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" eq "seq"){
    $create_clock = "create_clock -period 10 -waveform{0 5} clock";
}
elsif ("$algorithm" eq "array"){
    $create_clock = "";
}
else{
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

$create_clock

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);

            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
     
        <library name="OSAKA">
    
          <est_type name="shape">

            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4"> 0.098831 </data>
                  <data bit_width="8"> 0.197583 </data>
                  <data bit_width="16"> 0.420493 </data>
                  <data bit_width="32"> 0.843467 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.049695 </data>
                  <data bit_width="8"> 0.100579 </data>
                  <data bit_width="16"> 0.202057 </data>
                  <data bit_width="32"> 0.412350 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.049695 </data>
                    <data bit_width="8"> 0.100579 </data>
                    <data bit_width="16"> 0.202057 </data>
                    <data bit_width="32"> 0.412350 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.098831 </data>
                    <data bit_width="8"> 0.197583 </data>
                    <data bit_width="16"> 0.420493 </data>
                    <data bit_width="32"> 0.843467 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.062002 </data>
                    <data bit_width="8"> 0.122731 </data>
                    <data bit_width="16"> 0.250547 </data>
                    <data bit_width="32"> 0.466229 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4"> 0.095102 </data>
                  <data bit_width="8"> 0.182973 </data>
                  <data bit_width="16"> 0.385646 </data>
                  <data bit_width="32"> 0.779872 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.052634 </data>
                  <data bit_width="8"> 0.101929 </data>
                  <data bit_width="16"> 0.208490 </data>
                  <data bit_width="32"> 0.422750 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.052634 </data>
                    <data bit_width="8"> 0.101929 </data>
                    <data bit_width="16"> 0.208490 </data>
                    <data bit_width="32"> 0.422750 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.095102 </data>
                    <data bit_width="8"> 0.182973 </data>
                    <data bit_width="16"> 0.385646 </data>
                    <data bit_width="32"> 0.779872 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.062080 </data>
                    <data bit_width="8"> 0.120040 </data>
                    <data bit_width="16"> 0.255716 </data>
                    <data bit_width="32"> 0.476987 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4"> 0.055892 </data>
                  <data bit_width="8"> 0.264286 </data>
                  <data bit_width="16"> 0.900410 </data>
                  <data bit_width="32"> 2.835551 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.018183 </data>
                  <data bit_width="8"> 0.083210 </data>
                  <data bit_width="16"> 0.338120 </data>
                  <data bit_width="32"> 1.327280 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.018183 </data>
                    <data bit_width="8"> 0.083210 </data>
                    <data bit_width="16"> 0.338120 </data>
                    <data bit_width="32"> 1.327280 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.055892 </data>
                    <data bit_width="8"> 0.264286 </data>
                    <data bit_width="16"> 0.900410 </data>
                    <data bit_width="32"> 2.835551 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.024374 </data>
                    <data bit_width="8"> 0.106855 </data>
                    <data bit_width="16"> 0.431864 </data>
                    <data bit_width="32"> 1.610602 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4"> 0.049862 </data>
                  <data bit_width="8"> 0.255562 </data>
                  <data bit_width="16"> 0.924646 </data>
                  <data bit_width="32"> 3.214213 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.023347 </data>
                  <data bit_width="8"> 0.096242 </data>
                  <data bit_width="16"> 0.412663 </data>
                  <data bit_width="32"> 1.715828 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.023347 </data>
                    <data bit_width="8"> 0.096242 </data>
                    <data bit_width="16"> 0.412663 </data>
                    <data bit_width="32"> 1.715828 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.049862 </data>
                    <data bit_width="8"> 0.255562 </data>
                    <data bit_width="16"> 0.924646 </data>
                    <data bit_width="32"> 3.214213 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.032946 </data>
                    <data bit_width="8"> 0.141084 </data>
                    <data bit_width="16"> 0.524151 </data>
                    <data bit_width="32"> 2.183483 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4"> 0.090421 </data>
                  <data bit_width="8"> 0.162097 </data>
                  <data bit_width="16"> 0.311256 </data>
                  <data bit_width="32"> 0.646921 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.044614 </data>
                  <data bit_width="8"> 0.085019 </data>
                  <data bit_width="16"> 0.156786 </data>
                  <data bit_width="32"> 0.313790 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.044614 </data>
                    <data bit_width="8"> 0.085019 </data>
                    <data bit_width="16"> 0.156786 </data>
                    <data bit_width="32"> 0.313790 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.090421 </data>
                    <data bit_width="8"> 0.162097 </data>
                    <data bit_width="16"> 0.311256 </data>
                    <data bit_width="32"> 0.646921 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.058186 </data>
                    <data bit_width="8"> 0.097807 </data>
                    <data bit_width="16"> 0.180420 </data>
                    <data bit_width="32"> 0.335649 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4"> 0.087086 </data>
                  <data bit_width="8"> 0.162324 </data>
                  <data bit_width="16"> 0.364110 </data>
                  <data bit_width="32"> 0.552490 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.047076 </data>
                  <data bit_width="8"> 0.087632 </data>
                  <data bit_width="16"> 0.169552 </data>
                  <data bit_width="32"> 0.338061 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.047076 </data>
                    <data bit_width="8"> 0.087632 </data>
                    <data bit_width="16"> 0.169552 </data>
                    <data bit_width="32"> 0.338061 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.087086 </data>
                    <data bit_width="8"> 0.162324 </data>
                    <data bit_width="16"> 0.364110 </data>
                    <data bit_width="32"> 0.552490 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.059220 </data>
                    <data bit_width="8"> 0.105031 </data>
                    <data bit_width="16"> 0.189088 </data>
                    <data bit_width="32"> 0.365715 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4"> 0.075579 </data>
                  <data bit_width="8"> 0.236262 </data>
                  <data bit_width="16"> 0.857676 </data>
                  <data bit_width="32"> 2.772482 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.017310 </data>
                  <data bit_width="8"> 0.071615 </data>
                  <data bit_width="16"> 0.278442 </data>
                  <data bit_width="32"> 1.160693 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.017310 </data>
                    <data bit_width="8"> 0.071615 </data>
                    <data bit_width="16"> 0.278442 </data>
                    <data bit_width="32"> 1.160693 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.075579 </data>
                    <data bit_width="8"> 0.236262 </data>
                    <data bit_width="16"> 0.857676 </data>
                    <data bit_width="32"> 2.772482 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.024692 </data>
                    <data bit_width="8"> 0.086541 </data>
                    <data bit_width="16"> 0.332997 </data>
                    <data bit_width="32"> 1.491287 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4"> 0.057719 </data>
                  <data bit_width="8"> 0.231812 </data>
                  <data bit_width="16"> 0.836991 </data>
                  <data bit_width="32"> 3.161653 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.019059 </data>
                  <data bit_width="8"> 0.079571 </data>
                  <data bit_width="16"> 0.358354 </data>
                  <data bit_width="32"> 1.502216 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.019059 </data>
                    <data bit_width="8"> 0.079571 </data>
                    <data bit_width="16"> 0.358354 </data>
                    <data bit_width="32"> 1.502216 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.057719 </data>
                    <data bit_width="8"> 0.231812 </data>
                    <data bit_width="16"> 0.836991 </data>
                    <data bit_width="32"> 3.161653 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.024372 </data>
                    <data bit_width="8"> 0.112102 </data>
                    <data bit_width="16"> 0.453419 </data>
                    <data bit_width="32"> 2.119435 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4"> 0.106377 </data>
                  <data bit_width="8"> 0.233789 </data>
                  <data bit_width="16"> 0.473632 </data>
                  <data bit_width="32"> 0.902881 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.061283 </data>
                  <data bit_width="8"> 0.121232 </data>
                  <data bit_width="16"> 0.248270 </data>
                  <data bit_width="32"> 0.500347 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.061283 </data>
                    <data bit_width="8"> 0.121232 </data>
                    <data bit_width="16"> 0.248270 </data>
                    <data bit_width="32"> 0.500347 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.106377 </data>
                    <data bit_width="8"> 0.233789 </data>
                    <data bit_width="16"> 0.473632 </data>
                    <data bit_width="32"> 0.902881 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.070489 </data>
                    <data bit_width="8"> 0.143543 </data>
                    <data bit_width="16"> 0.300904 </data>
                    <data bit_width="32"> 0.565093 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4"> 0.115504 </data>
                  <data bit_width="8"> 0.234732 </data>
                  <data bit_width="16"> 0.440431 </data>
                  <data bit_width="32"> 0.931033 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.064700 </data>
                  <data bit_width="8"> 0.125673 </data>
                  <data bit_width="16"> 0.253113 </data>
                  <data bit_width="32"> 0.504778 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.064700 </data>
                    <data bit_width="8"> 0.125673 </data>
                    <data bit_width="16"> 0.253113 </data>
                    <data bit_width="32"> 0.504778 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.115504 </data>
                    <data bit_width="8"> 0.234732 </data>
                    <data bit_width="16"> 0.440431 </data>
                    <data bit_width="32"> 0.931033 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.075575 </data>
                    <data bit_width="8"> 0.150216 </data>
                    <data bit_width="16"> 0.299245 </data>
                    <data bit_width="32"> 0.599491 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4"> 0.104390 </data>
                  <data bit_width="8"> 0.332311 </data>
                  <data bit_width="16"> 1.134840 </data>
                  <data bit_width="32"> 3.248178 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.031763 </data>
                  <data bit_width="8"> 0.108693 </data>
                  <data bit_width="16"> 0.388263 </data>
                  <data bit_width="32"> 1.429454 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.031763 </data>
                    <data bit_width="8"> 0.108693 </data>
                    <data bit_width="16"> 0.388263 </data>
                    <data bit_width="32"> 1.429454 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.104390 </data>
                    <data bit_width="8"> 0.332311 </data>
                    <data bit_width="16"> 1.134840 </data>
                    <data bit_width="32"> 3.248178 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.038114 </data>
                    <data bit_width="8"> 0.130457 </data>
                    <data bit_width="16"> 0.473605 </data>
                    <data bit_width="32"> 1.730551 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4"> 0.100673 </data>
                  <data bit_width="8"> 0.310577 </data>
                  <data bit_width="16"> 1.032456 </data>
                  <data bit_width="32"> 3.705223 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.035020 </data>
                  <data bit_width="8"> 0.118712 </data>
                  <data bit_width="16"> 0.447927 </data>
                  <data bit_width="32"> 1.792273 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.035020 </data>
                    <data bit_width="8"> 0.118712 </data>
                    <data bit_width="16"> 0.447927 </data>
                    <data bit_width="32"> 1.792273 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.100673 </data>
                    <data bit_width="8"> 0.310577 </data>
                    <data bit_width="16"> 1.032456 </data>
                    <data bit_width="32"> 3.705223 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.043508 </data>
                    <data bit_width="8"> 0.149417 </data>
                    <data bit_width="16"> 0.582002 </data>
                    <data bit_width="32"> 2.252458 </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

            <est_index name="aspect_ratio">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="height">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="width">

              <!-- Dummy yet -->

            </est_index>

          </est_type>


          <est_type name="timing">

            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4"> 2.77 </data>
                  <data bit_width="8"> 2.07 </data>
                  <data bit_width="16"> 3.70 </data>
                  <data bit_width="32"> 6.48 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.38 </data>
                  <data bit_width="8"> 1.71 </data>
                  <data bit_width="16"> 2.18 </data>
                  <data bit_width="32"> 3.23 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.30 </data>
                    <data bit_width="8"> 2.02 </data>
                    <data bit_width="16"> 3.70 </data>
                    <data bit_width="32"> 6.48 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.38 </data>
                    <data bit_width="8"> 1.71 </data>
                    <data bit_width="16"> 2.18 </data>
                    <data bit_width="32"> 3.23 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.77 </data>
                    <data bit_width="8"> 2.07 </data>
                    <data bit_width="16"> 3.48 </data>
                    <data bit_width="32"> 6.43 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4"> 2.31 </data>
                  <data bit_width="8"> 1.69 </data>
                  <data bit_width="16"> 2.31 </data>
                  <data bit_width="32"> 2.47 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.46 </data>
                  <data bit_width="8"> 1.47 </data>
                  <data bit_width="16"> 1.65 </data>
                  <data bit_width="32"> 1.58 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.31 </data>
                    <data bit_width="8"> 1.47 </data>
                    <data bit_width="16"> 1.82 </data>
                    <data bit_width="32"> 1.67 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.46 </data>
                    <data bit_width="8"> 1.69 </data>
                    <data bit_width="16"> 2.31 </data>
                    <data bit_width="32"> 2.47 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.03 </data>
                    <data bit_width="8"> 1.47 </data>
                    <data bit_width="16"> 1.65 </data>
                    <data bit_width="32"> 1.58 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4"> 2.67 </data>
                  <data bit_width="8"> 2.86 </data>
                  <data bit_width="16"> 5.98 </data>
                  <data bit_width="32"> 12.04 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.36 </data>
                  <data bit_width="8"> 1.77 </data>
                  <data bit_width="16"> 2.18 </data>
                  <data bit_width="32"> 3.15 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.30 </data>
                    <data bit_width="8"> 2.76 </data>
                    <data bit_width="16"> 5.83 </data>
                    <data bit_width="32"> 11.94 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.36 </data>
                    <data bit_width="8"> 1.77 </data>
                    <data bit_width="16"> 2.18 </data>
                    <data bit_width="32"> 3.15 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.67 </data>
                    <data bit_width="8"> 2.86 </data>
                    <data bit_width="16"> 5.98 </data>
                    <data bit_width="32"> 12.04 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4"> 2.23 </data>
                  <data bit_width="8"> 2.51 </data>
                  <data bit_width="16"> 3.47 </data>
                  <data bit_width="32"> 5.67 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.39 </data>
                  <data bit_width="8"> 1.74 </data>
                  <data bit_width="16"> 2.07 </data>
                  <data bit_width="32"> 2.28 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.02 </data>
                    <data bit_width="8"> 2.04 </data>
                    <data bit_width="16"> 3.36 </data>
                    <data bit_width="32"> 5.67 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.39 </data>
                    <data bit_width="8"> 1.74 </data>
                    <data bit_width="16"> 2.07 </data>
                    <data bit_width="32"> 2.28 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.23 </data>
                    <data bit_width="8"> 2.51 </data>
                    <data bit_width="16"> 3.47 </data>
                    <data bit_width="32"> 5.58 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4"> 2.52 </data>
                  <data bit_width="8"> 1.65 </data>
                  <data bit_width="16"> 1.97 </data>
                  <data bit_width="32"> 2.31 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.40 </data>
                  <data bit_width="8"> 1.47 </data>
                  <data bit_width="16"> 1.65 </data>
                  <data bit_width="32"> 1.68 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.02 </data>
                    <data bit_width="8"> 1.47 </data>
                    <data bit_width="16"> 1.82 </data>
                    <data bit_width="32"> 1.68 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.40 </data>
                    <data bit_width="8"> 1.65 </data>
                    <data bit_width="16"> 1.97 </data>
                    <data bit_width="32"> 2.31 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.52 </data>
                    <data bit_width="8"> 1.47 </data>
                    <data bit_width="16"> 1.65 </data>
                    <data bit_width="32"> 1.92 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4"> 2.31 </data>
                  <data bit_width="8"> 2.86 </data>
                  <data bit_width="16"> 5.91 </data>
                  <data bit_width="32"> 10.01 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.39 </data>
                  <data bit_width="8"> 1.64 </data>
                  <data bit_width="16"> 1.93 </data>
                  <data bit_width="32"> 2.27 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.31 </data>
                    <data bit_width="8"> 2.76 </data>
                    <data bit_width="16"> 5.82 </data>
                    <data bit_width="32"> 10.01 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.39 </data>
                    <data bit_width="8"> 1.64 </data>
                    <data bit_width="16"> 1.93 </data>
                    <data bit_width="32"> 2.27 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.90 </data>
                    <data bit_width="8"> 2.86 </data>
                    <data bit_width="16"> 5.91 </data>
                    <data bit_width="32"> 9.93 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4"> 5.70 </data>
                  <data bit_width="8"> 23.45 </data>
                  <data bit_width="16"> 81.43 </data>
                  <data bit_width="32"> 292.13 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.51 </data>
                  <data bit_width="8"> 6.63 </data>
                  <data bit_width="16"> 20.78 </data>
                  <data bit_width="32"> 98.65 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 5.70 </data>
                    <data bit_width="8"> 22.79 </data>
                    <data bit_width="16"> 81.43 </data>
                    <data bit_width="32"> 292.13 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.51 </data>
                    <data bit_width="8"> 6.63 </data>
                    <data bit_width="16"> 20.78 </data>
                    <data bit_width="32"> 98.65 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 5.70 </data>
                    <data bit_width="8"> 23.45 </data>
                    <data bit_width="16"> 80.34 </data>
                    <data bit_width="32"> 291.75 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4"> 6.34 </data>
                  <data bit_width="8"> 21.99 </data>
                  <data bit_width="16"> 79.80 </data>
                  <data bit_width="32"> 304.42 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.81 </data>
                  <data bit_width="8"> 7.01 </data>
                  <data bit_width="16"> 23.34 </data>
                  <data bit_width="32"> 108.97 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 5.51 </data>
                    <data bit_width="8"> 21.99 </data>
                    <data bit_width="16"> 79.80 </data>
                    <data bit_width="32"> 304.42 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.81 </data>
                    <data bit_width="8"> 7.01 </data>
                    <data bit_width="16"> 23.34 </data>
                    <data bit_width="32"> 108.97 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 6.34 </data>
                    <data bit_width="8"> 20.26 </data>
                    <data bit_width="16"> 70.86 </data>
                    <data bit_width="32"> 297.88 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4"> 7.57 </data>
                  <data bit_width="8"> 25.00 </data>
                  <data bit_width="16"> 83.97 </data>
                  <data bit_width="32"> 303.15 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.37 </data>
                  <data bit_width="8"> 7.46 </data>
                  <data bit_width="16"> 21.12 </data>
                  <data bit_width="32"> 84.92 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 7.53 </data>
                    <data bit_width="8"> 25.00 </data>
                    <data bit_width="16"> 83.97 </data>
                    <data bit_width="32"> 303.15 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 2.37 </data>
                    <data bit_width="8"> 7.46 </data>
                    <data bit_width="16"> 21.12 </data>
                    <data bit_width="32"> 84.92 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 7.57 </data>
                    <data bit_width="8"> 24.60 </data>
                    <data bit_width="16"> 81.98 </data>
                    <data bit_width="32"> 301.70 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4"> 7.76 </data>
                  <data bit_width="8"> 24.66 </data>
                  <data bit_width="16"> 69.30 </data>
                  <data bit_width="32"> 182.00 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.87 </data>
                  <data bit_width="8"> 6.77 </data>
                  <data bit_width="16"> 19.37 </data>
                  <data bit_width="32"> 51.67 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 6.81 </data>
                    <data bit_width="8"> 24.66 </data>
                    <data bit_width="16"> 68.99 </data>
                    <data bit_width="32"> 182.00 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.87 </data>
                    <data bit_width="8"> 6.77 </data>
                    <data bit_width="16"> 19.37 </data>
                    <data bit_width="32"> 51.67 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 7.76 </data>
                    <data bit_width="8"> 24.52 </data>
                    <data bit_width="16"> 69.30 </data>
                    <data bit_width="32"> 178.67 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4"> 6.76 </data>
                  <data bit_width="8"> 24.52 </data>
                  <data bit_width="16"> 68.07 </data>
                  <data bit_width="32"> 180.92 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.11 </data>
                  <data bit_width="8"> 6.28 </data>
                  <data bit_width="16"> 18.59 </data>
                  <data bit_width="32"> 47.94 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 6.76 </data>
                    <data bit_width="8"> 23.75 </data>
                    <data bit_width="16"> 65.64 </data>
                    <data bit_width="32"> 173.73 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 2.11 </data>
                    <data bit_width="8"> 6.28 </data>
                    <data bit_width="16"> 18.59 </data>
                    <data bit_width="32"> 47.94 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 6.31 </data>
                    <data bit_width="8"> 24.52 </data>
                    <data bit_width="16"> 68.07 </data>
                    <data bit_width="32"> 180.92 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4"> 8.87 </data>
                  <data bit_width="8"> 25.95 </data>
                  <data bit_width="16"> 74.94 </data>
                  <data bit_width="32"> 196.08 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.42 </data>
                  <data bit_width="8"> 7.82 </data>
                  <data bit_width="16"> 19.72 </data>
                  <data bit_width="32"> 49.69 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 8.87 </data>
                    <data bit_width="8"> 25.71 </data>
                    <data bit_width="16"> 71.81 </data>
                    <data bit_width="32"> 196.08 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 2.42 </data>
                    <data bit_width="8"> 7.82 </data>
                    <data bit_width="16"> 19.72 </data>
                    <data bit_width="32"> 49.69 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 8.13 </data>
                    <data bit_width="8"> 25.95 </data>
                    <data bit_width="16"> 74.94 </data>
                    <data bit_width="32"> 196.00 </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4">
                    inport	 a	 1.08
                    inport	 b	 1.11
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 4.15
                  </data>
                  <data bit_width="8">
                    inport	 a	 1.79
                    inport	 b	 1.89
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 4.61
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.76
                    inport	 b	 3.37
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 6.72
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.54
                    inport	 b	 6.14
                    outport	 divu	 0.47
                    outport	 divu	 0.87
                    internal	 11.62
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 1.08
                    inport	 b	 1.11
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 4.15
                  </data>
                  <data bit_width="8">
                    inport	 a	 1.79
                    inport	 b	 1.89
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 4.61
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.76
                    inport	 b	 3.37
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 6.72
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.54
                    inport	 b	 6.14
                    outport	 divu	 0.47
                    outport	 divu	 0.87
                    internal	 11.62
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.94
                      inport	 b	 1.08
                      outport	 divu	 0.52
                      outport	 divu	 0.85
                      internal	 3.91
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.64
                      inport	 b	 1.96
                      outport	 divu	 0.52
                      outport	 divu	 0.89
                      internal	 4.56
                    </data>
                    <data bit_width="16">
                      inport	 a	 5.29
                      inport	 b	 3.52
                      outport	 divu	 0.52
                      outport	 divu	 0.89
                      internal	 7.45
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.61
                      inport	 b	 6.18
                      outport	 divu	 0.52
                      outport	 divu	 0.85
                      internal	 13.22
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.76
                      inport	 b	 0.87
                      outport	 divu	 0.48
                      outport	 divu	 0.66
                      internal	 1.38
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.15
                      inport	 b	 1.57
                      outport	 divu	 0.48
                      outport	 divu	 0.79
                      internal	 1.71
                    </data>
                    <data bit_width="16">
                      inport	 a	 1.97
                      inport	 b	 2.15
                      outport	 divu	 0.47
                      outport	 divu	 1.01
                      internal	 2.18
                    </data>
                    <data bit_width="32">
                      inport	 a	 3.20
                      inport	 b	 3.20
                      outport	 divu	 0.47
                      outport	 divu	 0.85
                      internal	 3.23
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 1.08
                      inport	 b	 1.11
                      outport	 divu	 0.47
                      outport	 divu	 0.85
                      internal	 4.15
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.79
                      inport	 b	 1.89
                      outport	 divu	 0.47
                      outport	 divu	 0.86
                      internal	 4.61
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.76
                      inport	 b	 3.37
                      outport	 divu	 0.47
                      outport	 divu	 0.86
                      internal	 6.72
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.54
                      inport	 b	 6.14
                      outport	 divu	 0.47
                      outport	 divu	 0.87
                      internal	 11.62
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.42
                    inport	 b	 0.35
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 1.10
                    internal	 3.27
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.37
                    inport	 b	 0.37
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.91
                    internal	 4.94
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 0.87
                    internal	 7.86
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.64
                    internal	 13.87
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.42
                    inport	 b	 0.35
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 1.10
                    internal	 3.27
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.37
                    inport	 b	 0.37
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.91
                    internal	 4.94
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 0.87
                    internal	 7.86
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.64
                    internal	 13.87
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.37
                      inport	 b	 0.30
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.84
                      internal	 3.92
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.37
                      inport	 b	 0.37
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.85
                      internal	 4.85
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.87
                      internal	 7.77
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.87
                      internal	 13.62
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.54
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.67
                      internal	 1.46
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.43
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.92
                      internal	 1.69
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.46
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.96
                      internal	 2.31
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.50
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 1.18
                      internal	 2.47
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.42
                      inport	 b	 0.35
                      outport	 sdiv0	 0.51
                      outport	 sdiv0	 1.10
                      internal	 3.27
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.37
                      inport	 b	 0.37
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.91
                      internal	 4.94
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.51
                      outport	 sdiv0	 0.87
                      internal	 7.86
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.64
                      internal	 13.87
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 0.90
                    path	 a	 r	 0.97
                    path	 b	 q	 0.91
                    inport	 a	 1.24
                    inport	 b	 1.09
                    outport	 reg_mode	 1.56
                    outport	 reg_mode	 1.84
                    internal	 3.90
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 1.05
                    path	 a	 r	 1.27
                    path	 b	 q	 1.05
                    inport	 a	 2.41
                    inport	 b	 1.55
                    outport	 divu	 2.85
                    outport	 divu	 2.86
                    internal	 4.71
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 1.49
                    path	 a	 r	 1.23
                    path	 b	 q	 1.48
                    inport	 a	 4.34
                    inport	 b	 2.98
                    outport	 divu	 5.74
                    outport	 divu	 5.98
                    internal	 6.43
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 1.86
                    path	 a	 r	 1.57
                    path	 b	 q	 1.87
                    inport	 a	 8.32
                    inport	 b	 5.07
                    outport	 divu	 12.04
                    outport	 divu	 11.86
                    internal	 12.04
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 0.90
                    path	 a	 r	 0.97
                    path	 b	 q	 0.91
                    inport	 a	 1.24
                    inport	 b	 1.09
                    outport	 reg_mode	 1.56
                    outport	 reg_mode	 1.84
                    internal	 3.90
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 1.05
                    path	 a	 r	 1.27
                    path	 b	 q	 1.05
                    inport	 a	 2.41
                    inport	 b	 1.55
                    outport	 divu	 2.85
                    outport	 divu	 2.86
                    internal	 4.71
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 1.49
                    path	 a	 r	 1.23
                    path	 b	 q	 1.48
                    inport	 a	 4.34
                    inport	 b	 2.98
                    outport	 divu	 5.74
                    outport	 divu	 5.98
                    internal	 6.43
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 1.86
                    path	 a	 r	 1.57
                    path	 b	 q	 1.87
                    inport	 a	 8.32
                    inport	 b	 5.07
                    outport	 divu	 12.04
                    outport	 divu	 11.86
                    internal	 12.04
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 0.84
                      path	 a	 r	 0.97
                      path	 b	 q	 0.85
                      inport	 a	 1.24
                      inport	 b	 1.01
                      outport	 reg_mode	 1.71
                      outport	 reg_mode	 2.09
                      internal	 3.91
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.23
                      path	 a	 r	 1.15
                      path	 b	 q	 1.24
                      inport	 a	 2.41
                      inport	 b	 1.91
                      outport	 divu	 2.76
                      outport	 divu	 2.76
                      internal	 5.41
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.71
                      path	 a	 r	 1.49
                      path	 b	 q	 1.72
                      inport	 a	 5.30
                      inport	 b	 3.14
                      outport	 divu	 5.83
                      outport	 divu	 5.82
                      internal	 10.44
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.44
                      path	 a	 r	 1.30
                      path	 b	 q	 1.47
                      inport	 a	 10.65
                      inport	 b	 5.88
                      outport	 divu	 11.94
                      outport	 divu	 11.94
                      internal	 19.01
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 0.72
                      path	 a	 r	 0.65
                      path	 b	 q	 0.71
                      inport	 a	 0.95
                      inport	 b	 0.83
                      outport	 divu	 1.10
                      outport	 divu	 1.19
                      internal	 1.36
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.00
                      path	 a	 r	 0.83
                      path	 b	 q	 1.00
                      inport	 a	 1.13
                      inport	 b	 1.47
                      outport	 divu	 1.48
                      outport	 divu	 1.63
                      internal	 1.77
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.02
                      path	 a	 r	 1.11
                      path	 b	 q	 1.03
                      inport	 a	 2.10
                      inport	 b	 2.10
                      outport	 divu	 2.03
                      outport	 divu	 2.21
                      internal	 2.18
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.12
                      path	 a	 r	 1.14
                      path	 b	 q	 1.13
                      inport	 a	 3.12
                      inport	 b	 3.09
                      outport	 divu	 3.05
                      outport	 divu	 3.25
                      internal	 3.15
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 0.90
                      path	 a	 r	 0.97
                      path	 b	 q	 0.91
                      inport	 a	 1.24
                      inport	 b	 1.09
                      outport	 reg_mode	 1.56
                      outport	 reg_mode	 1.84
                      internal	 3.90
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.05
                      path	 a	 r	 1.27
                      path	 b	 q	 1.05
                      inport	 a	 2.41
                      inport	 b	 1.55
                      outport	 divu	 2.85
                      outport	 divu	 2.86
                      internal	 4.71
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.49
                      path	 a	 r	 1.23
                      path	 b	 q	 1.48
                      inport	 a	 4.34
                      inport	 b	 2.98
                      outport	 divu	 5.74
                      outport	 divu	 5.98
                      internal	 6.43
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.86
                      path	 a	 r	 1.57
                      path	 b	 q	 1.87
                      inport	 a	 8.32
                      inport	 b	 5.07
                      outport	 divu	 12.04
                      outport	 divu	 11.86
                      internal	 12.04
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4">
                    inport	 a	 1.08
                    inport	 b	 1.17
                    outport	 divu	 0.51
                    outport	 divu	 0.87
                    internal	 4.01
                  </data>
                  <data bit_width="8">
                    inport	 a	 1.84
                    inport	 b	 2.22
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 4.20
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.15
                    inport	 b	 3.12
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 5.13
                  </data>
                  <data bit_width="32">
                    inport	 a	 9.29
                    inport	 b	 5.39
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 6.28
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 1.08
                    inport	 b	 1.17
                    outport	 divu	 0.51
                    outport	 divu	 0.87
                    internal	 4.01
                  </data>
                  <data bit_width="8">
                    inport	 a	 1.84
                    inport	 b	 2.22
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 4.20
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.15
                    inport	 b	 3.12
                    outport	 divu	 0.47
                    outport	 divu	 0.85
                    internal	 5.13
                  </data>
                  <data bit_width="32">
                    inport	 a	 9.29
                    inport	 b	 5.39
                    outport	 divu	 0.47
                    outport	 divu	 0.86
                    internal	 6.28
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.94
                      inport	 b	 0.98
                      outport	 divu	 0.52
                      outport	 divu	 1.12
                      internal	 3.63
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.70
                      inport	 b	 2.01
                      outport	 divu	 0.52
                      outport	 divu	 0.84
                      internal	 4.39
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.79
                      inport	 b	 3.25
                      outport	 divu	 0.52
                      outport	 divu	 0.84
                      internal	 5.05
                    </data>
                    <data bit_width="32">
                      inport	 a	 8.70
                      inport	 b	 5.38
                      outport	 divu	 0.52
                      outport	 divu	 0.84
                      internal	 5.91
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.76
                      inport	 b	 0.91
                      outport	 divu	 0.48
                      outport	 divu	 0.72
                      internal	 1.39
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.12
                      inport	 b	 1.61
                      outport	 divu	 0.48
                      outport	 divu	 0.72
                      internal	 1.74
                    </data>
                    <data bit_width="16">
                      inport	 a	 1.70
                      inport	 b	 1.95
                      outport	 divu	 0.47
                      outport	 divu	 0.73
                      internal	 2.07
                    </data>
                    <data bit_width="32">
                      inport	 a	 1.96
                      inport	 b	 2.02
                      outport	 divu	 0.47
                      outport	 divu	 1.10
                      internal	 2.28
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 1.08
                      inport	 b	 1.17
                      outport	 divu	 0.51
                      outport	 divu	 0.87
                      internal	 4.01
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.84
                      inport	 b	 2.22
                      outport	 divu	 0.47
                      outport	 divu	 0.85
                      internal	 4.20
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.15
                      inport	 b	 3.12
                      outport	 divu	 0.47
                      outport	 divu	 0.85
                      internal	 5.13
                    </data>
                    <data bit_width="32">
                      inport	 a	 9.29
                      inport	 b	 5.39
                      outport	 divu	 0.47
                      outport	 divu	 0.86
                      internal	 6.28
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.42
                    inport	 b	 0.35
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 0.87
                    internal	 3.76
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.37
                    inport	 b	 0.35
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.85
                    internal	 4.65
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 1.11
                    internal	 4.91
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.37
                    inport	 b	 0.30
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.86
                    internal	 6.23
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.42
                    inport	 b	 0.35
                    outport	 sdiv0	 0.51
                    outport	 sdiv0	 0.87
                    internal	 3.76
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.37
                    inport	 b	 0.35
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.85
                    internal	 4.65
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.37
                    inport	 b	 0.29
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 1.11
                    internal	 4.91
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.37
                    inport	 b	 0.30
                    outport	 sdiv0	 0.47
                    outport	 sdiv0	 0.86
                    internal	 6.23
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.37
                      inport	 b	 0.30
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 1.12
                      internal	 3.63
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.37
                      inport	 b	 0.30
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.88
                      internal	 4.31
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.88
                      internal	 5.90
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.52
                      outport	 sdiv0	 0.84
                      internal	 6.43
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.51
                      inport	 b	 0.41
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.76
                      internal	 1.40
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.73
                      internal	 1.65
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.43
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.81
                      internal	 1.97
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.54
                      inport	 b	 0.34
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.85
                      internal	 2.31
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.42
                      inport	 b	 0.35
                      outport	 sdiv0	 0.51
                      outport	 sdiv0	 0.87
                      internal	 3.76
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.37
                      inport	 b	 0.35
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.85
                      internal	 4.65
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.37
                      inport	 b	 0.29
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 1.11
                      internal	 4.91
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.37
                      inport	 b	 0.30
                      outport	 sdiv0	 0.47
                      outport	 sdiv0	 0.86
                      internal	 6.23
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 0.90
                    path	 a	 r	 1.11
                    path	 b	 q	 0.91
                    inport	 a	 1.24
                    inport	 b	 1.18
                    outport	 divu	 1.34
                    outport	 reg_mode	 1.84
                    internal	 3.94
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 1.57
                    path	 a	 r	 1.09
                    path	 b	 q	 1.56
                    inport	 a	 1.75
                    inport	 b	 1.88
                    outport	 divu	 2.85
                    outport	 divu	 2.86
                    internal	 4.21
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 1.61
                    path	 a	 r	 1.23
                    path	 b	 q	 1.59
                    inport	 a	 4.07
                    inport	 b	 3.54
                    outport	 divu	 5.89
                    outport	 divu	 5.91
                    internal	 5.91
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 1.87
                    path	 a	 r	 1.86
                    path	 b	 q	 1.87
                    inport	 a	 7.97
                    inport	 b	 6.26
                    outport	 divu	 7.75
                    outport	 divu	 9.93
                    internal	 9.93
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 0.90
                    path	 a	 r	 1.11
                    path	 b	 q	 0.91
                    inport	 a	 1.24
                    inport	 b	 1.18
                    outport	 divu	 1.34
                    outport	 reg_mode	 1.84
                    internal	 3.94
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 1.57
                    path	 a	 r	 1.09
                    path	 b	 q	 1.56
                    inport	 a	 1.75
                    inport	 b	 1.88
                    outport	 divu	 2.85
                    outport	 divu	 2.86
                    internal	 4.21
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 1.61
                    path	 a	 r	 1.23
                    path	 b	 q	 1.59
                    inport	 a	 4.07
                    inport	 b	 3.54
                    outport	 divu	 5.89
                    outport	 divu	 5.91
                    internal	 5.91
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 1.87
                    path	 a	 r	 1.86
                    path	 b	 q	 1.87
                    inport	 a	 7.97
                    inport	 b	 6.26
                    outport	 divu	 7.75
                    outport	 divu	 9.93
                    internal	 9.93
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 0.84
                      path	 a	 r	 1.11
                      path	 b	 q	 0.85
                      inport	 a	 1.23
                      inport	 b	 0.94
                      outport	 reg_mode	 1.71
                      outport	 reg_mode	 2.10
                      internal	 3.92
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.32
                      path	 a	 r	 1.09
                      path	 b	 q	 1.33
                      inport	 a	 1.61
                      inport	 b	 2.00
                      outport	 divu	 2.74
                      outport	 divu	 2.76
                      internal	 4.59
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.71
                      path	 a	 r	 1.58
                      path	 b	 q	 1.72
                      inport	 a	 3.57
                      inport	 b	 4.06
                      outport	 divu	 5.82
                      outport	 divu	 5.82
                      internal	 5.82
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.50
                      path	 a	 r	 1.30
                      path	 b	 q	 1.51
                      inport	 a	 7.58
                      inport	 b	 8.24
                      outport	 divu	 7.59
                      outport	 divu	 10.01
                      internal	 10.01
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 0.71
                      path	 a	 r	 0.65
                      path	 b	 q	 0.72
                      inport	 a	 0.85
                      inport	 b	 0.82
                      outport	 divu	 1.10
                      outport	 divu	 1.18
                      internal	 1.39
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.00
                      path	 a	 r	 0.77
                      path	 b	 q	 1.00
                      inport	 a	 1.13
                      inport	 b	 1.47
                      outport	 divu	 1.64
                      outport	 divu	 1.48
                      internal	 1.64
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.21
                      path	 a	 r	 1.07
                      path	 b	 q	 1.24
                      inport	 a	 1.66
                      inport	 b	 1.84
                      outport	 divu	 2.05
                      outport	 divu	 2.08
                      internal	 1.93
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.42
                      path	 a	 r	 1.38
                      path	 b	 q	 1.42
                      inport	 a	 2.04
                      inport	 b	 2.16
                      outport	 divu	 2.41
                      outport	 divu	 2.32
                      internal	 2.27
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 0.90
                      path	 a	 r	 1.11
                      path	 b	 q	 0.91
                      inport	 a	 1.24
                      inport	 b	 1.18
                      outport	 divu	 1.34
                      outport	 reg_mode	 1.84
                      internal	 3.94
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 1.57
                      path	 a	 r	 1.09
                      path	 b	 q	 1.56
                      inport	 a	 1.75
                      inport	 b	 1.88
                      outport	 divu	 2.85
                      outport	 divu	 2.86
                      internal	 4.21
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 1.61
                      path	 a	 r	 1.23
                      path	 b	 q	 1.59
                      inport	 a	 4.07
                      inport	 b	 3.54
                      outport	 divu	 5.89
                      outport	 divu	 5.91
                      internal	 5.91
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 1.87
                      path	 a	 r	 1.86
                      path	 b	 q	 1.87
                      inport	 a	 7.97
                      inport	 b	 6.26
                      outport	 divu	 7.75
                      outport	 divu	 9.93
                      internal	 9.93
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 4.38
                    path	 a	 r	 4.65
                    path	 b	 q	 5.47
                    path	 b	 r	 5.70
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 20.62
                    path	 a	 r	 21.45
                    path	 b	 q	 22.63
                    path	 b	 r	 23.45
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 73.85
                    path	 a	 r	 74.52
                    path	 b	 q	 79.67
                    path	 b	 r	 80.34
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 279.04
                    path	 a	 r	 279.98
                    path	 b	 q	 290.81
                    path	 b	 r	 291.75
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 4.38
                    path	 a	 r	 4.65
                    path	 b	 q	 5.47
                    path	 b	 r	 5.70
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 20.62
                    path	 a	 r	 21.45
                    path	 b	 q	 22.63
                    path	 b	 r	 23.45
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 73.85
                    path	 a	 r	 74.52
                    path	 b	 q	 79.67
                    path	 b	 r	 80.34
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 4.15
                      path	 a	 r	 4.62
                      path	 b	 q	 5.23
                      path	 b	 r	 5.70
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 19.77
                      path	 a	 r	 20.74
                      path	 b	 q	 21.82
                      path	 b	 r	 22.79
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 74.34
                      path	 a	 r	 75.70
                      path	 b	 q	 80.07
                      path	 b	 r	 81.43
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 281.07
                      path	 a	 r	 282.07
                      path	 b	 q	 291.13
                      path	 b	 r	 292.13
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 1.30
                      path	 a	 r	 1.51
                      path	 b	 q	 1.36
                      path	 b	 r	 1.51
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 6.35
                      path	 a	 r	 6.62
                      path	 b	 q	 6.36
                      path	 b	 r	 6.63
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 20.59
                      path	 a	 r	 20.74
                      path	 b	 q	 20.62
                      path	 b	 r	 20.78
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 98.55
                      path	 a	 r	 98.63
                      path	 b	 q	 98.57
                      path	 b	 r	 98.65
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 4.38
                      path	 a	 r	 4.65
                      path	 b	 q	 5.47
                      path	 b	 r	 5.70
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 20.62
                      path	 a	 r	 21.45
                      path	 b	 q	 22.63
                      path	 b	 r	 23.45
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 73.85
                      path	 a	 r	 74.52
                      path	 b	 q	 79.67
                      path	 b	 r	 80.34
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 279.04
                      path	 a	 r	 279.98
                      path	 b	 q	 290.81
                      path	 b	 r	 291.75
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 4.57
                    path	 a	 r	 5.59
                    path	 b	 q	 5.32
                    path	 b	 r	 6.34
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 17.25
                    path	 a	 r	 17.96
                    path	 b	 q	 19.55
                    path	 b	 r	 20.26
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.87
                    path	 a	 r	 66.36
                    path	 b	 q	 70.36
                    path	 b	 r	 70.86
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 285.77
                    path	 a	 r	 286.79
                    path	 b	 q	 296.86
                    path	 b	 r	 297.88
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 4.57
                    path	 a	 r	 5.59
                    path	 b	 q	 5.32
                    path	 b	 r	 6.34
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 17.25
                    path	 a	 r	 17.96
                    path	 b	 q	 19.55
                    path	 b	 r	 20.26
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.87
                    path	 a	 r	 66.36
                    path	 b	 q	 70.36
                    path	 b	 r	 70.86
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 4.54
                      path	 a	 r	 5.32
                      path	 b	 q	 4.73
                      path	 b	 r	 5.51
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 19.01
                      path	 a	 r	 19.95
                      path	 b	 q	 21.05
                      path	 b	 r	 21.99
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 73.83
                      path	 a	 r	 75.21
                      path	 b	 q	 78.42
                      path	 b	 r	 79.80
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 294.04
                      path	 a	 r	 295.04
                      path	 b	 q	 303.43
                      path	 b	 r	 304.42
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 1.67
                      path	 a	 r	 1.81
                      path	 b	 q	 1.67
                      path	 b	 r	 1.81
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 6.86
                      path	 a	 r	 7.00
                      path	 b	 q	 6.87
                      path	 b	 r	 7.01
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 23.13
                      path	 a	 r	 23.31
                      path	 b	 q	 23.17
                      path	 b	 r	 23.34
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 108.51
                      path	 a	 r	 108.67
                      path	 b	 q	 108.81
                      path	 b	 r	 108.97
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 4.57
                      path	 a	 r	 5.59
                      path	 b	 q	 5.32
                      path	 b	 r	 6.34
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 17.25
                      path	 a	 r	 17.96
                      path	 b	 q	 19.55
                      path	 b	 r	 20.26
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 65.87
                      path	 a	 r	 66.36
                      path	 b	 q	 70.36
                      path	 b	 r	 70.86
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 285.77
                      path	 a	 r	 286.79
                      path	 b	 q	 296.86
                      path	 b	 r	 297.88
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 6.70
                    path	 a	 r	 7.25
                    path	 b	 q	 7.00
                    path	 b	 r	 7.55
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.53
                    path	 a	 r	 22.84
                    path	 b	 q	 23.30
                    path	 b	 r	 24.60
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 76.24
                    path	 a	 r	 78.64
                    path	 b	 q	 79.58
                    path	 b	 r	 81.98
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 288.57
                    path	 a	 r	 289.97
                    path	 b	 q	 300.30
                    path	 b	 r	 301.70
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 6.70
                    path	 a	 r	 7.25
                    path	 b	 q	 7.00
                    path	 b	 r	 7.55
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.53
                    path	 a	 r	 22.84
                    path	 b	 q	 23.30
                    path	 b	 r	 24.60
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 76.24
                    path	 a	 r	 78.64
                    path	 b	 q	 79.58
                    path	 b	 r	 81.98
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 6.22
                      path	 a	 r	 6.73
                      path	 b	 q	 7.09
                      path	 b	 r	 7.53
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 22.38
                      path	 a	 r	 23.36
                      path	 b	 q	 24.02
                      path	 b	 r	 25.00
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 79.64
                      path	 a	 r	 81.25
                      path	 b	 q	 82.35
                      path	 b	 r	 83.97
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 290.65
                      path	 a	 r	 293.33
                      path	 b	 q	 300.47
                      path	 b	 r	 303.15
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 2.29
                      path	 a	 r	 2.36
                      path	 b	 q	 2.29
                      path	 b	 r	 2.36
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 7.41
                      path	 a	 r	 7.46
                      path	 b	 q	 7.41
                      path	 b	 r	 7.46
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 21.11
                      path	 a	 r	 21.11
                      path	 b	 q	 21.11
                      path	 b	 r	 21.12
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 84.86
                      path	 a	 r	 84.91
                      path	 b	 q	 84.87
                      path	 b	 r	 84.92
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 6.70
                      path	 a	 r	 7.25
                      path	 b	 q	 7.00
                      path	 b	 r	 7.55
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 21.53
                      path	 a	 r	 22.84
                      path	 b	 q	 23.30
                      path	 b	 r	 24.60
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 76.24
                      path	 a	 r	 78.64
                      path	 b	 q	 79.58
                      path	 b	 r	 81.98
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 288.57
                      path	 a	 r	 289.97
                      path	 b	 q	 300.30
                      path	 b	 r	 301.70
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 6.53
                    path	 a	 r	 6.92
                    path	 b	 q	 7.37
                    path	 b	 r	 7.76
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.18
                    path	 a	 r	 22.29
                    path	 b	 q	 23.41
                    path	 b	 r	 24.52
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.59
                    path	 a	 r	 65.85
                    path	 b	 q	 69.04
                    path	 b	 r	 69.30
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 172.66
                    path	 a	 r	 174.53
                    path	 b	 q	 176.80
                    path	 b	 r	 178.67
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 6.53
                    path	 a	 r	 6.92
                    path	 b	 q	 7.37
                    path	 b	 r	 7.76
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.18
                    path	 a	 r	 22.29
                    path	 b	 q	 23.41
                    path	 b	 r	 24.52
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.59
                    path	 a	 r	 65.85
                    path	 b	 q	 69.04
                    path	 b	 r	 69.30
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 5.68
                      path	 a	 r	 5.90
                      path	 b	 q	 6.58
                      path	 b	 r	 6.81
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 21.62
                      path	 a	 r	 22.35
                      path	 b	 q	 23.93
                      path	 b	 r	 24.66
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 64.64
                      path	 a	 r	 65.82
                      path	 b	 q	 67.81
                      path	 b	 r	 68.99
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 177.56
                      path	 a	 r	 177.86
                      path	 b	 q	 181.70
                      path	 b	 r	 182.00
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 1.83
                      path	 a	 r	 1.87
                      path	 b	 q	 1.81
                      path	 b	 r	 1.86
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 6.73
                      path	 a	 r	 6.76
                      path	 b	 q	 6.74
                      path	 b	 r	 6.77
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 19.12
                      path	 a	 r	 19.36
                      path	 b	 q	 19.13
                      path	 b	 r	 19.37
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 51.43
                      path	 a	 r	 51.58
                      path	 b	 q	 51.51
                      path	 b	 r	 51.67
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 6.53
                      path	 a	 r	 6.92
                      path	 b	 q	 7.37
                      path	 b	 r	 7.76
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 21.18
                      path	 a	 r	 22.29
                      path	 b	 q	 23.41
                      path	 b	 r	 24.52
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 65.59
                      path	 a	 r	 65.85
                      path	 b	 q	 69.04
                      path	 b	 r	 69.30
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 172.66
                      path	 a	 r	 174.53
                      path	 b	 q	 176.80
                      path	 b	 r	 178.67
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 5.31
                    path	 a	 r	 5.74
                    path	 b	 q	 5.88
                    path	 b	 r	 6.31
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.93
                    path	 a	 r	 22.63
                    path	 b	 q	 23.83
                    path	 b	 r	 24.52
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.02
                    path	 a	 r	 65.39
                    path	 b	 q	 67.69
                    path	 b	 r	 68.07
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 177.77
                    path	 a	 r	 178.07
                    path	 b	 q	 180.62
                    path	 b	 r	 180.92
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 5.31
                    path	 a	 r	 5.74
                    path	 b	 q	 5.88
                    path	 b	 r	 6.31
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 21.93
                    path	 a	 r	 22.63
                    path	 b	 q	 23.83
                    path	 b	 r	 24.52
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 65.02
                    path	 a	 r	 65.39
                    path	 b	 q	 67.69
                    path	 b	 r	 68.07
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 5.86
                      path	 a	 r	 6.07
                      path	 b	 q	 6.55
                      path	 b	 r	 6.76
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 21.40
                      path	 a	 r	 22.03
                      path	 b	 q	 23.12
                      path	 b	 r	 23.75
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 62.02
                      path	 a	 r	 63.22
                      path	 b	 q	 64.45
                      path	 b	 r	 65.64
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 169.44
                      path	 a	 r	 170.37
                      path	 b	 q	 172.80
                      path	 b	 r	 173.73
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 1.84
                      path	 a	 r	 2.09
                      path	 b	 q	 1.86
                      path	 b	 r	 2.11
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 6.11
                      path	 a	 r	 6.27
                      path	 b	 q	 6.12
                      path	 b	 r	 6.28
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 18.42
                      path	 a	 r	 18.58
                      path	 b	 q	 18.43
                      path	 b	 r	 18.59
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 47.72
                      path	 a	 r	 47.89
                      path	 b	 q	 47.78
                      path	 b	 r	 47.94
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 5.31
                      path	 a	 r	 5.74
                      path	 b	 q	 5.88
                      path	 b	 r	 6.31
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 21.93
                      path	 a	 r	 22.63
                      path	 b	 q	 23.83
                      path	 b	 r	 24.52
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 65.02
                      path	 a	 r	 65.39
                      path	 b	 q	 67.69
                      path	 b	 r	 68.07
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 177.77
                      path	 a	 r	 178.07
                      path	 b	 q	 180.62
                      path	 b	 r	 180.92
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 q	 7.13
                    path	 a	 r	 7.51
                    path	 b	 q	 7.72
                    path	 b	 r	 8.10
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 24.78
                    path	 a	 r	 24.87
                    path	 b	 q	 25.86
                    path	 b	 r	 25.95
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 73.03
                    path	 a	 r	 74.50
                    path	 b	 q	 73.47
                    path	 b	 r	 74.94
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 192.46
                    path	 a	 r	 192.80
                    path	 b	 q	 195.66
                    path	 b	 r	 196.00
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 q	 7.13
                    path	 a	 r	 7.51
                    path	 b	 q	 7.72
                    path	 b	 r	 8.10
                  </data>
                  <data bit_width="8">
                    path	 a	 q	 24.78
                    path	 a	 r	 24.87
                    path	 b	 q	 25.86
                    path	 b	 r	 25.95
                  </data>
                  <data bit_width="16">
                    path	 a	 q	 73.03
                    path	 a	 r	 74.50
                    path	 b	 q	 73.47
                    path	 b	 r	 74.94
                  </data>
                  <data bit_width="32">
                    path	 a	 q	 100
                    path	 a	 r	 100
                    path	 b	 q	 100
                    path	 b	 r	 100
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 q	 7.66
                      path	 a	 r	 7.98
                      path	 b	 q	 8.55
                      path	 b	 r	 8.87
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 24.35
                      path	 a	 r	 24.04
                      path	 b	 q	 25.71
                      path	 b	 r	 25.41
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 69.37
                      path	 a	 r	 70.61
                      path	 b	 q	 70.57
                      path	 b	 r	 71.81
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 188.00
                      path	 a	 r	 190.88
                      path	 b	 q	 193.20
                      path	 b	 r	 196.08
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 q	 2.38
                      path	 a	 r	 2.42
                      path	 b	 q	 2.38
                      path	 b	 r	 2.42
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 7.78
                      path	 a	 r	 7.80
                      path	 b	 q	 7.81
                      path	 b	 r	 7.82
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 19.67
                      path	 a	 r	 19.71
                      path	 b	 q	 19.69
                      path	 b	 r	 19.72
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 49.49
                      path	 a	 r	 49.69
                      path	 b	 q	 49.50
                      path	 b	 r	 49.69
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 q	 7.13
                      path	 a	 r	 7.51
                      path	 b	 q	 7.72
                      path	 b	 r	 8.10
                    </data>
                    <data bit_width="8">
                      path	 a	 q	 24.78
                      path	 a	 r	 24.87
                      path	 b	 q	 25.86
                      path	 b	 r	 25.95
                    </data>
                    <data bit_width="16">
                      path	 a	 q	 73.03
                      path	 a	 r	 74.50
                      path	 b	 q	 73.47
                      path	 b	 r	 74.94
                    </data>
                    <data bit_width="32">
                      path	 a	 q	 192.46
                      path	 a	 r	 192.80
                      path	 b	 q	 195.66
                      path	 b	 r	 196.00
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="power">
          
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4"> 318.4694 </data>
                  <data bit_width="8"> 593.4914 </data>
                  <data bit_width="16"> 1237 </data>
                  <data bit_width="32"> 1642.3 </data>
                </max>
                <min>
                  <data bit_width="4"> 298.7745 </data>
                  <data bit_width="8"> 537.5029 </data>
                  <data bit_width="16"> 1106.7 </data>
                  <data bit_width="32"> 1451 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 298.7745 </data>
                    <data bit_width="8"> 593.4914 </data>
                    <data bit_width="16"> 1237 </data>
                    <data bit_width="32"> 1642.3 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 301.2545 </data>
                    <data bit_width="8"> 537.5029 </data>
                    <data bit_width="16"> 1109.8 </data>
                    <data bit_width="32"> 1548.3 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 318.4694 </data>
                    <data bit_width="8"> 544.7934 </data>
                    <data bit_width="16"> 1106.7 </data>
                    <data bit_width="32"> 1451 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4"> 297.1020 </data>
                  <data bit_width="8"> 471.3623 </data>
                  <data bit_width="16"> 880.8623 </data>
                  <data bit_width="32"> 1119.1 </data>
                </max>
                <min>
                  <data bit_width="4"> 283.5941 </data>
                  <data bit_width="8"> 460.3742 </data>
                  <data bit_width="16"> 835.6219 </data>
                  <data bit_width="32"> 1003.4 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 283.5941 </data>
                    <data bit_width="8"> 460.5271 </data>
                    <data bit_width="16"> 880.8623 </data>
                    <data bit_width="32"> 1119.1 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 285.9065 </data>
                    <data bit_width="8"> 471.3623 </data>
                    <data bit_width="16"> 835.6219 </data>
                    <data bit_width="32"> 1003.4 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 297.1020 </data>
                    <data bit_width="8"> 460.3742 </data>
                    <data bit_width="16"> 875.1608 </data>
                    <data bit_width="32"> 1107.1 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4"> 340.2390 </data>
                  <data bit_width="8"> 534.9455 </data>
                  <data bit_width="16"> 944.1481 </data>
                  <data bit_width="32"> 1249.7 </data>
                </max>
                <min>
                  <data bit_width="4"> 320.8606 </data>
                  <data bit_width="8"> 519.2766 </data>
                  <data bit_width="16"> 925.3356 </data>
                  <data bit_width="32"> 1018.5 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 325.3176 </data>
                    <data bit_width="8"> 521.6802 </data>
                    <data bit_width="16"> 944.1481 </data>
                    <data bit_width="32"> 1018.5 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 320.8606 </data>
                    <data bit_width="8"> 534.9455 </data>
                    <data bit_width="16"> 925.3356 </data>
                    <data bit_width="32"> 1249.7 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 340.2390 </data>
                    <data bit_width="8"> 519.2766 </data>
                    <data bit_width="16"> 932.2499 </data>
                    <data bit_width="32"> 1026 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4"> 307.8978 </data>
                  <data bit_width="8"> 528.0146 </data>
                  <data bit_width="16"> 1072.9 </data>
                  <data bit_width="32"> 1538 </data>
                </max>
                <min>
                  <data bit_width="4"> 295.1077 </data>
                  <data bit_width="8"> 498.3704 </data>
                  <data bit_width="16"> 996.3539 </data>
                  <data bit_width="32"> 1436 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 295.1077 </data>
                    <data bit_width="8"> 500.0167 </data>
                    <data bit_width="16"> 1063.9 </data>
                    <data bit_width="32"> 1460.4 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 302.9686 </data>
                    <data bit_width="8"> 528.0146 </data>
                    <data bit_width="16"> 996.3539 </data>
                    <data bit_width="32"> 1538 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 307.8978 </data>
                    <data bit_width="8"> 498.3704 </data>
                    <data bit_width="16"> 1072.9 </data>
                    <data bit_width="32"> 1436 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4"> 299.5314 </data>
                  <data bit_width="8"> 469.8615 </data>
                  <data bit_width="16"> 826.4698 </data>
                  <data bit_width="32"> 1023 </data>
                </max>
                <min>
                  <data bit_width="4"> 284.1765 </data>
                  <data bit_width="8"> 445.2886 </data>
                  <data bit_width="16"> 640.2348 </data>
                  <data bit_width="32"> 1017.5 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 284.1765 </data>
                    <data bit_width="8"> 445.2886 </data>
                    <data bit_width="16"> 640.2348 </data>
                    <data bit_width="32"> 1020.1 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 286.0500 </data>
                    <data bit_width="8"> 469.8615 </data>
                    <data bit_width="16"> 826.4698 </data>
                    <data bit_width="32"> 1017.5 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 299.5314 </data>
                    <data bit_width="8"> 451.3227 </data>
                    <data bit_width="16"> 644.1907 </data>
                    <data bit_width="32"> 1023 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4"> 340.7472 </data>
                  <data bit_width="8"> 536.9392 </data>
                  <data bit_width="16"> 926.0313 </data>
                  <data bit_width="32"> 1258.5 </data>
                </max>
                <min>
                  <data bit_width="4"> 321.8026 </data>
                  <data bit_width="8"> 520.9402 </data>
                  <data bit_width="16"> 913.7979 </data>
                  <data bit_width="32"> 1210 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 329.1729 </data>
                    <data bit_width="8"> 528.9767 </data>
                    <data bit_width="16"> 913.7979 </data>
                    <data bit_width="32"> 1210 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 321.8026 </data>
                    <data bit_width="8"> 536.9392 </data>
                    <data bit_width="16"> 926.0313 </data>
                    <data bit_width="32"> 1258.5 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 340.7472 </data>
                    <data bit_width="8"> 520.9402 </data>
                    <data bit_width="16"> 914.8425 </data>
                    <data bit_width="32"> 1233.4 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4"> 273.9829 </data>
                  <data bit_width="8"> 1136.5 </data>
                  <data bit_width="16"> 3446.1 </data>
                  <data bit_width="32"> 10810.7 </data>
                </max>
                <min>
                  <data bit_width="4"> 71.2485 </data>
                  <data bit_width="8"> 571.8047 </data>
                  <data bit_width="16"> 2128.5 </data>
                  <data bit_width="32"> 8898.6 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 72.6281 </data>
                    <data bit_width="8"> 571.8047 </data>
                    <data bit_width="16"> 2128.5 </data>
                    <data bit_width="32"> 8898.6 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 273.9829 </data>
                    <data bit_width="8"> 1136.5 </data>
                    <data bit_width="16"> 3446.1 </data>
                    <data bit_width="32"> 10810.7 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 71.2485 </data>
                    <data bit_width="8"> 600.9440 </data>
                    <data bit_width="16"> 2459.2 </data>
                    <data bit_width="32"> 9489.9 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4"> 1054.7 </data>
                  <data bit_width="8"> 2200 </data>
                  <data bit_width="16"> 4267.9 </data>
                  <data bit_width="32"> 23879.5 </data>
                </max>
                <min>
                  <data bit_width="4"> 80.5874 </data>
                  <data bit_width="8"> 572.6766 </data>
                  <data bit_width="16"> 3613.7 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 120.4081 </data>
                    <data bit_width="8"> 758.7520 </data>
                    <data bit_width="16"> 3615 </data>
                    <data bit_width="32"> 10862.4 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1054.7 </data>
                    <data bit_width="8"> 2200 </data>
                    <data bit_width="16"> 4267.9 </data>
                    <data bit_width="32"> 23879.5 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 80.5874 </data>
                    <data bit_width="8"> 572.6766 </data>
                    <data bit_width="16"> 3613.7 </data>
                    <data bit_width="32"> 11563.8 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4"> 505.5423 </data>
                  <data bit_width="8"> 1513.9 </data>
                  <data bit_width="16"> 3902.1 </data>
                  <data bit_width="32"> 10845.4 </data>
                </max>
                <min>
                  <data bit_width="4"> 141.6405 </data>
                  <data bit_width="8"> 615.3133 </data>
                  <data bit_width="16"> 2331.6 </data>
                  <data bit_width="32"> 8363.7 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 157.2558 </data>
                    <data bit_width="8"> 615.3133 </data>
                    <data bit_width="16"> 2331.6 </data>
                    <data bit_width="32"> 8363.7 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 505.5423 </data>
                    <data bit_width="8"> 1513.9 </data>
                    <data bit_width="16"> 3902.1 </data>
                    <data bit_width="32"> 10845.4 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 141.6405 </data>
                    <data bit_width="8"> 639.8572 </data>
                    <data bit_width="16"> 2431.7 </data>
                    <data bit_width="32"> 9499.7 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4"> 183.0298 </data>
                  <data bit_width="8"> 1293.8 </data>
                  <data bit_width="16"> 3283 </data>
                  <data bit_width="32"> 16329.9 </data>
                </max>
                <min>
                  <data bit_width="4"> 102.7428 </data>
                  <data bit_width="8"> 671.5324 </data>
                  <data bit_width="16"> 2860.4 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 102.7428 </data>
                    <data bit_width="8"> 671.5324 </data>
                    <data bit_width="16"> 3041.3 </data>
                    <data bit_width="32"> 14038.6 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 183.0298 </data>
                    <data bit_width="8"> 1293.8 </data>
                    <data bit_width="16"> 2860.4 </data>
                    <data bit_width="32"> 10631.1 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 109.5477 </data>
                    <data bit_width="8"> 732.6342 </data>
                    <data bit_width="16"> 3283 </data>
                    <data bit_width="32"> 16329.9 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4"> 452.4268 </data>
                  <data bit_width="8"> 1291.4 </data>
                  <data bit_width="16"> 4868.7 </data>
                  <data bit_width="32"> 27294.2 </data>
                </max>
                <min>
                  <data bit_width="4"> 80.4126 </data>
                  <data bit_width="8"> 758.0208 </data>
                  <data bit_width="16"> 4272.9 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 92.9533 </data>
                    <data bit_width="8"> 758.0208 </data>
                    <data bit_width="16"> 4272.9 </data>
                    <data bit_width="32"> 13870.6 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 452.4268 </data>
                    <data bit_width="8"> 1291.4 </data>
                    <data bit_width="16"> 4558.3 </data>
                    <data bit_width="32"> 27294.2 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 80.4126 </data>
                    <data bit_width="8"> 986.3793 </data>
                    <data bit_width="16"> 4868.7 </data>
                    <data bit_width="32"> 25438.2 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4"> 495.4196 </data>
                  <data bit_width="8"> 1440.5 </data>
                  <data bit_width="16"> 3139.3 </data>
                  <data bit_width="32"> 14306.2 </data>
                </max>
                <min>
                  <data bit_width="4"> 176.9378 </data>
                  <data bit_width="8"> 692.7177 </data>
                  <data bit_width="16"> 2878.3 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 178.1541 </data>
                    <data bit_width="8"> 692.7177 </data>
                    <data bit_width="16"> 3027.4 </data>
                    <data bit_width="32"> 13280.9 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 495.4196 </data>
                    <data bit_width="8"> 1440.5 </data>
                    <data bit_width="16"> 2878.3 </data>
                    <data bit_width="32"> 10140.8 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 176.9378 </data>
                    <data bit_width="8"> 745.7358 </data>
                    <data bit_width="16"> 3139.3 </data>
                    <data bit_width="32"> 14306.2 </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="seq,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">
              <parameters name="seq,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="seq,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="div">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="divu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="diva">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">

            <!-- Dummy yet -->

          </est_type>

        </library>     

      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for divider(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="seq,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="seq,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="seq,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0];
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>
</FHM>
