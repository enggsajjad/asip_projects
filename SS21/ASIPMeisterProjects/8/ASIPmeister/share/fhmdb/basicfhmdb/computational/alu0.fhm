<?xml version="1.0" encoding="UTF-8" ?>
<FHM>
  <model_name> alu </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yamane Yukinori ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%                 Copyright 2002 PEAS Project                    %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
        <value> 256 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCTION
unsigned   addu(twoscomp a, twoscomp b);
unsigned   subu(twoscomp a, twoscomp b);
unsigned   add(twoscomp a, twoscomp b);
unsigned   sub(twoscomp a, twoscomp b);
unsigned   and(twoscomp a, twoscomp b);
unsigned   or(twoscomp a, twoscomp b);
unsigned   xor(twoscomp a, twoscomp b);
unsigned   nor(twoscomp a, twoscomp b);
unsigned   cmpu(twoscomp a, twoscomp b);
unsigned   cmp(twoscomp a, twoscomp b);
unsigned   cmpzu(twoscomp a);
unsigned   cmpz(twoscomp a);
signed     inc(twoscomp a);
unsigned   incu(twoscomp a);
unsigned   dec(twoscomp a);
unsigned   cdec(twoscomp a);
unsigned   caddu(twoscomp a, twoscomp b);
signed     cadd(twoscomp a, twoscomp b);
unsigned   csubu(twoscomp a, twoscomp b);
signed     csub(twoscomp a, twoscomp b);
bit_vector alu_flag(bit_vector mode, bit_vector a, bit_vector b, bit cin);
 
/** ${bit_width}-th alu */
model alu${bit_width}{
  port{
    in  a[${bit_width_1}:0], b[${bit_width_1}:0], cin, mode[4:0];
    out result[${bit_width_1}:0], flag[3:0];
  }

   /** C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else '0'
       V is '1' when overflowed and signed-mode else '0'
       S is equal to MSB of result
       Z is '1' when result = 0 else '0' */

  /** caddu : unsigned clip add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function caddu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** cadd : signed clip add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cadd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cadd(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** csubu : unsigned clip subtract, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function csubu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** csub : signed clip subtract, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function csub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csub(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** addu : unsigned add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** subu : unsigned sub, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** add : signed add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function add{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = add(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** sub : signed sub, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function sub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = sub(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** and : and, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function and{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = and(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** or : or, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function or{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = or(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** xor : xor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function xor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = xor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nor : nor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpu : unsigned comp, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cmpu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmp : signed comp, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cmp{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cmp(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpzu : unsigned comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cmpzu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cmpzu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpz : signed comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cmpz{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cmpz(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** inc : inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function inc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = inc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** incu : unsigned inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function incu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = incu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** dec : unsigned dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function dec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = dec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cdec : unsigned dec(clip), flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cdec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cdec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }
}
FHM_DL_FUNCTION
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCCONV
/** unsigned clip add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function caddu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00101";
      cin = '0';
    }
  }
}

/** signed clip add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cadd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01101";
      cin = '0';
    }
  }
}

/** unsigned clip subtract, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function csubu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00110";
      cin = '1';
    }
  }
}

/** signed clip subtract, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function csub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01110";
      cin = '1';
    }
  }
}

/** unsigned add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00001";
      cin = '0';
    }
  }
}

/** unsigned sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function add {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01001";
      cin = '0';
    }
  }
}

/** signed sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function sub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** and, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function and {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10010";
    }
  }
}

/** or, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function or {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10000";
    }
  }
}

/** xor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function xor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10001";
    }
  }
}

/** nor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11000";
    }
  }
}

/** unsigned cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cmp {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** unsigned cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpzu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '0';
    }
  }
}

/** signed cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpz {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '0';
    }
  }
}

/** increment, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function inc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '1';
    }
  }
}

/** unsigned increment, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function incu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '1';
    }
  }
}

/** unsigned decrement, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function dec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00011";
      cin = '0';
    }
  }
}

/** unsigned decrement(clip), flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cdec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00111";
      cin = '0';
    }
  }
}
FHM_DL_FUNCCONV
}
exit(0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu port infomation in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}


$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_PORTINFO
a	in	bit_vector   $bit_width_1   0	data
b	in	bit_vector   $bit_width_1   0	data
cin	in	bit		mode
mode	in	bit_vector   4   0	mode
result	out	bit_vector   $bit_width_1   0	data
flag	out	bit_vector   3   0	data
FHM_DL_PORTINFO
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

$bit_width_1 = $bit_width - 1;

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";

$x_str = "X" x $bit_width;
$x_str = "\"" . $x_str . "\"";

{
print <<FHM_DL_INSTANCE
-- Module     : Arithmetic Logic Unit
-- Feature    : 
-- References : 
-- Author     : Designed by T.Morifuji (c)1997,1998.

-- Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue

-- Comment : function table is followings.
--  +-----------+-------------+-------------+---------+
--  |   mode    |   cin = 0   |   cin = 1   |  flag   |
--  +-----------+-------------+-------------+---------+
--  | 4 3 2 1 0 |   result    |   result    | c z s v |
--  +-----------+-------------+-------------+---------+
--  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
--  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
--  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
--  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
--  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
--  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
--  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
--  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
--  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
--  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
--  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
--  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
--  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
--  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
--  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
--  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
--  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
--  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
--  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
--  | 1 0 0 1 1 |           not a           | 0 * * 0 |
--  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
--  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
--  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
--  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
--  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
--  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
--  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
--  | 1 1 0 1 1 |             |             | 0 * * * |
--  | 1 1 1 0 0 |             |             | 0 * * * |
--  | 1 1 1 0 1 |             |             | 0 * * * |
--  | 1 1 1 1 0 |             |             | 0 * * * |
--  | 1 1 1 1 1 |             |             | 0 * * * |
--  +-----------+-------------+-------------+---------+
-- C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
--      '0';
-- V is '1' when overflowed and signed-mode else
--      '0';
-- S is equal to MSB of result;
-- Z is '1' when result = 0 else
--      '0';

-- Functionality : behavior level
--  port
--   a, b   : datas
--   cin    : carry in
--   mode   : control (refer to the above table)
--   result : result of calculation
--   flag   : flag of result (refer to the above table)


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_arith.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (a, b 	: in std_logic_vector($bit_width_1 downto 0);
        cin     : in std_logic;
        mode 	: in std_logic_vector(4 downto 0);
        result 	: out std_logic_vector($bit_width_1 downto 0);
        flag 	: out std_logic_vector(3 downto 0) );
end $instance_name;


architecture behavior of $instance_name is

  -- purpose: adder
  procedure ${instance_name}_add (
    constant a, b   : in  std_logic_vector($bit_width_1 downto 0);
    constant cin    : in  std_logic;
    variable result : out std_logic_vector($bit_width_1 downto 0);
    variable cout   : out std_logic) is
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin  -- ${instance_name}_add
    int_a := '0' & a;
    int_b := '0' & b;
    int_result := int_a + int_b + cin;
    result := int_result($bit_width_1 downto 0);
    cout := int_result($bit_width);
  end ${instance_name}_add;

begin

  process(a, b, cin, mode)
    variable pre_result    : std_logic_vector($bit_width_1 downto 0);
    variable s_max, s_min  : std_logic_vector($bit_width_1 downto 0);
    variable C, Z, S, V    : std_logic;

  begin

    case mode is
      when "00000" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "00001" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "00010" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "00011" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "00100" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "00101" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "00110" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "00111" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "01000" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "01001" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "01010" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "01011" =>
        ${instance_name}_add(a,not $one,cin,pre_result,C);
      when "01100" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "01101" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "01110" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "01111" =>
        ${instance_name}_add(a,not $one,cin,pre_result,C);
      when "10000" =>
        pre_result := a or b;
      when "10001" =>
        pre_result := a xor b;
      when "10010" =>
        pre_result := a and b;
      when "10011" =>
        pre_result := not a;
      when "10100" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10101" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10110" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10111" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "11000" =>
        pre_result := not ( a or b );
      when "11001" =>
        pre_result := not ( a xor b );
      when "11010" =>
        pre_result := not ( a and b );
      when others =>
        pre_result := $x_str;
    end case;

    if mode(4 downto 2) = "100" or mode(4 downto 3) = "11" then
      C := '0';
    end if;

    if pre_result = $zero then
      Z := '1';
    else
      Z := '0';
    end if;

    S := pre_result($bit_width_1);

    V := '0';
    case mode is
      when "01000" | "01100" =>
        if a($bit_width_1)='0' and pre_result($bit_width_1)='1' then
          V := '1';
        end if;
      when "01001" | "01101" =>
        if     ( a($bit_width_1)='0' and b($bit_width_1)='0'
                 and pre_result($bit_width_1)='1' )
            or ( a($bit_width_1)='1' and b($bit_width_1)='1'
                 and pre_result($bit_width_1)='0' ) then
          V := '1';
        end if;
      when "01010" | "01110" | "10110" | "10111" =>
        if     ( a($bit_width_1)='0' and b($bit_width_1)='1'
                 and pre_result($bit_width_1)='1' )
            or ( a($bit_width_1)='1' and b($bit_width_1)='0'
                 and pre_result($bit_width_1)='0' ) then
          V := '1';
        end if;
      when "01011" | "01111" =>
        if a($bit_width_1)='1' and pre_result($bit_width_1)='0' then
          V := '1';
        end if;
      when others =>
        V := '0';
    end case;


    if a($bit_width_1) = '0' and b($bit_width_1) = '1' then
      s_max := a;
    elsif a($bit_width_1) = '1' and b($bit_width_1) = '0' then
      s_max := b;
    elsif a($bit_width_1) = '0' and C = '1' then
      s_max := a;
    else
      s_max := b;
    end if;

    if a($bit_width_1) = '0' and b($bit_width_1) = '1' then
      s_max := b;
    elsif a($bit_width_1) = '1' and b($bit_width_1) = '0' then
      s_max := a;
    elsif a($bit_width_1) = '0' and C = '1' then
      s_max := b;
    else
      s_max := a;
    end if;

    if mode(3 downto 2) = "01" then
      if C = '1' and mode(1) = '0' then
        pre_result := $one;
      elsif C = '0' and mode(1) = '1' then
        pre_result := $zero;
      end if;
    elsif mode (3 downto 2) = "11" and V = '1' then
      if C = '0' and mode(1) = '0' then
        pre_result := s_max;
      else
        pre_result := s_min;
      end if;
    end if;

    if mode(4 downto 1) = "1010" then
      if (C = '1' and mode(0) = '0') or (C = '0' and mode(0) = '1') then
        pre_result := a;
      elsif (C = '1' and mode(0) = '1') or (C = '0' and mode(0) = '0') then
        pre_result := b;
      end if;
    end if;

    if mode(4 downto 1) = "1011" then
      if ( a($bit_width_1) = '0' and b($bit_width_1) = '1'
           and mode(0) = '0') or
         ( a($bit_width_1) = '1' and b($bit_width_1) = '0'
           and mode(0) = '1') then
        pre_result := a;
      elsif ( a($bit_width_1) = '1' and b($bit_width_1) = '0'
             and mode(0) = '0') or
           ( a($bit_width_1) = '0' and b($bit_width_1) = '1'
             and mode(0) = '1') then
        pre_result := b;
      elsif (C = '1' and mode(0) = '0') or (C = '0' and mode(0) = '1') then
        pre_result := a;
      elsif (C = '1' and mode(0) = '1') or (C = '0' and mode(0) = '0') then
        pre_result := b;
      end if;
    end if;

    result <= pre_result;
    flag <= C & Z & S & V;

  end process;
end behavior;
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu entity information in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}


$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

{
print <<FHM_DL_ENTINFO
entity $instance_name is
  port (a, b   : in std_logic_vector($bit_width-1 downto 0);
        cin    : in std_logic;
        result : out std_logic_vector($bit_width-1 downto 0);
        cout   : out std_logic);
end $instance_name;
FHM_DL_ENTINFO
}
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates alu synthesis script in behavior level
# parameter : instance_name priority bit_width

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width\n";
    exit (100);
}


$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "Not supported priority\n";
  exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="4"> 0.168215591382495 </data>
                  <data bit_width="8"> 0.385634843443575 </data>
                  <data bit_width="16"> 0.522368828659013 </data>
                  <data bit_width="32"> 1.04257322832772 </data>
                  <data bit_width="256"> 7.58054943950991 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.094535593619695 </data>
                  <data bit_width="8"> 0.152732544125207 </data>
                  <data bit_width="16"> 0.265588983930237 </data>
                  <data bit_width="32"> 0.535712054463929 </data>
                  <data bit_width="256"> 5.10001821438091 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 9.53 </data>
                  <data bit_width="8"> 12.67 </data>
                  <data bit_width="16"> 19.51 </data>
                  <data bit_width="32"> 32.75 </data>
                  <data bit_width="256"> 239.94 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.24 </data>
                  <data bit_width="8"> 4.61 </data>
                  <data bit_width="16"> 5.90 </data>
                  <data bit_width="32"> 6.27 </data>
                  <data bit_width="256"> 9.56 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="">
                <max>
                  <data bit_width="4"> 74.1982 </data>
                  <data bit_width="8"> 159.0084 </data>
                  <data bit_width="16"> 214.0195 </data>
                  <data bit_width="32"> 411.9496 </data>
                  <data bit_width="256"> 2849.1 </data>
                </max>
                <min>
                  <data bit_width="4"> 32.0087 </data>
                  <data bit_width="8"> 48.1682 </data>
                  <data bit_width="16"> 90.3668 </data>
                  <data bit_width="32"> 168.9971 </data>
                  <data bit_width="256"> 1586.9 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by logarithm expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;

	$log_bit[$i] = log($bit[$i]) / log(4);
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $log_bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@log_bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $log_bit[$i] * $log_bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@log_bit) * &sum(@log_bit);


# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}

	
$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@log_bit)) / $n;

$ret_data = $a * log($ARGV[1]) / log(4) + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;



for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += $bit_width * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $bit[$i] * $bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@bit) * &sum(@bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }


    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@bit)) / $n;
    
    $ret_data = $a * $ARGV[1] + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by logarithm expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$log_bit[$n] = log($bit_width) / log(4);
	
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\/data\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t\t\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;

for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += log($bit_width) / log(4) * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@log_bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $log_bit[$i] * $log_bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@log_bit) * &sum(@log_bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }

    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@log_bit)) / $n;
    
    $ret_data = $a * log($ARGV[1]) / log(4) + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> rt </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yamane Yukinori ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[ (c)2001,PEAS3-Lite Project ]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
        <value> 256 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCTION
unsigned   addu(twoscomp a, twoscomp b);
unsigned   subu(twoscomp a, twoscomp b);
unsigned   add(twoscomp a, twoscomp b);
unsigned   sub(twoscomp a, twoscomp b);
unsigned   and(twoscomp a, twoscomp b);
unsigned   or(twoscomp a, twoscomp b);
unsigned   xor(twoscomp a, twoscomp b);
unsigned   nor(twoscomp a, twoscomp b);
unsigned   cmpu(twoscomp a, twoscomp b);
unsigned   cmp(twoscomp a, twoscomp b);
unsigned   cmpzu(twoscomp a);
unsigned   cmpz(twoscomp a);
signed     inc(twoscomp a);
unsigned   incu(twoscomp a);
unsigned   dec(twoscomp a);
unsigned   cdec(twoscomp a);
unsigned   caddu(twoscomp a, twoscomp b);
signed     cadd(twoscomp a, twoscomp b);
unsigned   csubu(twoscomp a, twoscomp b);
signed     csub(twoscomp a, twoscomp b);
bit_vector alu_flag(bit_vector mode, bit_vector a, bit_vector b, bit cin);
 
/** ${bit_width}-th alu */
model alu${bit_width}{
  port{
    in  a[${bit_width_1}:0], b[${bit_width_1}:0], cin, mode[4:0];
    out result[${bit_width_1}:0], flag[3:0];
  }

   /** C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else '0'
       V is '1' when overflowed and signed-mode else '0'
       S is equal to MSB of result
       Z is '1' when result = 0 else '0' */

  /** caddu : unsigned clip add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function caddu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** cadd : signed clip add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cadd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cadd(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** csub : signed clip subtract, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function csub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csub(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** csubu : unsigned clip subtract, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function csubu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** addu : unsigned add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** subu : unsigned sub, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** add : signed add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function add{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = add(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** sub : signed sub, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function sub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = sub(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** and : and, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function and{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = and(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** or : or, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function or{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = or(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** xor : xor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function xor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = xor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nor : nor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpu : unsigned comp, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cmpu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmp : signed comp, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cmp{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cmp(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpzu : unsigned comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cmpzu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cmpzu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpz : signed comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cmpz{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cmpz(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** inc : inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function inc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = inc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** incu : unsigned inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function incu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = incu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** dec : unsigned dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function dec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = dec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cdec : unsigned dec(clip), flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cdec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cdec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }
}
FHM_DL_FUNCTION
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}

$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCCONV
/** unsigned clip add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function caddu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00101";
      cin = '0';
    }
  }
}

/** signed clip add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cadd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01101";
      cin = '0';
    }
  }
}

/** unsigned clip subtract, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function csubu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00110";
      cin = '1';
    }
  }
}

/** signed clip subtract, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function csub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01110";
      cin = '1';
    }
  }
}

/** unsigned add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00001";
      cin = '0';
    }
  }
}

/** unsigned sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function add {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01001";
      cin = '0';
    }
  }
}

/** signed sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function sub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** and, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function and {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10010";
    }
  }
}

/** or, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function or {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10000";
    }
  }
}

/** xor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function xor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10001";
    }
  }
}

/** nor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11000";
    }
  }
}

/** unsigned cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cmp {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** unsigned cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpzu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '0';
    }
  }
}

/** signed cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpz {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '0';
    }
  }
}

/** increment, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function inc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '1';
    }
  }
}

/** unsigned increment, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function incu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '1';
    }
  }
}

/** unsigned decrement, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function dec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00011";
      cin = '0';
    }
  }
}

/** unsigned decrement(clip), flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cdec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00111";
      cin = '0';
    }
  }
}
FHM_DL_FUNCCONV
}
exit(0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu port infomation in behavior level
# parameter : bit_width

if ($#ARGV != 0){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width\n";
    exit (100);
}


$bit_width = $ARGV[0];
$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_PORTINFO
a	in	bit_vector   $bit_width_1   0	data
b	in	bit_vector   $bit_width_1   0	data
cin	in	bit		mode
mode	in	bit_vector   4   0	mode
result	out	bit_vector   $bit_width_1   0	data
flag	out	bit_vector   3   0	data
FHM_DL_PORTINFO
}
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates shifter instance in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

$bit_width_1 = $bit_width - 1;

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";

$x_str = "X" x $bit_width;
$x_str = "\"" . $x_str . "\"";

{
print <<FHM_DL_INSTANCE
-- Module     : Arithmetic Logic Unit
-- Feature    : 
-- References : 
-- Author     : Designed by T.Morifuji (c)1997,1998.

-- Version : 1.3  : Modified by Y.Yamane 2002/01/15 Tue

-- Comment : function table is followings.
--  +-----------+-------------+-------------+---------+
--  |   mode    |   cin = 0   |   cin = 1   |  flag   |
--  +-----------+-------------+-------------+---------+
--  | 4 3 2 1 0 |   result    |   result    | c z s v |
--  +-----------+-------------+-------------+---------+
--  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
--  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
--  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
--  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
--  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
--  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
--  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
--  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
--  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
--  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
--  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
--  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
--  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
--  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
--  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
--  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
--  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
--  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
--  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
--  | 1 0 0 1 1 |           not a           | 0 * * 0 |
--  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
--  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
--  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
--  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
--  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
--  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
--  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
--  | 1 1 0 1 1 |             |             | 0 * * * |
--  | 1 1 1 0 0 |             |             | 0 * * * |
--  | 1 1 1 0 1 |             |             | 0 * * * |
--  | 1 1 1 1 0 |             |             | 0 * * * |
--  | 1 1 1 1 1 |             |             | 0 * * * |
--  +-----------+-------------+-------------+---------+
-- C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
--      '0';
-- V is '1' when overflowed and signed-mode else
--      '0';
-- S is equal to MSB of result;
-- Z is '1' when result = 0 else
--      '0';

-- Functionality : behavior level
--  port
--   a, b   : datas
--   cin    : carry in
--   mode   : control (refer to the above table)
--   result : result of calculation
--   flag   : flag of result (refer to the above table)


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_arith.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (a, b 	: in std_logic_vector($bit_width_1 downto 0);
        cin     : in std_logic;
        mode 	: in std_logic_vector(4 downto 0);
        result 	: out std_logic_vector($bit_width_1 downto 0);
        flag 	: out std_logic_vector(3 downto 0) );
end $instance_name;


architecture behavior of $instance_name is

  -- purpose: adder
  procedure ${instance_name}_add (
    constant a, b   : in  std_logic_vector($bit_width_1 downto 0);
    constant cin    : in  std_logic;
    variable result : out std_logic_vector($bit_width_1 downto 0);
    variable cout   : out std_logic) is
    variable int_a, int_b : std_logic_vector($bit_width downto 0);
    variable int_result   : std_logic_vector($bit_width downto 0);
  begin  -- ${instance_name}_add
    int_a := '0' & a;
    int_b := '0' & b;
    int_result := int_a + int_b + cin;
    result := int_result($bit_width_1 downto 0);
    cout := int_result($bit_width);
  end ${instance_name}_add;

begin

  process(a, b, cin, mode)
    variable pre_result    : std_logic_vector($bit_width_1 downto 0);
    variable s_max, s_min  : std_logic_vector($bit_width_1 downto 0);
    variable C, Z, S, V    : std_logic;

  begin

    case mode is
      when "00000" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "00001" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "00010" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "00011" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "00100" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "00101" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "00110" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "00111" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "01000" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "01001" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "01010" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "01011" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "01100" =>
        ${instance_name}_add(a,$zero,cin,pre_result,C);
      when "01101" =>
        ${instance_name}_add(a,b,cin,pre_result,C);
      when "01110" =>
        ${instance_name}_add(a,not b,cin,pre_result,C);
      when "01111" =>
        ${instance_name}_add(a,$one,cin,pre_result,C);
      when "10000" =>
        pre_result := a or b;
      when "10001" =>
        pre_result := a xor b;
      when "10010" =>
        pre_result := a and b;
      when "10011" =>
        pre_result := not a;
      when "10100" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10101" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10110" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "10111" =>
        ${instance_name}_add(a,not b,'1',pre_result,C);
      when "11000" =>
        pre_result := not ( a or b );
      when "11001" =>
        pre_result := not ( a xor b );
      when "11010" =>
        pre_result := not ( a and b );
      when others =>
        pre_result := $x_str;
    end case;

    if mode(4 downto 2) = "100" or mode(4 downto 3) = "11" then
      C := '0';
    end if;

    if pre_result = $zero then
      Z := '1';
    else
      Z := '0';
    end if;

    S := pre_result($bit_width_1);

    if mode(4 downto 3) = "00" or mode(4 downto 2) = "100"
       or mode(4 downto 1) = "1010" or mode(4 downto 2) = "110" then
      V := '0';
    elsif     ( a($bit_width_1)='0' and b($bit_width_1)='0'
               and pre_result($bit_width_1)='1' )
           or ( a($bit_width_1)='1' and b($bit_width_1)='1'
               and pre_result($bit_width_1)='0' ) then
      V := '1';
    else
      V := '0';
    end if;

    if a($bit_width_1) = '0' and b($bit_width_1) = '1' then
      s_max := a;
    elsif a($bit_width_1) = '1' and b($bit_width_1) = '0' then
      s_max := b;
    elsif a($bit_width_1) = '0' and C = '1' then
      s_max := a;
    else
      s_max := b;
    end if;

    if a($bit_width_1) = '0' and b($bit_width_1) = '1' then
      s_max := b;
    elsif a($bit_width_1) = '1' and b($bit_width_1) = '0' then
      s_max := a;
    elsif a($bit_width_1) = '0' and C = '1' then
      s_max := b;
    else
      s_max := a;
    end if;

    if mode(3 downto 2) = "01" then
      if C = '1' and mode(1) = '0' then
        pre_result := $one;
      elsif C = '1' and mode(1) = '1' then
        pre_result := $zero;
      end if;
    elsif mode (3 downto 2) = "11" and V = '1' then
      if C = '0' and mode(1) = '0' then
        pre_result := s_max;
      else
        pre_result := s_min;
      end if;
    end if;

    result <= pre_result;
    flag <= C & Z & S & V;

  end process;
end behavior;
FHM_DL_INSTANCE
}
exit(0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu entity information in behavior level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}


$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

{
print <<FHM_DL_ENTINFO
entity $instance_name is
  port (a, b   : in std_logic_vector($bit_width-1 downto 0);
        cin    : in std_logic;
        result : out std_logic_vector($bit_width-1 downto 0);
        cout   : out std_logic);
end $instance_name;
FHM_DL_ENTINFO
}
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates alu synthesis script in behavior level
# parameter : instance_name priority bit_width

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width\n";
    exit (100);
}


$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "Not supported priority\n";
  exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="4"> 0.168215591382495 </data>
                  <data bit_width="8"> 0.385634843443575 </data>
                  <data bit_width="16"> 0.522368828659013 </data>
                  <data bit_width="32"> 1.04257322832772 </data>
                  <data bit_width="256"> 7.58054943950991 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.094535593619695 </data>
                  <data bit_width="8"> 0.152732544125207 </data>
                  <data bit_width="16"> 0.265588983930237 </data>
                  <data bit_width="32"> 0.535712054463929 </data>
                  <data bit_width="256"> 5.10001821438091 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 9.53 </data>
                  <data bit_width="8"> 12.67 </data>
                  <data bit_width="16"> 19.51 </data>
                  <data bit_width="32"> 32.75 </data>
                  <data bit_width="256"> 239.94 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.24 </data>
                  <data bit_width="8"> 4.61 </data>
                  <data bit_width="16"> 5.90 </data>
                  <data bit_width="32"> 6.27 </data>
                  <data bit_width="256"> 9.56 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
            <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="">
                <max>
                  <data bit_width="4"> 74.1982 </data>
                  <data bit_width="8"> 159.0084 </data>
                  <data bit_width="16"> 214.0195 </data>
                  <data bit_width="32"> 411.9496 </data>
                  <data bit_width="256"> 2849.1 </data>
                </max>
                <min>
                  <data bit_width="4"> 32.0087 </data>
                  <data bit_width="8"> 48.1682 </data>
                  <data bit_width="16"> 90.3668 </data>
                  <data bit_width="32"> 168.9971 </data>
                  <data bit_width="256"> 1586.9 </data>
                </min>
                <typ>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <!-- Dummy yet -->
          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by logarithm expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;

	$log_bit[$i] = log($bit[$i]) / log(4);
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $log_bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@log_bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $log_bit[$i] * $log_bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@log_bit) * &sum(@log_bit);


# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}

	
$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@log_bit)) / $n;

$ret_data = $a * log($ARGV[1]) / log(4) + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;



for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += $bit_width * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $bit[$i] * $bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@bit) * &sum(@bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }


    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@bit)) / $n;
    
    $ret_data = $a * $ARGV[1] + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by logarithm expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$log_bit[$n] = log($bit_width) / log(4);
	
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\/data\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t\t\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;

for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += log($bit_width) / log(4) * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@log_bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $log_bit[$i] * $log_bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@log_bit) * &sum(@log_bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }

    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@log_bit)) / $n;
    
    $ret_data = $a * log($ARGV[1]) / log(4) + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Yamane Yukinori ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[ (c)2001,PEAS3-Lite Project ]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 64 </value>
        <value> 128 </value>
        <value> 256 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> rca </value>
        <value> cla </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCTION
unsigned   addu(twoscomp a, twoscomp b);
unsigned   subu(twoscomp a, twoscomp b);
unsigned   add(twoscomp a, twoscomp b);
unsigned   sub(twoscomp a, twoscomp b);
unsigned   and(twoscomp a, twoscomp b);
unsigned   or(twoscomp a, twoscomp b);
unsigned   xor(twoscomp a, twoscomp b);
unsigned   nor(twoscomp a, twoscomp b);
unsigned   cmpu(twoscomp a, twoscomp b);
unsigned   cmp(twoscomp a, twoscomp b);
unsigned   cmpzu(twoscomp a);
unsigned   cmpz(twoscomp a);
signed     inc(twoscomp a);
unsigned   incu(twoscomp a);
unsigned   dec(twoscomp a);
unsigned   cdec(twoscomp a);
unsigned   caddu(twoscomp a, twoscomp b);
signed     cadd(twoscomp a, twoscomp b);
unsigned   csubu(twoscomp a, twoscomp b);
signed     csub(twoscomp a, twoscomp b);
bit_vector alu_flag(bit_vector mode, bit_vector a, bit_vector b, bit cin);

/** ${bit_width}-th alu */
model alu${bit_width}{
  port{
    in  a[${bit_width_1}:0], b[${bit_width_1}:0], cin, mode[4:0];
    out result[${bit_width_1}:0], flag[3:0];
  }

   /** C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else '0'
       V is '1' when overflowed and signed-mode else '0'
       S is equal to MSB of result
       Z is '1' when result = 0 else '0' */

  /** caddu : unsigned clip add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function caddu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = caddu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** cadd : signed clip add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cadd{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cadd(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01101" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** csubu : unsigned clip subtract, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function csubu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csubu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** csub : signed clip subtract, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function csub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = csub(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01110" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** addu : unsigned add, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function addu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = addu(a, b);
      bit_vector flag = alu_flag(mode, a, b);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }
  
  /** subu : unsigned sub, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function subu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = subu(a, b, cin);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** add : signed add, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function add{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = add(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01001" && cin == '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** sub : signed sub, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function sub{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = sub(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin == '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** and : and, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function and{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = and(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10010"]{
	valid result;
	valid flag;
      }
    }
  }

  /** or : or, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function or{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = or(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** xor : xor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function xor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = xor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "10001"]{
	valid result;
	valid flag;
      }
    }
  }

  /** nor : nor, flag(3)=0, flag(2):Z, flag(1):S, flag(0)=0 */
  function nor{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = nor(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
    }
    protocol{
      [mode == "11000"]{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpu : unsigned comp, flag(3):C, flag(2):Z, flag(1):S, flag(0)=0 */
  function cmpu{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cmpu(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00010" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmp : signed comp, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function cmp{
    input{
      unsigned a, b;
    }
    output{
      unsigned   result = cmp(a, b);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01010" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpzu : unsigned comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cmpzu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cmpzu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cmpz : signed comp with zero, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cmpz{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cmpz(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** inc : inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):V */
  function inc{
    input{
      unsigned a;
    }
    output{
      unsigned   result = inc(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "01000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** incu : unsigned inc, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function incu{
    input{
      unsigned a;
    }
    output{
      unsigned   result = incu(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00000" && cin = '1']{
	valid result;
	valid flag;
      }
    }
  }

  /** dec : unsigned dec, flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function dec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = dec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00011" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }

  /** cdec : unsigned dec(clip), flag(3):C, flag(2):Z, flag(1):S, flag(0):0 */
  function cdec{
    input{
      unsigned a;
    }
    output{
      unsigned   result = cdec(a);
      bit_vector flag = alu_flag(mode, a, b, cin);
    }
    control{
      in mode;
      in cin;
    }
    protocol{
      [mode == "00111" && cin = '0']{
	valid result;
	valid flag;
      }
    }
  }
}
FHM_DL_FUNCTION
}
exit(0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu function definition in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_FUNCCONV
/** unsigned clip add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function caddu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00101";
      cin = '0';
    }
  }
}

/** signed clip add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cadd {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01101";
      cin = '0';
    }
  }
}

/** unsigned clip subtract, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function csubu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00110";
      cin = '1';
    }
  }
}

/** signed clip subtract, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function csub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01110";
      cin = '1';
    }
  }
}

/** unsigned add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function addu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00001";
      cin = '0';
    }
  }
}

/** unsigned sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function subu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed add, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function add {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01001";
      cin = '0';
    }
  }
}

/** signed sub, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function sub {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** and, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function and {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10010";
    }
  }
}

/** or, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function or {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10000";
    }
  }
}

/** xor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function xor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "10001";
    }
  }
}

/** nor, flag(3) = 0, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function nor {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
  }
  protocol {
    single_cycle_protocol {
      mode = "11000";
    }
  }
}

/** unsigned cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpu {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00010";
      cin = '1';
    }
  }
}

/** signed cmp, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V*/
function cmp {
  input {
    bit [$bit_width_1:0] a;
    bit [$bit_width_1:0] b;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01010";
      cin = '1';
    }
  }
}

/** unsigned cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpzu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '0';
    }
  }
}

/** signed cmp zero, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cmpz {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '0';
    }
  }
}

/** increment, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = V */
function inc {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "01000";
      cin = '1';
    }
  }
}

/** unsigned increment, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0 */
function incu {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00000";
      cin = '1';
    }
  }
}

/** unsigned decrement, flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function dec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00011";
      cin = '0';
    }
  }
}

/** unsigned decrement(clip), flag(3) = C, flag(2) = Z, flag(1) = S, flag(0) = 0*/
function cdec {
  input {
    bit [$bit_width_1:0] a;
  }
  output {
    bit [$bit_width_1:0] result;
    bit [3:0]  flag;
  }
  control {
    in bit [4:0] mode;
    in bit	 cin;
  }
  protocol {
    single_cycle_protocol {
      mode = "00111";
      cin = '0';
    }
  }
}
FHM_DL_FUNCCONV
}
exit(0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates alu port infomation in synthesis level
# parameter : bit_width algorithm

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm\n";
    exit (100);
}


$bit_width = $ARGV[0];
$algorithm = $ARGV[1];

$bit_width_1 = $bit_width - 1;

{
print <<FHM_DL_PORTINFO
a	in	bit_vector   $bit_width_1   0	data
b	in	bit_vector   $bit_width_1   0	data
cin	in	bit		mode
mode	in	bit_vector   4   0	mode
result	out	bit_vector   $bit_width_1   0	data
flag	out	bit_vector   3   0	data
FHM_DL_PORTINFO
}
exit(0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu instance in synthesis level
# parameter : instance_name bit_width algorithm

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm\n";
    exit (100);
}


$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];

$zero = "0" x $bit_width;
$zero = "\"" . $zero . "\"";
$one  = "1" x $bit_width;
$one  = "\"" . $one . "\"";

$x_str  = "1" x $bit_width;
$x_str  = "\"" . $x_str . "\"";

#system 'fhmdbms', "einstance(%FHMROOT/basicfhmdb/computational/adder, gate, ${instance_name}_add, $bit_width, $algorithm)";

# --- Start of Adder
if ("$algorithm" eq "rca"){
  print <<FHM_DL_RCA
-- Module     : 1-bit Full Adder
-- Feature    : 
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0  :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add_fa is
    port (a:      in  std_logic;
          b:      in  std_logic;
          cin:    in  std_logic;
          result: out std_logic;
          cout:   out std_logic );
end ${instance_name}_add_fa;

architecture synthesis of ${instance_name}_add_fa is
begin

   result <= (not a and b and not cin) or
	     (a and not b and not cin) or
             (not a and not b and cin) or 
	     (a and b and cin);

   cout <= (a and b and not cin) or 
           (not a and b and cin) or 
           (a and not b and cin) or 
           (a and b and cin);

end synthesis;

--%%

-- Module     : N-bit Ripple Carry Ahead Adder
-- Feature    : N = 4, 8, 16, 24, 32
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0

-- Functionality : synthesis level
--  port
--   a, b   : can represent from 0 to 2^$bit_width-1 in integer
--   cin    : meens carry in
--   result : added result
--   cout   : '1' when result > 2^$bit_width-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add is
    port (a, b   : in  std_logic_vector($bit_width-1 downto 0);
          cin    : in  std_logic;
          result : out std_logic_vector($bit_width-1 downto 0);
          cout   : out std_logic);
end ${instance_name}_add;

architecture synthesis of ${instance_name}_add is

   component ${instance_name}_add_fa
      port (a:      in  std_logic;
            b:      in  std_logic;
            cin:    in  std_logic;
            result: out std_logic;
            cout:   out std_logic);
   end component;

   signal  ctmp :  std_logic_vector($bit_width downto 0);

begin

   ctmp(0) <= cin;

   full_adder: for i in $bit_width-1 downto 0 generate
   fan: ${instance_name}_add_fa 
      port map (a      => a(i),
                b      => b(i),
                cin    => ctmp(i),
                result => result(i),
                cout   => ctmp(i+1));
   end generate full_adder;

   cout <= ctmp($bit_width);

end synthesis;

FHM_DL_RCA
}
elsif ("$algorithm" eq "cla"){
  $rem64   = $bit_width % 64;
  $count64 = ($bit_width - $rem64) / 64;
  $rem16   = $rem64 % 16;
  $count16 = ($rem64 - $rem16) / 16;
  $count1  = $rem16 % 4;
  $count4  = ($rem16 - $count1) / 4;

  $req64 = $count64;
  $req16 = $req64 + $count16;
  $req4  = $req16 + $count4;

  if ($req4 != 0){
    print <<FHM_DL_CLA4
-- Module     : 4bit Carry Look Ahead Adder
-- Feature    : 
-- References : Computer Architecture
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add4 is
  port (a, b       : in  std_logic_vector(3 downto 0);
        cin        : in  std_logic;
        result     : out std_logic_vector(3 downto 0);
        pout, gout : out std_logic);
end ${instance_name}_add4;

architecture synthesis of ${instance_name}_add4 is

  signal p, g  : std_logic_vector(3 downto 0);
  signal carry : std_logic_vector(2 downto 0);

begin  --  gate

  --  make carry generate
  g(0) <= a(0) and b(0);
  g(1) <= a(1) and b(1);
  g(2) <= a(2) and b(2);
  g(3) <= a(3) and b(3);

  --  make carry propagate
  p(0) <= a(0) xor b(0);
  p(1) <= a(1) xor b(1);
  p(2) <= a(2) xor b(2);
  p(3) <= a(3) xor b(3);
  
  --   make internal carry and external carry
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout  <= p(3) and p(2) and p(1) and p(0);
  gout  <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
            or (p(3) and p(2) and p(1) and g(0));

  --  make sum.
  result(0) <= p(0) xor cin;
  result(1) <= p(1) xor carry(0);
  result(2) <= p(2) xor carry(1);
  result(3) <= p(3) xor carry(2);

end synthesis;

--%%

FHM_DL_CLA4
  }
  if ($req16 != 0){
    print <<FHM_DL_CLA16
-- Module     : 16bit Carry Look Ahead Adder
-- Feature    : 
-- References : Computer Architecture
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add16 is
  port (a, b       : in std_logic_vector(15 downto 0);
        cin        : in std_logic;
        result     : out std_logic_vector(15 downto 0);
        pout, gout : out std_logic);
end ${instance_name}_add16;

architecture synthesis of ${instance_name}_add16 is

  component ${instance_name}_add4
    port (a, b       : in  std_logic_vector(3 downto 0);
          cin        : in  std_logic;
          result     : out std_logic_vector(3 downto 0);
          pout, gout : out std_logic);
  end component;

  signal p, g  : std_logic_vector(3 downto 0);
  signal carry : std_logic_vector(2 downto 0);

--  for all : ${instance_name}_add4
--    use entity work.${instance_name}_add4(gate);
begin  --  gate

  -- make internal carry and carry propagate/generate
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout <= p(3) and p(2) and p(1) and p(0);
  gout <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
          or (p(3) and p(2) and p(1) and g(0));
  
  -- work adder
  u0 : ${instance_name}_add4
    port map (a(3 downto 0), b(3 downto 0), cin,
              result(3 downto 0), p(0), g(0));
  u1 : ${instance_name}_add4
    port map (a(7 downto 4), b(7 downto 4), carry(0),
              result(7 downto 4), p(1), g(1));
  u2 : ${instance_name}_add4
    port map (a(11 downto 8), b(11 downto 8), carry(1),
              result(11 downto 8), p(2), g(2));
  u3 : ${instance_name}_add4
    port map (a(15 downto 12), b(15 downto 12), carry(2),
              result(15 downto 12), p(3), g(3));

end synthesis;

--%%

FHM_DL_CLA16
  }
  if ($req64 != 0){
    print <<FHM_DL_CLA64
-- Module     : 64bit Carry Look Ahead Adder
-- Feature    : 
-- References : Computer Architecture
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add64 is
  port (a, b       : in std_logic_vector(63 downto 0);
        cin        : in std_logic;
        result     : out std_logic_vector(63 downto 0);
        pout, gout : out std_logic);
end ${instance_name}_add64;

architecture synthesis of ${instance_name}_add64 is

  component ${instance_name}_add16
    port (a, b       : in std_logic_vector(15 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(15 downto 0);
          pout, gout : out std_logic);
  end component;

  signal        p, g             : std_logic_vector(3 downto 0);
  signal        carry            : std_logic_vector(2 downto 0);

--  for all : ${instance_name}_add16
--    use entity work.${instance_name}_add16(gate);
begin  --  synthesis 

  -- make internal carry and carry propagate/generate
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout <= p(3) and p(2) and p(1) and p(0);
  gout <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
          or (p(3) and p(2) and p(1) and g(0));
  
  -- work adder
  u0 : ${instance_name}_add16
    port map (a(15 downto 0), b(15 downto 0), cin,
              result(15 downto 0), p(0), g(0));
  u1 : ${instance_name}_add16
    port map (a(31 downto 16), b(31 downto 16), carry(0),
              result(31 downto 16), p(1), g(1));
  u2 : ${instance_name}_add16
    port map (a(47 downto 32), b(47 downto 32), carry(1),
              result(47 downto 32), p(2), g(2));
  u3 : ${instance_name}_add16
    port map (a(63 downto 48), b(63 downto 48), carry(2),
              result(63 downto 48), p(3), g(3));

end synthesis;

--%%

FHM_DL_CLA64
  }{
  print <<FHM_DL_CLA_BEGIN
-- Module     : $bit_width bit Carry Look Ahead Adder
-- Feature    : 
-- References : Computer Architecture
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_add is
  port (a, b   : in  std_logic_vector($bit_width-1 downto 0);
        cin    : in  std_logic;
        result : out std_logic_vector($bit_width-1 downto 0);
        cout   : out std_logic);
end ${instance_name}_add;

architecture synthesis of ${instance_name}_add is

FHM_DL_CLA_BEGIN
  }
  if ($count64 != 0){
    print <<FHM_DL_CLA_COMP64
  component ${instance_name}_add64
    port (a, b       : in std_logic_vector(63 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(63 downto 0);
          pout, gout : out std_logic);
  end component;

--  for all : ${instance_name}_add64
--    use entity work.${instance_name}_add64(gate);

FHM_DL_CLA_COMP64
  }
  if ($count16 != 0){
    print <<FHM_DL_CLA_COMP16
  component ${instance_name}_add16
    port (a, b       : in std_logic_vector(15 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(15 downto 0);
          pout, gout : out std_logic);
  end component;

--  for all : ${instance_name}_add16
--    use entity work.${instance_name}_add16(gate);

FHM_DL_CLA_COMP16
  }
  if ($count4 != 0){
    print <<FHM_DL_CLA_COMP4
  component ${instance_name}_add4
    port (a, b       : in std_logic_vector(3 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(3 downto 0);
          pout, gout : out std_logic);
  end component;

--  for all : ${instance_name}_add4
--    use entity work.${instance_name}_add4(gate);

FHM_DL_CLA_COMP4
  }
  if ($req4 >= 1){
    $tmp = $req4 - 1;
    print "  signal p, g      : std_logic_vector($tmp downto 0);\n";
    print "  signal carry     : std_logic_vector($tmp downto 0);\n";
  }
  if ($count1 != 0){
    $tmp = $count1 - 1;
    print "  signal gres,pres : std_logic_vector($tmp downto 0);\n";
  }
  if ($count1 > 1){
    $tmp = $count1 - 2;
    print "  signal carry_res : std_logic_vector($tmp downto 0);\n";
  }
 
  print "begin\n";

  for ($carry=0; $carry<$req4; $carry++){
    print "  carry($carry) <= g($carry) or\n";
    $tmp = $carry;

    for ($g=$carry; $g>=0; $g--,$tmp--){
      print "              (";

      for ($p=$carry; $p>=$tmp; $p--){
        print "p($p) and ";
      }
      if ($g == 0){
        print "cin);\n";
      }
      else{
        print "g($p)) or\n";
      }
    }
  }

  print "\n";

  $bit_tmp = 0;
  $p = 0;
  $g = 0;

  for ($loop=0,$bit_tmp_63=$bit_tmp+63; $loop<=$count64-1;
       $loop++,$bit_tmp+=64,$bit_tmp_63+=64,$p++,$g++){
    print "  u64_$loop : ${instance_name}_add64\n";
    print "    port map (a($bit_tmp_63 downto $bit_tmp),";
    print " b($bit_tmp_63 downto $bit_tmp),";

    if ($bit_tmp == 0){
      print "cin,\n";
    }
    else{
      $tmp = $p - 1;
      print "carry($tmp),\n";
    }

    print "              result($bit_tmp_63 downto $bit_tmp),";
    print " p($p), g($g));\n";
  }

  for ($loop=0,$bit_tmp_15=$bit_tmp+15; $loop<=$count16-1;
       $loop++,$bit_tmp+=16,$bit_tmp_15+=16,$p++,$g++){
    print "  u16_$loop : ${instance_name}_add16\n";
    print "    port map (a($bit_tmp_15 downto $bit_tmp),";
    print " b($bit_tmp_15 downto $bit_tmp),";

    if ($bit_tmp == 0){
      print "cin,\n";
    }
    else{
      $tmp = $p - 1;
      print "carry($tmp),\n";
    }

    print "              result($bit_tmp_15 downto $bit_tmp),";
    print " p($p), g($g));\n";
  }

  for ($loop=0,$bit_tmp_3=$bit_tmp+3; $loop<=$count4-1;
       $loop++,$bit_tmp+=4,$bit_tmp_3+=4,$p++,$g++){
    print "  u4_$loop : ${instance_name}_add4\n";
    print "    port map (a($bit_tmp_3 downto $bit_tmp),";
    print " b($bit_tmp_3 downto $bit_tmp),";

    if ($bit_tmp == 0){
      print "cin,\n";
    }
    else{
      $tmp = $p - 1;
      print "carry($tmp),\n";
    }

    print "              result($bit_tmp_3 downto $bit_tmp),";
    print " p($p), g($g));\n";
  }

  for ($loop=0,$tmp=$bit_tmp; $loop<=$count1-1; $loop++,$tmp++){
    print "  gres($loop) <= a($tmp) and b($tmp);\n";
  }
  print "\n";
  for ($loop=0,$tmp=$bit_tmp; $loop<=$count1-1; $loop++,$tmp++){
    print "  pres($loop) <= a($tmp) xor b($tmp);\n";
  }
  if ($count1 == 0){
    $tmp = $req4 - 1;
    print "  cout <= carry($tmp);\n";
  }

  for ($carry=0; $carry<=$count1-1; $carry++){
    if ($carry == $count1 - 1){
      print "  cout <= gres($carry) or\n";
    }
    else{
      print "  carry_res($carry) <= gres($carry) or\n";
    }
    $tmp = $carry;

    for ($g=$carry; $g>=0; $g--,$tmp--){
      print "              (";

      for ($p=$carry; $p>=$tmp; $p--){
        print "pres($p) and ";
      }

      if ($g == 0){
        if ($req4 == 0){
          print "cin);\n";
        }
        else{
          $tmp2 = $req4 - 1;
          print "carry($tmp2));\n";
	}
      }
      else{
	print "gres($p)) or\n";
      }
    }
    if ($carry == $count1-1){
	print "\n";
    }
  }

  for ($loop=0,$tmp=$bit_tmp; $loop<=$count1-1; $loop++,$tmp++){
    if ($req4 eq 0){
      if ($loop eq 0){
	print "  result($tmp) <= pres($loop) xor cin;\n";
      }
      else{
	$tmp2 = $loop - 1;
	print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
      }            
    }
    else{
      if ($loop eq 0){
	$tmp2 = $req4 - 1;
	print "  result($tmp) <= pres($loop) xor carry($tmp2);\n";
      }
      else{
	$tmp2 = $loop - 1;
	print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
      }
    }
  }
  print "end synthesis;\n";
}
else{
  print "false\n";
  exit (100);
}

# --- End of Adder
{
print <<FHM_DL_INSTANCE

--%
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
-- Module     : Arithmetic Logic Unit
-- Feature    : 
-- References : 
-- Author     : Designed by T.Morifuji (c)1997,1998.

-- Version : 1.1  : all test is ok.
-- Version : 1.2  : modified by Y.Yamane 2001/12/26

-- Comment : function table is followings.
--  +-----------+-------------+-------------+---------+
--  |   mode    |   cin = 0   |   cin = 1   |  flag   |
--  +-----------+-------------+-------------+---------+
--  | 4 3 2 1 0 |   result    |   result    | c z s v |
--  +-----------+-------------+-------------+---------+
--  | 0 0 0 0 0 | a           | a + 1       | * * * 0 | unsigned (c)
--  | 0 0 0 0 1 | a + b       | a + b + 1   | * * * 0 | unsigned (c)
--  | 0 0 0 1 0 | a - b - 1   | a - b       | * * * 0 | unsigned (c)
--  | 0 0 0 1 1 | a - 1       | a           | * * * 0 | unsigned (c)
--  | 0 0 1 0 0 | a           | a +] 1      | * * * 0 | unsigned clip
--  | 0 0 1 0 1 | a +] b      | a +] b +] 1 | * * * 0 | unsigned clip
--  | 0 0 1 1 0 | a -] b -] 1 | a -] b      | * * * 0 | unsigned clip
--  | 0 0 1 1 1 | a -] 1      | a           | * * * 0 | unsigned clip
--  | 0 1 0 0 0 | a           | a + 1       | * * * * | signed (v)
--  | 0 1 0 0 1 | a + b       | a + b + 1   | * * * * | signed (v)
--  | 0 1 0 1 0 | a - b - 1   | a - b       | * * * * | signed (v)
--  | 0 1 0 1 1 | a - 1       | a           | * * * * | signed (v)
--  | 0 1 1 0 0 | a           | a +] 1      | * * * * | signed clip
--  | 0 1 1 0 1 | a +] b      | a +] b +] 1 | * * * * | signed clip
--  | 0 1 1 1 0 | a -] b -] 1 | a -] b      | * * * * | signed clip
--  | 0 1 1 1 1 | a -] 1      | a           | * * * * | signed clip
--  | 1 0 0 0 0 |           a or b          | 0 * * 0 |
--  | 1 0 0 0 1 |          a xor b          | 0 * * 0 |
--  | 1 0 0 1 0 |          a and b          | 0 * * 0 |
--  | 1 0 0 1 1 |           not a           | 0 * * 0 |
--  | 1 0 1 0 0 |             | max(a, b)   | * * * 0 | unsigned
--  | 1 0 1 0 1 |             | min(a, b)   | * * * 0 | unsigned
--  | 1 0 1 1 0 |             | max(a, b)   | * * * * | signed
--  | 1 0 1 1 1 |             | min(a, b)   | * * * * | signed
--  | 1 1 0 0 0 |          a nor b          | 0 * * 0 |
--  | 1 1 0 0 1 |         a nxor b          | 0 * * 0 |
--  | 1 1 0 1 0 |         a nand b          | 0 * * 0 |
--  | 1 1 0 1 1 |             |             | 0 * * 0 |
--  | 1 1 1 0 0 |             |             | 0 * * * |
--  | 1 1 1 0 1 |             |             | 0 * * * |
--  | 1 1 1 1 0 |             |             | 0 * * * |
--  | 1 1 1 1 1 |             |             | 0 * * * |
--  +-----------+-------------+-------------+---------+
-- C is '1' when (carry-occurred or not-bollowed) and unsigned-mode else
--      '0';
-- V is '1' when overflowed and signed-mode else
--      '0';
-- S is equal to MSB of result;
-- Z is '1' when result = 0 else
--      '0';

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;
  use IEEE.std_logic_arith.all;

entity $instance_name is
  port (a, b 	: in std_logic_vector($bit_width-1 downto 0);
        cin     : in std_logic;
        mode 	: in std_logic_vector(4 downto 0);
        result 	: out std_logic_vector($bit_width-1 downto 0);
        flag 	: out std_logic_vector(3 downto 0) );
end $instance_name;

architecture synthesis of $instance_name is

  component ${instance_name}_add
    port (a, b 	 : in std_logic_vector($bit_width-1 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($bit_width-1 downto 0);
          cout 	 : out std_logic);
  end component;

  signal ain, bin             : std_logic_vector($bit_width-1 downto 0);
  signal sum                  : std_logic_vector($bit_width-1 downto 0);
  signal unsigned_max         : std_logic_vector($bit_width-1 downto 0);
  signal unsigned_min         : std_logic_vector($bit_width-1 downto 0);
  signal signed_max           : std_logic_vector($bit_width-1 downto 0);
  signal signed_min           : std_logic_vector($bit_width-1 downto 0);
  signal clipped_signed_sum   : std_logic_vector($bit_width-1 downto 0);
  signal clipped_unsigned_sum : std_logic_vector($bit_width-1 downto 0);
  signal clipped_sum          : std_logic_vector($bit_width-1 downto 0);
  signal tmp_cout             : std_logic;
  signal tmp_out              : std_logic_vector($bit_width-1 downto 0);
  signal pre_result           : std_logic_vector($bit_width-1 downto 0);
  signal V, C                 : std_logic;
  signal pre_pre_v            : std_logic;
  signal pre_v                : std_logic;
  signal unsigned_clipped     : std_logic;
  signal S, Z                 : std_logic;

  signal signed_max_value : std_logic_vector($bit_width-1 downto 0);
  signal signed_min_value : std_logic_vector($bit_width-1 downto 0);

begin

  --  input value of adder
  ain <= a;
  bin <= $zero when mode(1 downto 0) = "00"
                    and mode(4) = '0'          else -- a
         b     when mode(1 downto 0) = "01"
                    and mode(4) = '0'          else -- a + b
         not b when mode(1 downto 0) = "10"
                    or mode(4) = '1'           else -- a - b
         $one  when mode(1 downto 0) = "11"
                    and mode(4) = '0'          else -- a - 1
         $x_str;

  unsigned_clipped <= tmp_cout xor mode(1);

  clipped_unsigned_sum <= sum when unsigned_clipped = '0' else
                          $one when mode(1) = '0' else -- (+)
                          $zero;                        -- (-)

  signed_max_value($bit_width-1) <= '0';
  signed_max_value($bit_width-2 downto 1) <= conv_std_logic_vector(0, $bit_width-2);
  signed_max_value(0) <= '1';
  signed_min_value($bit_width-1) <= '1';
  signed_min_value($bit_width-2 downto 0) <= conv_std_logic_vector(0, $bit_width-1);

  clipped_signed_sum <= sum when pre_pre_v = '0' else
                        signed_max  -- (+)
                           when tmp_cout = '0' and mode(1) = '0' else
                        signed_min; -- (-)

  clipped_sum <= sum when mode(2) = '0' else
                 clipped_unsigned_sum when mode(3) = '0' else
                 clipped_signed_sum;

  unsigned_max <= a when tmp_cout = '1' else
                  b;

  unsigned_min <= a when tmp_cout = '0' else
                  b;

  signed_max <= a when (a($bit_width-1) = '0' and b($bit_width-1) = '1') else
                b when (a($bit_width-1) = '1' and b($bit_width-1) = '0') else
                a when (a($bit_width-1) = '0' and tmp_cout = '1') else
                b;

  signed_min <= b when (a($bit_width-1) = '0' and b($bit_width-1) = '1') else
                a when (a($bit_width-1) = '1' and b($bit_width-1) = '0') else
                b when (a($bit_width-1) = '0' and tmp_cout = '1') else
                a;

  -- output
  tmp_out <= sum         when mode(2) = '0' else -- no clip
             clipped_sum when mode(2) = '1' else
             $x_str;

  S <= pre_result($bit_width-1);

  C <= unsigned_clipped when mode(4 downto 2)  = "001" else
       tmp_cout         when mode(4 downto 2) /= "100"
                         and mode(4 downto 2) /= "110" else
       '0';

  Z <= '1' when pre_result = conv_std_logic_vector(0, $bit_width) else
       '0';

  pre_pre_v <= '1' when ((ain($bit_width-1)='0' and bin($bit_width-1) = '0'
                          and sum($bit_width-1) = '1' )
                      or (ain($bit_width-1)='1' and bin($bit_width-1) = '1'
                                       and sum($bit_width-1) = '0' )) else
               '0';

  pre_v <= '1' when mode(2) = '0' and pre_pre_v = '1' else
           '0';

  V <= pre_v     when mode(4 downto 2) = "010" else
       pre_pre_v when mode(4 downto 2) = "011"
               or mode(4 downto 1) = "1011" else
       '0';

  flag <= C & Z & S & V;

  pre_result <= tmp_out      when mode(4) = '0' else
               a or b        when mode(3 downto 0) = "0000" else
               a xor b       when mode(3 downto 0) = "0001" else
               a and b       when mode(3 downto 0) = "0010" else
               not a         when mode(3 downto 0) = "0011" else
               unsigned_max  when mode(3 downto 0) = "0100" else
               unsigned_min  when mode(3 downto 0) = "0101" else
               signed_max    when mode(3 downto 0) = "0110" else
               signed_min    when mode(3 downto 0) = "0111" else
               not (a or b)  when mode(3 downto 0) = "1000" else
               not (a xor b) when mode(3 downto 0) = "1001" else
               not (a and b) when mode(3 downto 0) = "1010" else
               $x_str;

  result <= pre_result;

  -- port mapping add
  a0 : ${instance_name}_add
    port map (ain, bin, cin,
              sum, tmp_cout);

end synthesis;
FHM_DL_INSTANCE
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates alu entity information in synthesis level
# parameter : instance_name bit_width

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width\n";
    exit (100);
}


$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];

{
print <<FHM_DL_ENTINFO
entity $instance_name is
  port (a, b   : in std_logic_vector($bit_width-1 downto 0);
        cin    : in std_logic;
        result : out std_logic_vector($bit_width-1 downto 0);
        cout   : out std_logic);
end $instance_name;
FHM_DL_ENTINFO
}
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates alu synthesis script in synthesis level
# parameter : instance_name priority bit_width

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width algorithm\n";
    exit (100);
}


$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];


if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "Not supported priority\n";
  exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
        <library name="OSAKA">

          <est_type name="shape">
            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="rca">
                <max>
                  <data bit_width="4"> 0.165776090992175 </data>
                  <data bit_width="8"> 0.272560304925649 </data>
                  <data bit_width="16"> 0.517813417252147 </data>
                  <data bit_width="32"> 0.953272081167533 </data>
                  <data bit_width="256"> 7.58054943950991 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.094535593619695 </data>
                  <data bit_width="8"> 0.152732544125207 </data>
                  <data bit_width="16"> 0.265588983930237 </data>
                  <data bit_width="32"> 0.535712054463929 </data>
                  <data bit_width="256"> 5.10001821438091 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.094535593619695 </data>
                    <data bit_width="8"> 0.152732544125207 </data>
                    <data bit_width="16"> 0.265588983930237 </data>
                    <data bit_width="32"> 0.535712054463929 </data>
                    <data bit_width="256"> 5.10001821438091 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.165776090992175 </data>
                    <data bit_width="8"> 0.272560304925649 </data>
                    <data bit_width="16"> 0.517813417252147 </data>
                    <data bit_width="32"> 0.953272081167533 </data>
                    <data bit_width="256"> 7.58054943950991 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.114349096789855 </data>
                    <data bit_width="8"> 0.191118417632947 </data>
                    <data bit_width="16"> 0.360638738314198 </data>
                    <data bit_width="32"> 0.668820083633213 </data>
                    <data bit_width="256"> 6.02758338616934 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="cla">
                <max>
                  <data bit_width="4"> 0.168215591382495 </data>
                  <data bit_width="8"> 0.385634843443575 </data>
                  <data bit_width="16"> 0.522368828659013 </data>
                  <data bit_width="32"> 1.04257322832772 </data>
                  <data bit_width="256"> 6.24815735896118 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.0950548168827707 </data>
                  <data bit_width="8"> 0.154511022257764 </data>
                  <data bit_width="16"> 0.275114534424325 </data>
                  <data bit_width="32"> 0.560745695769311 </data>
                  <data bit_width="256"> 5.53798105019897 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.0950548168827707 </data>
                    <data bit_width="8"> 0.154511022257764 </data>
                    <data bit_width="16"> 0.275114534424325 </data>
                    <data bit_width="32"> 0.560745695769311 </data>
                    <data bit_width="256"> 5.53798105019897 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.168215591382495 </data>
                    <data bit_width="8"> 0.385634843443575 </data>
                    <data bit_width="16"> 0.522368828659013 </data>
                    <data bit_width="32"> 1.04257322832772 </data>
                    <data bit_width="256"> 5.85528158522305 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.115182554597209 </data>
                    <data bit_width="8"> 0.196941981064717 </data>
                    <data bit_width="16"> 0.379257941585271 </data>
                    <data bit_width="32"> 0.706795674111308 </data>
                    <data bit_width="256"> 6.24815735896118 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="aspect_ratio">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="height">
              <!-- Dummy yet -->
            </est_index>

            <est_index name="width">
              <!-- Dummy yet -->
            </est_index>
          </est_type>

          <est_type name="timing">
            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="rca">
                <max>
                  <data bit_width="4"> 9.53 </data>
                  <data bit_width="8"> 12.67 </data>
                  <data bit_width="16"> 19.51 </data>
                  <data bit_width="32"> 32.75 </data>
                  <data bit_width="256"> 239.94 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.24 </data>
                  <data bit_width="8"> 5.10 </data>
                  <data bit_width="16"> 6.64 </data>
                  <data bit_width="32"> 11.22 </data>
                  <data bit_width="256"> 51.04 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 8.12 </data>
                    <data bit_width="8"> 11.51 </data>
                    <data bit_width="16"> 18.09 </data>
                    <data bit_width="32"> 29.87 </data>
                    <data bit_width="256"> 210.91 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 4.24 </data>
                    <data bit_width="8"> 5.10 </data>
                    <data bit_width="16"> 6.64 </data>
                    <data bit_width="32"> 11.22 </data>
                    <data bit_width="256"> 51.04 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 9.53 </data>
                    <data bit_width="8"> 12.67 </data>
                    <data bit_width="16"> 19.51 </data>
                    <data bit_width="32"> 32.75 </data>
                    <data bit_width="256"> 239.94 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="cla">
                <max>
                  <data bit_width="4"> 9.13 </data>
                  <data bit_width="8"> 11.89 </data>
                  <data bit_width="16"> 16.58 </data>
                  <data bit_width="32"> 22.71 </data>
                  <data bit_width="256"> 45.17 </data>
                </max>
                <min>
                  <data bit_width="4"> 4.45 </data>
                  <data bit_width="8"> 4.61 </data>
                  <data bit_width="16"> 5.90 </data>
                  <data bit_width="32"> 6.27 </data>
                  <data bit_width="256"> 9.56 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 8.22 </data>
                    <data bit_width="8"> 9.74 </data>
                    <data bit_width="16"> 13.23 </data>
                    <data bit_width="32"> 17.38 </data>
                    <data bit_width="256"> 41.30 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 4.45 </data>
                    <data bit_width="8"> 4.61 </data>
                    <data bit_width="16"> 5.90 </data>
                    <data bit_width="32"> 6.27 </data>
                    <data bit_width="256"> 9.56 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 9.13 </data>
                    <data bit_width="8"> 11.89 </data>
                    <data bit_width="16"> 16.58 </data>
                    <data bit_width="32"> 22.71 </data>
                    <data bit_width="256"> 45.17 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="rca">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 4.60
                    path	 b	 result	 4.84
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 7.52
                    path	 b	 result	 8.12
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 10.95
                    path	 b	 result	 11.74
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 18.41
                    path	 b	 result	 19.17
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 4.60
                    path	 b	 result	 4.84
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 7.52
                    path	 b	 result	 8.12
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 10.95
                    path	 b	 result	 11.74
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 18.41
                    path	 b	 result	 19.17
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 4.48
                      path	 b	 result	 5.27
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 7.02
                      path	 b	 result	 8.05
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 11.16
                      path	 b	 result	 11.99
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 18.55
                      path	 b	 result	 19.54
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.34
                      path	 b	 result	 2.34
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 2.19
                      path	 b	 result	 2.31
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 2.67
                      path	 b	 result	 2.76
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 2.96
                      path	 b	 result	 3.01
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 4.60
                      path	 b	 result	 4.84
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 7.52
                      path	 b	 result	 8.12
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 10.95
                      path	 b	 result	 11.74
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 18.41
                      path	 b	 result	 19.17
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="cla">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 4.17
                    path	 b	 result	 4.71
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 6.68
                    path	 b	 result	 6.83
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 7.95
                    path	 b	 result	 8.80
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 9.92
                    path	 b	 result	 10.78
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 4.17
                    path	 b	 result	 4.71
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 6.68
                    path	 b	 result	 6.83
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 7.95
                    path	 b	 result	 8.80
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 9.92
                    path	 b	 result	 10.78
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 4.39
                      path	 b	 result	 5.22
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 6.31
                      path	 b	 result	 6.82
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 8.32
                      path	 b	 result	 8.80
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 10.07
                      path	 b	 result	 10.70
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.01
                      path	 b	 result	 2.30
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 2.44
                      path	 b	 result	 2.68
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 2.66
                      path	 b	 result	 2.92
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 2.98
                      path	 b	 result	 3.20
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 4.17
                      path	 b	 result	 4.71
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 6.68
                      path	 b	 result	 6.83
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 7.95
                      path	 b	 result	 8.80
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 9.92
                      path	 b	 result	 10.78
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>
          </est_type>

          <est_type name="power">
            <est_index name="static_power">
              <unit> mW </unit>
              <parameters name="rca">
                <max>
                  <data bit_width="4"> 72.5419 </data>
                  <data bit_width="8"> 115.3882 </data>
                  <data bit_width="16"> 214.0195 </data>
                  <data bit_width="32"> 366.1331 </data>
                  <data bit_width="256"> 2849.1 </data>
                </max>
                <min>
                  <data bit_width="4"> 32.0087 </data>
                  <data bit_width="8"> 48.1682 </data>
                  <data bit_width="16"> 90.3668 </data>
                  <data bit_width="32"> 168.9971 </data>
                  <data bit_width="256"> 1586.9 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 35.0581 </data>
                    <data bit_width="8"> 56.0406 </data>
                    <data bit_width="16"> 96.8180 </data>
                    <data bit_width="32"> 187.4783 </data>
                    <data bit_width="256"> 1645.6 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 72.5419 </data>
                    <data bit_width="8"> 115.3882 </data>
                    <data bit_width="16"> 214.0195 </data>
                    <data bit_width="32"> 366.1331 </data>
                    <data bit_width="256"> 2849.1 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 32.0087 </data>
                    <data bit_width="8"> 48.1682 </data>
                    <data bit_width="16"> 90.3668 </data>
                    <data bit_width="32"> 168.9971 </data>
                    <data bit_width="256"> 1586.9 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="cla">
                <max>
                  <data bit_width="4"> 74.1982 </data>
                  <data bit_width="8"> 159.0084 </data>
                  <data bit_width="16"> 211.2822 </data>
                  <data bit_width="32"> 411.9496 </data>
                  <data bit_width="256"> 2165 </data>
                </max>
                <min>
                  <data bit_width="4"> 32.5684 </data>
                  <data bit_width="8"> 50.4298 </data>
                  <data bit_width="16"> 98.3936 </data>
                  <data bit_width="32"> 185.1792 </data>
                  <data bit_width="256"> 1827.1 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 35.9893 </data>
                    <data bit_width="8"> 59.6906 </data>
                    <data bit_width="16"> 107.5416 </data>
                    <data bit_width="32"> 210.1078 </data>
                    <data bit_width="256"> 1916.3 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 74.1982 </data>
                    <data bit_width="8"> 159.0084 </data>
                    <data bit_width="16"> 211.2822 </data>
                    <data bit_width="32"> 411.9496 </data>
                    <data bit_width="256"> 2165 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 32.5684 </data>
                    <data bit_width="8"> 50.4298 </data>
                    <data bit_width="16"> 98.3936 </data>
                    <data bit_width="32"> 185.1792 </data>
                    <data bit_width="256"> 1827.1 </data>
                  </priority>
                </typ>
              </parameters>
            </est_index>
          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="rca">
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>

              <parameters name="cla">
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">
              <parameters name="rca">
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>

              <parameters name="cla">
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="rca">
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>

              <parameters name="cla">
                <function name="caddu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cadd">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csubu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="csub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="addu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="subu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="add">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="sub">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="and">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="or">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="xor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="nor">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmp">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpzu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cmpz">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="inc">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="incu">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="dec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
                <function name="cdec">
                  <priority name="area"><data bit_width="0">0</data></priority>
                  <priority name="delay"><data bit_width="0">0</data></priority>
                  <priority name="power"><data bit_width="0">0</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">
            <!-- Dummy yet -->
          </est_type>
        </library>
      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $bit[$i] * $bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@bit) * &sum(@bit);
	

# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}


$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@bit)) / $n;

$ret_data = $a * $ARGV[1] + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Regression Methods by logarithm expression
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;

	$log_bit[$i] = log($bit[$i]) / log(4);
	$i++;
    }
}
close(TMP);

$n = $i;

# numerator 1
$nume_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $nume_1 += $log_bit[$i] * $data[$i];
}
$nume_1 *= $n;

# numerator 2
$nume_2 = &sum(@log_bit) * &sum(@data);
    
# denominator 1
$deno_1 = 0.00;
for ($i = 0; $i < $n; $i++) {
    $deno_1 += $log_bit[$i] * $log_bit[$i];
}
$deno_1 *= $n;

# denominator 2
$deno_2 = &sum(@log_bit) * &sum(@log_bit);


# divide by zero
if ($deno_1 == $deno_2) {
    exit(100);
}
if ($n == 0) {
    exit(100);
}

	
$a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);
$b = (&sum(@data) - $a * &sum(@log_bit)) / $n;

$ret_data = $a * log($ARGV[1]) / log(4) + $b;


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $ret_data );

    $ret_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$ret_data += $data[$i];
    }

    return($ret_data);
}

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by linear expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\s*\/data\s*\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;



for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += $bit_width * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $bit[$i] * $bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@bit) * &sum(@bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }


    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@bit)) / $n;
    
    $ret_data = $a * $ARGV[1] + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay_fullpath for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

$Round = 1;

#--------------------------------------------------------------------------#
# Type: Regression Methods by logarithm expression for delay_fullpath
#--------------------------------------------------------------------------#
$n = 0;

while (<TMP>) {

    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>/ ) {

	$bit_width = $1;
	$bit[$n] = $bit_width;
	$log_bit[$n] = log($bit_width) / log(4);
	
	$n++;
	$_ = <TMP>;
	
	$i = 0;
	while (! /\<\/data\>/ ) {

	    # path 
	    if ( /path\s+(\w+)\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "path\t $1\t $2\t ";
		$delay{$bit_width}[$i] = $3; 
		$i++;
	    }

	    # inport
	    if ( /inport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "inport\t $1\t\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # outport
	     if ( /outport\s+(\w+)\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "outport\t $1\t\t ";
		$delay{$bit_width}[$i] = $2;
		$i++;
	    }

	    # internal
	    if ( /internal\s+(\d+\.?\d+)/ ) {
		$line{$bit_width}[$i]  = "internal\t\t\t ";
		$delay{$bit_width}[$i] = $1;
		$i++;
	    }

	    $_ = <TMP>;
	}
    }
}
close(TMP);

$line_num = $i;

for ($j = 0; $j < $line_num; $j++) {

    # numerator 1
    $nume_1 = 0.00;
    foreach $bit_width (@bit) {
	$nume_1 += log($bit_width) / log(4) * $delay{$bit_width}[$j];
    }
    $nume_1 *= $n;

    # numerator 2
    $nume_2 = &sum(@log_bit);

    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $nume_2 *= $tmp;
    
    # denominator 1
    $deno_1 = 0.00;
    for ($i = 0; $i < $n; $i++) {
	$deno_1 += $log_bit[$i] * $log_bit[$i];
    }
    $deno_1 *= $n;

    # denominator 2
    $deno_2 = &sum(@log_bit) * &sum(@log_bit);
    

    # divide by zero
    if ($deno_1 == $deno_2) {
	exit(100);
    }
    if ($n == 0) {
	exit(100);
    }

    # a
    $a = ($nume_1 - $nume_2) / ($deno_1 - $deno_2);

    # b
    $tmp = 0.00;
    foreach $bit_width (@bit) {
	$tmp += $delay{$bit_width}[$j];
    }
    $b = ($tmp - $a * &sum(@log_bit)) / $n;
    
    $ret_data = $a * log($ARGV[1]) / log(4) + $b;
    $ret_data = &data_round($ret_data, $Round);
    
    print "$line{$bit[0]}[$j] $ret_data\n";
}

exit(0);


sub sum
{
    my ( @data ) = @_;
    my ( $i );
    my ( $return_data );

    $return_data = 0.00;
    for ($i = 0; $i < @data; $i++) {
	$return_data += $data[$i];
    }

    return($return_data);
}


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}
          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="rca">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(rca) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="cla">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for alu(cla) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[3]")) {
    print STDOUT ("Data file '$ARGV[3]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="rca">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>

            <parameters name="cla">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="latency">
            <parameters name="rca">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>

            <parameters name="cla">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="rca">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>

            <parameters name="cla">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
                ]]>
              </script>
            </parameters>
          </est_index>
        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>
</FHM>
