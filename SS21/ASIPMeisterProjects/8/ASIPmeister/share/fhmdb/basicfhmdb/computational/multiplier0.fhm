<?xml version="1.0" encoding="UTF-8" ?>
<FHM>
  <model_name> multiplier </model_name>

  <model>
    <design_level> behavior </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Tak. Tokihisa ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                %
%                 Copyright 2002 PEAS Project                    %
%                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> unsigned </value>
        <value> abs </value>
        <value> two_complement </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates multiplier function definition in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = 2*$bit_width -1;


if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp mul(twoscomp a, towscomp b);
unsigned mul(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn mul(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned mul(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC

/** $bit_width-bit $data_type multiplier */
model ${data_type}_mul${bit_width}{
  port{
    clock clock;
    in  reset, start;
    in  a[$w:0], b[$w:0];
    in  mode;
    out result[$w:0];
    out fin;
  }
  default_control{
    reset = 0;
    start = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in start, reset;
    }
    protocol{
      [start == 0 && reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", "twoscomp", 1, 1);
    &print_func("unsigned multiplication", "mulu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type result = mul(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
	print <<FHM_DL_SUB_SIGNED
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid result;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_SIGNED
    }
    else{
	print <<FHM_DL_SUB_NOSIGNED
    control{
      out fin;
    }
    protocol{
      [true]{
	valid result;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_NOSIGNED
    }
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates multiplier function definition in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = 2*$bit_width -1;

print <<FHM_DL_FUNCTION;
/** no operation */
function nop{
  input{
  }
  output{
  }
  control{
    in bit start;
    in bit reset;
  }
  protocol{
    single_cycle_protocol{
      start = '0';
      reset = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }
  output{
  }
  control{
    in bit reset;
  }
  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}
FHM_DL_FUNCTION

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_FUNC1
/** signed multiplication */
function mul{
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
    in  bit mode;
  }
  protocol{
    single_cycle_protocol{
      mode = '1';
    }
  }
}

/** unsigned multiplication */
function mulu{
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
    in  bit mode;
  }
  protocol{
    single_cycle_protocol{
      mode = '0';
    }
  }
}
FHM_DL_FUNC1
}

elsif ("$data_type" eq "abs"){
    print <<FHM_DL_FUNC2
/** abs multiplication */
function  mula{
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
  }
  protocol{
  }
}
FHM_DL_FUNC2
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_FUNC3
/** unsigned multiplication */
function mulu{
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
  }
  protocol{
  }
}
FHM_DL_FUNC3
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates adder pultiplier infomation in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width-1;
$w2 = $bit_width * 2 - 1;

print <<FHM_DL_PORT;
clock	in	bit		clock
reset	in	bit		reset
a	in	bit_vector   $w   0	data
b	in	bit_vector   $w   0	data
mode	in	bit	       	mode
start	in	bit		ctrl
clear	in	bit		ctrl
result	out	bit_vector   $w2   0	data
fin	out	bit	       	ctrl
FHM_DL_PORT
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = ($bit_width + 1) * 2 - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n--              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

print <<FHM_DL_INSTANCE;
-- Module     : $bit_width-bit Multiplier
-- Feature    : 
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1999
--              Modefied by Tak. Tokihisa (c)2002
-- Version    : 1.1  :

-- Functionality : behavioral level
--  port
--   clock   : (ignore)
--   reset   : (ignore)
--   a       : multiplicand
--   b       : multiplier
--   mode    : $mode_comment
--   start   : (ignore)
--   clear   : (ignore)
--   result  : multiplied result
--   fin     : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_signed.all;

entity $instance_name is
  port (clock  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        mode   : in std_logic;
        start  : in std_logic;
	clear  : in std_logic;
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic);
end $instance_name;

architecture behavior of $instance_name is
begin
  process (a, b, mode)
    variable tmp_a, tmp_b : std_logic_vector($bit_width downto 0);
    variable tmp_result   : std_logic_vector($w3 downto 0);
  begin
FHM_DL_INSTANCE

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    tmp_a := (a($w) and mode) & a;
    tmp_b := (b($w) and mode) & b;
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
    if (a($w) = '1') then
      tmp_a := '0' & not a + 1;
    else
      tmp_a := '0' & a;
    end if;
    if (b($w) = '1') then
      tmp_b := '0' & not b + 1;
    else
      tmp_b := '0' & b;
    end if;
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
    tmp_a := '0' & a;
    tmp_b := '0' & b;
FHM_DL_INSTANCE4
}
{
	print <<FHM_DL_INSTANCE5

    tmp_result := tmp_a * tmp_b;
    result <= tmp_result($w2 downto 0);
    fin <= '1';
  end process;
end behavior;
FHM_DL_INSTANCE5
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier entity information in behavior level
# parameter : instance_name bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = 2*$bit_width -1;
$data1 = "($w downto 0)";
$data2 = "($w2 downto 0)";


print <<FHM_DL_ENTITY;
entity $instance_name is
  port (clock  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector$data1;
        mode   : in std_logic;
        start  : in std_logic;
        clear  : in std_logic;
        result : out std_logic_vector$data2;
        fin    : out std_logic);
end $instance_name;
FHM_DL_ENTITY
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for multiplier in behavior level
# parameter : instance_name priority bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$data_type     = $ARGV[3];

if ($priority eq "area"){
    $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
    $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
    $priority_const = "";
}
elsif ($priority eq "none"){
    $priority_const = "";
}
else{
    print "priority $priority is not supported.\n";
    exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}


print <<FHM_DL_SCRIPT;
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name

uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area

report_timing

quit
FHM_DL_SCRIPT
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
     
        <library name="OSAKA">

          <est_type name="shape">

            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="4"> 0.099159 </data>
                  <data bit_width="8"> 0.360277 </data>
                  <data bit_width="16"> 1.399553 </data>
                  <data bit_width="32"> 5.183344 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.011037 </data>
                  <data bit_width="8"> 0.067082 </data>
                  <data bit_width="16"> 0.129160 </data>
                  <data bit_width="32"> 0.251008 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="aspect_ratio">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="height">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="width">

              <!-- Dummy yet -->

            </est_index>

          </est_type>

          <est_type name="timing">

            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 5.44 </data>
                  <data bit_width="8"> 12.37 </data>
                  <data bit_width="16"> 32.02 </data>
                  <data bit_width="32"> 63.58 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.93 </data>
                  <data bit_width="8"> 0.64 </data>
                  <data bit_width="16"> 1.23 </data>
                  <data bit_width="32"> 1.49 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

            </est_index>

          </est_type>

          <est_type name="power">
            
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 505.2987 </data>
                  <data bit_width="8"> 2262.6 </data>
                  <data bit_width="16"> 11741.5 </data>
                  <data bit_width="32"> 66751.8 </data>
                </max>
                <min>
                  <data bit_width="4"> 20.4679 </data>
                  <data bit_width="8"> 408.0370 </data>
                  <data bit_width="16"> 665.7615 </data>
                  <data bit_width="32"> 909.7382 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <!-- Dummy yet -->

          </est_type>

          <est_type name="function_power">

            <!-- Dummy yet -->

          </est_type>

        </library>     

      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> rt </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Tak. Tokihisa ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[ (c)2001,PEAS3-Lite Project ]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates multiplier function definition in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = 2*$bit_width -1;

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp mul(twoscomp a, towscomp b);
unsigned mul(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn mul(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned mul(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC

/** $bit_width-bit $data_type multiplier */
model ${data_type}_mul${bit_width}{
  port{
    clock clock;
    in  reset, start;
    in  a[$w:0], b[$w:0];
    in  mode;
    out result[$w:0];
    out fin;
  }
  default_control{
    reset = 0;
    start = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in start, reset;
    }
    protocol{
      [start == 0 && reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", "twoscomp", 1, 1);
    &print_func("unsigned multiplication", "mulu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type result = mul(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
	print <<FHM_DL_SUB_SIGNED
    control{
      in mode;
      out fin;
    }
    protocol{
      [mode == $mode_val]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_SIGNED
    }
    else{
	print <<FHM_DL_SUB_NOSIGNED
    control{
      out fin;
    }
    protocol{
      [true]{
	valid q, r, flag;
	fin = 1;
      }
    }
  }

FHM_DL_SUB_NOSIGNED
    }
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates multiplier function definition in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = 2*$bit_width -1;

print <<FHM_DL_FUNCTION;
/** no operation */
function nop {
  input {
  }
  output {
  }
  control {
    in bit start;
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      start = '0';
      reset = '0';
    }
  }
}

/** reset */
function reset {
  input {
  }
  output {
  }
  control {
    in bit reset;
  }
  protocol {
    single_cycle_protocol {
      reset = '1';
  }
}
FHM_DL_FUNCTION

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_FUNC1
/** signed multiplication */
function mul {
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
    in  bit mode;
  }
  protocol{
    single_cycle_protocol{
      mode = '1';
    }
  }
}

/** unsigned multiplication */
function mulu {
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
    in  bit mode;
  }
  protocol{
    single_cycle_protocol{
      mode = '0';
    }
  }
}
FHM_DL_FUNC1
}

elsif ("$data_type" eq "abs"){
    print <<FHM_DL_FUNC2
/** abs multiplication */
function  mula {
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
  }
  protocol{
  }
}
FHM_DL_FUNC2
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_FUNC3
/** unsigned multiplication */
function mulu {
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }
  output{
    bit [$w2:0] result;
  }
  control{
  }
  protocol{
  }
}
FHM_DL_FUNC3
}
exit (0);
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates adder pultiplier infomation in behavior level
# parameter : bit_width data_type

if ($#ARGV != 1){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$data_type = $ARGV[1];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width-1;
$w2 = $bit_width * 2 - 1;

print <<FHM_DL_PORT;
clock	in	bit		clock
reset	in	bit		reset
a	in	bit_vector   $w   0	data
b	in	bit_vector   $w   0	data
mode	in	bit	       	mode
start	in	bit		ctrl
clear	in	bit		ctrl
result	out	bit_vector   $w2   0	data
fin	out	bit	       	ctrl
FHM_DL_PORT
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier instance in behavior level
# parameter : instance_name bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$b2 = 2 * $bit_width;
$w = $bit_width - 1;
$w2 = $b2 -1;
$w3 = ($bit_width + 1) * 2 - 1;

if ("$data_type" eq "two_complement"){
    $mode_comment = "\'1\' for signed multiplication\n--              '0' for unsigned multiplication";
}
else{
    $mode_comment = "(ignore)";
}

print <<FHM_DL_INSTANCE;
-- Module     : $bit_width-bit Multiplier
-- Feature    : 
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1999
--              Modefied by Tak. Tokihisa (c)2002
-- Version    : 1.1  :

-- Functionality : behavioral level
--  port
--   clock   : (ignore)
--   reset   : (ignore)
--   a       : multiplicand
--   b       : multiplier
--   mode    : $mode_comment
--   start   : (ignore)
--   clear   : (ignore)
--   result  : multiplied result
--   fin     : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_signed.all;

entity $instance_name is
  port (clock  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        mode   : in std_logic;
        start  : in std_logic;
	clear  : in std_logic;
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic);
end $instance_name;

architecture behavior of $instance_name is
begin
  process (a, b, mode)
    variable tmp_a, tmp_b : std_logic_vector($bit_width downto 0);
    variable tmp_result   : std_logic_vector($w3 downto 0);
  begin
FHM_DL_INSTANCE

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE2;
    tmp_a := (a($w) and mode) & a;
    tmp_b := (b($w) and mode) & b;
FHM_DL_INSTANCE2
}
elsif("$data_type" eq "abs"){
    print <<FHM_DL_INSTANCE3;
    if (a($w) = '1') then
      tmp_a := '0' & not a + 1;
    else
      tmp_a := '0' & a;
    end if;
    if (b($w) = '1') then
      tmp_b := '0' & not b + 1;
    else
      tmp_b := '0' & b;
    end if;
FHM_DL_INSTANCE3
}
elsif ("$data_type" eq"unsigned"){
    print <<FHM_DL_INSTANCE4;
    tmp_a := '0' & a;
    tmp_b := '0' & b;
FHM_DL_INSTANCE4
}
{
	print <<FHM_DL_INSTANCE5

    tmp_result := tmp_a * tmp_b;
    result <= tmp_result(63 downto 0);
    fin <= '1';
  end process;
end behavior;
FHM_DL_INSTANCE5
}
exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates multiplier entity information in behavior level
# parameter : instance_name bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$data_type     = $ARGV[2];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;
$w2 = 2*$bit_width -1;
$data1 = "($w downto 0)";
$data2 = "($w2 downto 0)";


print <<FHM_DL_ENTITY;
entity $instance_name is
  port (clock  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector$data1;
        mode   : in std_logic;
        start  : in std_logic;
        clear  : in std_logic;
        result : out std_logic_vector$data2;
        fin    : out std_logic);
end $instance_name;
FHM_DL_ENTITY
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for multiplier in behavior level
# parameter : instance_name priority bit_width data_type

if ($#ARGV != 2){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$data_type     = $ARGV[3];

if ($priority eq "area"){
    $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
    $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
    $priority_const = "";
}
elsif ($priority eq "none"){
    $priority_const = "";
}
else{
    print "priority $priority is not supported.\n";
    exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}


print <<FHM_DL_SCRIPT;
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name

uniquify

$priority_const

compile 

write -hierarchy -output $instance_name.db

report_area

report_timing

quit
FHM_DL_SCRIPT
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
     
        <library name="OSAKA">

          <est_type name="shape">

            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="">
                <max>
                  <data bit_width="4"> 0.099159 </data>
                  <data bit_width="8"> 0.360277 </data>
                  <data bit_width="16"> 1.399553 </data>
                  <data bit_width="32"> 5.183344 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.011037 </data>
                  <data bit_width="8"> 0.067082 </data>
                  <data bit_width="16"> 0.129160 </data>
                  <data bit_width="32"> 0.251008 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="aspect_ratio">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="height">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="width">

              <!-- Dummy yet -->

            </est_index>

          </est_type>

          <est_type name="timing">

            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 5.44 </data>
                  <data bit_width="8"> 12.37 </data>
                  <data bit_width="16"> 32.02 </data>
                  <data bit_width="32"> 63.58 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.93 </data>
                  <data bit_width="8"> 0.64 </data>
                  <data bit_width="16"> 1.23 </data>
                  <data bit_width="32"> 1.49 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

            </est_index>

          </est_type>

          <est_type name="power">
            
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="">
                <max>
                  <data bit_width="4"> 505.2987 </data>
                  <data bit_width="8"> 2262.6 </data>
                  <data bit_width="16"> 11741.5 </data>
                  <data bit_width="32"> 66751.8 </data>
                </max>
                <min>
                  <data bit_width="4"> 20.4679 </data>
                  <data bit_width="8"> 408.0370 </data>
                  <data bit_width="16"> 665.7615 </data>
                  <data bit_width="32"> 909.7382 </data>
                </min>
                <typ>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <!-- Dummy yet -->

          </est_type>

          <est_type name="function_power">

            <!-- Dummy yet -->

          </est_type>

        </library>     

      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>

  <model>
    <design_level> synthesis </design_level>
    <version> 1.0 </version>
    <author> <![CDATA[ Tak. Tokihisa ]]> </author>
    <affiliation> <![CDATA[ Osaka Univ. ]]> </affiliation>
    <model_info> <![CDATA[ (c)2001,PEAS3-Lite Project ]]> </model_info>

    <parameter>
      <parameter_value key="bit_width">
        <value> 4 </value>
        <value> 8 </value>
        <value> 12 </value>
        <value> 16 </value>
        <value> 20 </value>
        <value> 24 </value>
        <value> 28 </value>
        <value> 32 </value>
        <value> 36 </value>
        <value> 40 </value>
        <value> 44 </value>
        <value> 48 </value>
        <value> 52 </value>
        <value> 56 </value>
        <value> 60 </value>
        <value> 64 </value>
        <value> 128 </value>
      </parameter_value>
      <parameter_value key="algorithm">
        <value> seq </value>
        <value> array </value>
      </parameter_value>
      <parameter_value key="adder_algorithm">
        <value> rca </value>
        <value> cla </value>
      </parameter_value>
      <parameter_value key="data_type">
        <value> unsigned </value>
        <value> abs </value>
        <value> two_complement </value>
      </parameter_value>
    </parameter>

    <function_description>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates AUTOGEN description for multiplier in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

if ("$data_type" eq "two_complement"){
    print <<FHM_DL_TWOCOMP_BASIC_FUNC
twoscomp mul(twoscomp a, towscomp b);
unsigned mul(unsigned a, unsigned b);
FHM_DL_TWOCOMP_BASIC_FUNC
}
elsif ("$data_type" eq "abs"){
    print <<FHM_DL_ABS_BASIC_FUNC
signmagn mul(signmagn a, signmagn b);
FHM_DL_ABS_BASIC_FUNC
}
elsif ("$data_type" eq "unsigned"){
    print <<FHM_DL_UN_BASIC_FUNC
unsigned mul(unsigned a, unsigned b);
FHM_DL_UN_BASIC_FUNC
}
{
    print <<FHM_DL_FUNC

/** $bit_width-bit $data_type multiplier */
model ${data_type}_mul${bit_width}{
  port{
    clock clock;
    in  reset, start;
    in  a[$w:0], b[$w:0];
    in  mode;
    out result[$w:0];
    out fin;
  }
  default_control{
    reset = 0;
    start = 0;
  }

  /** no operation */
  function nop : idle{
    control{
      in start, reset;
    }
    protocol{
      [start == 0 && reset == 0]{
      }
    }
  }

  /** reset */
  function reset : reset{
    control{
      in reset;
    }
    protocol{
      [reset == 1]{
      }
    }
  }

FHM_DL_FUNC
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
elsif ("$algorithm" eq "array"){
    $multi = 0;
}

$w = $bit_width - 1;

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", "twoscomp", 1, 1);
    &print_func("unsigned multiplication", "mulu", "unsigned", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", "signmagn", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", "unsigned", 0);
}
print "}\n";
exit (0);

# ---------------------------------

sub print_func{
    $comment   = $_[0];
    $func_name = $_[1];
    $d_type    = $_[2];
    $mode      = $_[3];
    $mode_val  = $_[4];

    {
	print <<FHM_DL_SUB_FUNC1
  /** $comment */
  function ${func_name}{
    input{
      $d_type a, b;
    }
    output{
      $d_type result = mul(a, b);
    }
FHM_DL_SUB_FUNC1
    }
    if ($mode == 1){
        {
	print <<FHM_DL_SUB_SIGNED_1
    control{
      in mode;
      out fin;
    }
    protocol{
FHM_DL_SUB_SIGNED_1
        }
	if ($multi == 1){
	print <<FHM_DL_SUB_SIGNED_2
      repeat [start == 1 && mode == $mode_val] until (fin == 1 || reset == 1);
      if (fin == 1){
        valid result;
      }
    }
  }

FHM_DL_SUB_SIGNED_2
        }
	else{
	print <<FHM_DL_SUB_SIGNED_3
      [mode == $mode_val]{
	valid result;
      }
    }
  }

FHM_DL_SUB_SIGNED_3
        }
    }
    else{
    {
	print <<FHM_DL_SUB_NOSIGNED_1
    control{
      out fin;
    }
    protocol{
FHM_DL_SUB_NOSIGNED_1
    }
	if ($multi == 1){
	print <<FHM_DL_SUB_NOSIGNED_2
      [true]{
	valid result;
      }
    }
  }

FHM_DL_SUB_NOSIGNED_2
        }
        else{
	print <<FHM_DL_SUB_NOSIGNED_3
      repeat [start == 1] until (fin == 1 || reset == 1);
      if (fin == 1){
        valid result;
      }
    }
  }

FHM_DL_SUB_NOSIGNED_3
        }
    }
}
exit (0);
        ]]>
      </script>
    </function_description>

    <function_conv>
      <script>
        <![CDATA[
#!/usr/bin/perl
# This script generates AUTOGEN description for multiplier in synthesis level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_NOP_RESET
/** no operation */
function nop{
  input{
  }

  output{
  }

  control{
    in bit start;
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      start = '0';
      reset = '0';
    }
  }
}

/** reset */
function reset{
  input{
  }

  output{
  }

  control{
    in bit reset;
  }

  protocol{
    single_cycle_protocol{
      reset = '1';
    }
  }
}

FHM_DL_NOP_RESET
}

if ("$algorithm" eq "seq"){
    $multi = 1;
}
elsif ("$algorithm" eq "array"){
    $multi = 0;
}

$w = $bit_width - 1;
$w2 = $bit_width * 2 - 1;

if ("$data_type" eq "two_complement"){
    &print_func("signed multiplication", "mul", 1, 1);
    &print_func("unsigned multiplication", "mulu", 1, 0);
}
elsif ("$data_type" eq "abs"){
    &print_func("abs multiplication", "mula", 0);
}
elsif ("$data_type" eq "unsigned"){
    &print_func("unsigned multiplication", "mulu", 0);
}
exit (0);

# ---------------------------------

sub print_func{
  $comment   = $_[0];
  $func_name = $_[1];
  $mode      = $_[2];
  $mode_val  = $_[3];

  {
    print <<FHM_DL_FUNC1
/** $comment */
function ${func_name}{
  input{
    bit [$w:0] a;
    bit [$w:0] b;
  }

  output{
    bit [$w2:0] result;
  }

  control{
FHM_DL_FUNC1
  }

  if ($mode == 1){
    print "    in  bit mode;\n";
  }

  if ($multi == 1){
  print <<FHM_DL_MULTI1
    in  bit start;
    in  bit clear;
    out bit fin;
FHM_DL_MULTI1
}

{
  print <<FHM_DL_FUNC2
  }

  protocol{
FHM_DL_FUNC2
  }

  if ($multi == 1){
    {
      print <<FHM_DL_MULTI2
    multi_cycle_protocol{
      start_signal  start = '1';
      fin_signal    fin = '1';
      cancel_signal clear = '1';
FHM_DL_MULTI2
    }
    if ($mode == 1){
      print "\n";
    }
  }
  elsif ($mode == 1){
    print "    single_cycle_protocol{\n";
  }

  if ($mode == 1){
    print "      mode = '$mode_val';\n";
  }

  if ($mode == 1 || $multi == 1){
      print "    }\n";
  }
  print <<FHM_DL_FUNC3
  }
}

FHM_DL_FUNC3
}
        ]]>
      </script>
    </function_conv>

    <function_port>
      <script>
        <![CDATA[
#!/usr/bin/perl
# this script generates adder pultiplier infomation in behavior level
# parameter : bit_width algorithm adder_algorithm data_type

if ($#ARGV != 3){
    print "number of parameters is wrong.\n";
    print "usage : this_script bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$bit_width = $ARGV[0];
$algorithm = $ARGV[1];
$add_algo  = $ARGV[2];
$data_type = $ARGV[3];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width-1;
$w2 = $bit_width * 2 - 1;

print <<FHM_DL_PORT;
clock	in	bit		clock
reset	in	bit		reset
a	in	bit_vector   $w   0	data
b	in	bit_vector   $w   0	data
mode	in	bit	       	mode
start	in	bit		ctrl
clear	in	bit		ctrl
result	out	bit_vector   $w2   0	data
fin	out	bit	       	ctrl
FHM_DL_PORT
exit (0);
        ]]>
      </script>
    </function_port>

    <design>
      <design_lang> vhdl </design_lang>

      <instance>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates instance for multiplier in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}


$w = $bit_width - 1;
$w2 = $bit_width * 2 - 1;
$w3 = $bit_width - 2;
$w4 = $bit_width * 2 - 2;
$double_width = $bit_width * 2;
$instance_name_add = $instance_name."_add$bit_width";
$instance_name_add2 = $instance_name."_add$double_width";

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}


if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$zeros = 0 x $bit_width;
$zeros = "\"" . $zeros . "\"";

$zeros1 = 0 x $w;
$zeros1 = "\"" . $zeros1 . "\"";

$zeros2 = 0 x $double_width;
$zeros2 = "\"" . $zeros2 . "\"";

# 1 bit register generation for tconv_result
if ("$algorithm" eq "seq" && "$data_type" eq "two_complement"){
    print <<FHM_DL_INSTANCE_REG;
-- Module     : 1-bit Edge Trigger Register
-- Feature    : positive
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   clock    : clock
--   reset    : reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;


entity ${instance_name}_reg1 is
  port (clock    : in std_logic;
        reset    : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic;
        data_out : out std_logic);
end ${instance_name}_reg1;

architecture synthesis of ${instance_name}_reg1 is
begin

  process (clock, reset, enb)
  begin
    if (reset = '1') then
      data_out <= '0';
    elsif (clock'event and clock = '1') then
      if (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

FHM_DL_INSTANCE_REG
}

# adder generation
if ("$add_algo" eq "rca"){

    print <<FHM_DL_RCA;
-- Module     : 1-bit full adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : carry of a + b + c

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_fa is
    port (a:    in  std_logic;
          b:    in  std_logic;
          cin:  in  std_logic;
          s:    out std_logic;
          cout: out std_logic );
end ${instance_name}_fa;

architecture synthesis of ${instance_name}_fa is
begin

   s <= (not a and b and not cin) or
	(a and not b and not cin) or
        (not a and not b and cin) or 
	(a and b and cin);

   cout <= (a and b and not cin) or 
           (not a and b and cin) or 
           (a and not b and cin) or 
           (a and b and cin);

end synthesis;

--%%

FHM_DL_RCA
    if ("$algorithm" eq "array" || "$data_type" ne "unsigned"){
        print <<FHM_DL_RCA;
-- Module     : ${bit_width}-bit ripple carry adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add data
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^${bit_width}-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add is
    port (a, b   : in  std_logic_vector($w downto 0);
          cin    : in  std_logic;
          result : out std_logic_vector($w downto 0);
          cout   : out std_logic);
end $instance_name_add;

architecture synthesis of $instance_name_add is

   component ${instance_name}_fa
      port (a:    in  std_logic;
            b:    in  std_logic;
            cin:  in  std_logic;
            s:    out std_logic;
            cout: out std_logic);
   end component;

   signal  ctmp :  std_logic_vector($bit_width downto 0);

begin

   ctmp(0) <= cin;

   full_adder: for i in $w downto 0 generate
   fan: ${instance_name}_fa 
      port map (a    => a(i),
                b    => b(i),
                cin  => ctmp(i),
                s    => result(i),
                cout => ctmp(i+1));
   end generate full_adder;

   cout <= ctmp($bit_width);

end synthesis;

--%%

FHM_DL_RCA
    }
    if ("$algorithm" eq "seq" || "$data_type" eq "two_complement"){
        print <<FHM_DL_RCA;
-- Module     : ${double_width}-bit ripple carry adder
-- References :
-- Author     : Designed by T.Morifuji (c)1996.
-- Version    : 1.0
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add data
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^${double_width}-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add2 is
    port (a, b   : in  std_logic_vector($w2 downto 0);
          cin    : in  std_logic;
          result : out std_logic_vector($w2 downto 0);
          cout   : out std_logic);
end $instance_name_add2;

architecture synthesis of $instance_name_add2 is

   component ${instance_name}_fa
      port (a:    in  std_logic;
            b:    in  std_logic;
            cin:  in  std_logic;
            s:    out std_logic;
            cout: out std_logic);
   end component;

   signal  ctmp :  std_logic_vector($double_width downto 0);

begin

   ctmp(0) <= cin;

   full_adder: for i in $w2 downto 0 generate
   fan: ${instance_name}_fa 
      port map (a    => a(i),
                b    => b(i),
                cin  => ctmp(i),
                s    => result(i),
                cout => ctmp(i+1));
   end generate full_adder;

   cout <= ctmp($double_width);

end synthesis;

--%%

FHM_DL_RCA
    }
}
elsif ("$add_algo" eq "cla"){
    $rem64   = $bit_width % 64;
    $count64 = ($bit_width - $rem64) / 64;
    $rem16   = $rem64 % 16;
    $count16 = ($rem64 - $rem16) / 16;
    $count1  = $rem16 % 4;
    $count4  = ($rem16 - $count1) / 4;

    $req64 = $count64;
    $req16 = $req64 + $count16;
    $req4  = $req16 + $count4;

    $rem_b2_64   = $double_width % 64;
    $count_b2_64 = ($double_width - $rem_b2_64) / 64;
    $rem_b2_16   = $rem_b2_64 % 16;
    $count_b2_16 = ($rem_b2_64 - $rem_b2_16) / 16;
    $count_b2_1  = $rem_b2_16 % 4;
    $count_b2_4  = ($rem_b2_16 - $count_b2_1) / 4;

    $req_b2_64 = $count_b2_64;
    $req_b2_16 = $req_b2_64 + $count_b2_16;
    $req_b2_4  = $req_b2_16 + $count_b2_4;

    if ($req4 != 0 || $req_b2_4 != 0){
	print <<FHM_DL_CLA4;
-- Module     : Basic 4bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^4-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_cla4 is
  port (a, b       : in  std_logic_vector(3 downto 0);
        cin        : in  std_logic;
        result     : out std_logic_vector(3 downto 0);
        pout, gout : out std_logic);
end ${instance_name}_cla4;

architecture synthesis of ${instance_name}_cla4 is

  signal p, g  : std_logic_vector(3 downto 0);
  signal carry : std_logic_vector(2 downto 0);

begin  --  synthesis

  --  make carry generate
  g(0) <= a(0) and b(0);
  g(1) <= a(1) and b(1);
  g(2) <= a(2) and b(2);
  g(3) <= a(3) and b(3);

  --  make carry propagate
  p(0) <= a(0) xor b(0);
  p(1) <= a(1) xor b(1);
  p(2) <= a(2) xor b(2);
  p(3) <= a(3) xor b(3);
  
  --   make internal carry and external carry
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout  <= p(3) and p(2) and p(1) and p(0);
  gout  <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
            or (p(3) and p(2) and p(1) and g(0));

  --  make sum.
  result(0) <= p(0) xor cin;
  result(1) <= p(1) xor carry(0);
  result(2) <= p(2) xor carry(1);
  result(3) <= p(3) xor carry(2);

end synthesis;

--%%

FHM_DL_CLA4
    }
    if ($req16 != 0 || $req_b2_16 != 0){
	print <<FHM_DL_CLA16;
-- Module     : Basic 16bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^16-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_cla16 is
  port (a, b       : in std_logic_vector(15 downto 0);
        cin        : in std_logic;
        result     : out std_logic_vector(15 downto 0);
        pout, gout : out std_logic);
end ${instance_name}_cla16;

architecture synthesis of ${instance_name}_cla16 is

  component ${instance_name}_cla4
    port (a, b       : in  std_logic_vector(3 downto 0);
          cin        : in  std_logic;
          result     : out std_logic_vector(3 downto 0);
          pout, gout : out std_logic);
  end component;

  signal p, g  : std_logic_vector(3 downto 0);
  signal carry : std_logic_vector(2 downto 0);

begin  --  synthesis

  -- make internal carry and carry propagate/generate
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout <= p(3) and p(2) and p(1) and p(0);
  gout <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
          or (p(3) and p(2) and p(1) and g(0));
  
  -- work adder
  u0 : ${instance_name}_cla4
    port map (
      a      => a(3 downto 0),
      b      => b(3 downto 0),
      cin    => cin,
      result => result(3 downto 0),
      pout   => p(0),
      gout   => g(0));
  
  u1 : ${instance_name}_cla4
    port map (
      a      => a(7 downto 4),
      b      => b(7 downto 4),
      cin    => carry(0),
      result => result(7 downto 4),
      pout   => p(1),
      gout   => g(1));

  u2 : ${instance_name}_cla4
    port map (
      a      => a(11 downto 8),
      b      => b(11 downto 8),
      cin    => carry(1),
      result => result(11 downto 8),
      pout   => p(2),
      gout   => g(2));

  u3 : ${instance_name}_cla4
    port map (
      a      => a(15 downto 12),
      b      => b(15 downto 12),
      cin    => carry(2),
      result => result(15 downto 12),
      pout   => p(3),
      gout   => g(3));

end synthesis;

--%%

FHM_DL_CLA16
    }
    if ($req64 != 0 || $req_b2_64 != 0){
	print <<FHM_DL_CLA64;
-- Module     : Basic 64bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^64-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_cla64 is
  port (a, b       : in std_logic_vector(63 downto 0);
        cin        : in std_logic;
        result     : out std_logic_vector(63 downto 0);
        pout, gout : out std_logic);
end ${instance_name}_cla64;

architecture synthesis of ${instance_name}_cla64 is

  component ${instance_name}_cla16
    port (a, b       : in std_logic_vector(15 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(15 downto 0);
          pout, gout : out std_logic);
  end component;

  signal        p, g             : std_logic_vector(3 downto 0);
  signal        carry            : std_logic_vector(2 downto 0);

begin  --  synthesis 

  -- make internal carry and carry propagate/generate
  carry(0) <= g(0) or (p(0) and cin);
  carry(1) <= g(1) or (p(1) and g(0)) or (p(1) and p(0) and cin);
  carry(2) <= g(2) or (p(2) and g(1)) or (p(2) and p(1) and g(0))
            or (p(2) and p(1) and p(0) and cin);
  pout <= p(3) and p(2) and p(1) and p(0);
  gout <= g(3) or (p(3) and g(2)) or (p(3) and p(2) and g(1))
          or (p(3) and p(2) and p(1) and g(0));
  
  -- work adder
  u0 : ${instance_name}_cla16
    port map (
      a      => a(15 downto 0),
      b      => b(15 downto 0),
      cin    => cin,
      result => result(15 downto 0),
      pout   => p(0),
      gout   => g(0));

  u1 : ${instance_name}_cla16
    port map (
      a      => a(31 downto 16),
      b      => b(31 downto 16),
      cin    => carry(0),
      result => result(31 downto 16),
      pout   => p(1),
      gout   => g(1));

  u2 : ${instance_name}_cla16
    port map (
      a      => a(47 downto 32),
      b      => b(47 downto 32),
      cin    => carry(1),
      result => result(47 downto 32),
      pout   => p(2),
      gout   => g(2));

  u3 : ${instance_name}_cla16
    port map (
      a      => a(63 downto 48),
      b      => b(63 downto 48),
      cin    => carry(2),
      result => result(63 downto 48),
      pout   => p(3),
      gout   => g(3));

end synthesis;

--%%

FHM_DL_CLA64
    }
    if ("$algorithm" eq "array" || "$data_type" ne "unsigned"){
            print <<FHM_DL_CLA_BEGIN;
-- Module     : $bit_width-bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$bit_width-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add is
  port (a, b   : in  std_logic_vector($w downto 0);
        cin    : in  std_logic;
        result : out std_logic_vector($w downto 0);
        cout   : out std_logic);
end $instance_name_add;

architecture synthesis of $instance_name_add is

FHM_DL_CLA_BEGIN

    if ($count64 != 0){
        print <<FHM_DL_CLA_COMP64
  component ${instance_name}_cla64
    port (a, b       : in std_logic_vector(63 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(63 downto 0);
          pout, gout : out std_logic);
  end component;

FHM_DL_CLA_COMP64
    }
    if ($count16 != 0){
        print <<FHM_DL_CLA_COMP16
  component ${instance_name}_cla16
    port (a, b       : in std_logic_vector(15 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(15 downto 0);
          pout, gout : out std_logic);
  end component;

FHM_DL_CLA_COMP16
    }
    if ($count4 != 0){
        print <<FHM_DL_CLA_COMP4
  component ${instance_name}_cla4
    port (a, b       : in std_logic_vector(3 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(3 downto 0);
          pout, gout : out std_logic);
  end component;

FHM_DL_CLA_COMP4
    }
    if ($req4 >= 1){
        $tmp = $req4 - 1;
        print "  signal p, g      : std_logic_vector($tmp downto 0);\n";
        print "  signal carry     : std_logic_vector($tmp downto 0);\n";
    }
    if ($count1 != 0){
        $tmp = $count1 - 1;
        print "  signal gres,pres : std_logic_vector($tmp downto 0);\n";
    }
    if ($count1 > 1){
        $tmp = $count1 - 2;
        print "  signal carry_res : std_logic_vector($tmp downto 0);\n";
    }
 
    print "begin\n";
 
    for ($carry=0; $carry<$req4; $carry++){
        print "  carry($carry) <= g($carry) or\n";
        $tmp = $carry;

        for ($g=$carry; $g>=0; $g--,$tmp--){
            print "              (";
              
            for ($p=$carry; $p>=$tmp; $p--){
                print "p($p) and ";
            }
            if ($g == 0){
                print "cin);\n";
            }
            else{
                print "g($p)) or\n";
            }
        }
    }

    print "\n";

    $bit_tmp = 0;
    $p = 0;
    $g = 0;

    for ($loop=0,$bit_tmp_63=$bit_tmp+63; $loop<=$count64-1;
         $loop++,$bit_tmp+=64,$bit_tmp_63+=64,$p++,$g++){
        print "  u64_$loop : ${instance_name}_cla64\n";
        print "    port map (\n";
        print "      a      => a($bit_tmp_63 downto $bit_tmp),\n";
        print "      b      => b($bit_tmp_63 downto $bit_tmp),\n";

            if ($bit_tmp == 0){
                print "      cin    => cin,\n";
            }
            else{
                $tmp = $p - 1;
                print "      cin    => carry($tmp),\n";
            }
        
            print "      result => result($bit_tmp_63 downto $bit_tmp),\n";
            print "      pout   => p($p),\n";
            print "      gout   => g($g));\n";
        }

        for ($loop=0,$bit_tmp_15=$bit_tmp+15; $loop<=$count16-1;
             $loop++,$bit_tmp+=16,$bit_tmp_15+=16,$p++,$g++){
            print "  u16_$loop : ${instance_name}_cla16\n";
            print "    port map (\n";
            print "      a      => a($bit_tmp_15 downto $bit_tmp),\n";
            print "      b      => b($bit_tmp_15 downto $bit_tmp),\n";
            
            if ($bit_tmp == 0){
                print "      cin    => cin,\n";
            }
            else{
                $tmp = $p - 1;
                print "      cin    => carry($tmp),\n";
            }
            
            print "      result => result($bit_tmp_15 downto $bit_tmp),\n";
            print "      pout   => p($p),\n";
            print "      gout   => g($g));\n";
        }

        for ($loop=0,$bit_tmp_3=$bit_tmp+3; $loop<=$count4-1;
             $loop++,$bit_tmp+=4,$bit_tmp_3+=4,$p++,$g++){
            print "  u4_$loop : ${instance_name}_cla4\n";
            print "    port map (\n";
            print "      a      => a($bit_tmp_3 downto $bit_tmp),\n";
            print "      b      => b($bit_tmp_3 downto $bit_tmp),\n";
            
            if ($bit_tmp == 0){
                print "      cin    => cin,\n";
            }
            else{
                $tmp = $p - 1;
                print "      cin    => carry($tmp),\n";
            }
            
            print "      result => result($bit_tmp_3 downto $bit_tmp),\n";
            print "      pout   => p($p),\n";
            print "      gout   => g($g));\n";
        }

        for ($loop=0,$tmp=$bit_tmp; $loop<=$count1-1; $loop++,$tmp++){
            print "  gres($loop) <= a($tmp) and b($tmp);\n";
        }
        print "\n";
        for ($loop=0,$tmp=$bit_tmp; $loop<=$count1-1; $loop++,$tmp++){
            print "  pres($loop) <= a($tmp) xor b($tmp);\n";
        }
        if ($count1 == 0){
            $tmp = $req4 - 1;
            print "  cout <= carry($tmp);\n";
        }

        for ($carry=0; $carry<=$count1-1; $carry++){
            if ($carry == $count1 - 1){
                print "  cout <= gres($carry) or\n";
            }
            else{
                print "  carry_res($carry) <= gres($carry) or\n";
            }
            $tmp = $carry;
            
            for ($g=$carry; $g>=0; $g--,$tmp--){
                print "              (";
                
                for ($p=$carry; $p>=$tmp; $p--){
                    print "pres($p) and ";
                }
                
                if ($g == 0){
                    if ($req4 == 0){
                        print "cin);\n";
                    }
                    else{
                        $tmp2 = $req4 - 1;
                        print "carry($tmp2));\n";
                    }
                }
                else{
                    print "gres($p)) or\n";
                }
            }
            if ($carry == $count1-1){
                print "\n";
            }
        }

        for ($loop=0,$tmp=$bit_tmp; $loop<=$count1-1; $loop++,$tmp++){
            if ($req4 eq 0){
                if ($loop eq 0){
                    print "  result($tmp) <= pres($loop) xor cin;\n";
                }
                else{
                    $tmp2 = $loop - 1;
                    print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
                }            
            }
            else{
                if ($loop eq 0){
                    $tmp2 = $req4 - 1;
                    print "  result($tmp) <= pres($loop) xor carry($tmp2);\n";
                }
                else{
                    $tmp2 = $loop - 1;
                    print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
                }
            }
        }
        print "end synthesis;\n\n--%%\n\n";
    }
    if ("$algorithm" eq "seq" || "$data_type" eq "two_complement"){
        print <<FHM_DL_CLA_BEGIN;
-- Module     : $double_width-bit carry look ahead adder
-- References : John L. Hennessy, David A. Patterson,
--              "Computer Architecture : A Quantitative Approach,"
--              Second Edition, Morgan Kaufmann, 1996
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   a, b   : add datas
--   cin    : carry in
--   result : result of a + b + c
--   cout   : '1' when result > 2^$double_width-1 else '0'

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name_add2 is
  port (a, b   : in  std_logic_vector($w2 downto 0);
        cin    : in  std_logic;
        result : out std_logic_vector($w2 downto 0);
        cout   : out std_logic);
end $instance_name_add2;

architecture synthesis of $instance_name_add2 is

FHM_DL_CLA_BEGIN

    if ($count_b2_64 != 0){
        print <<FHM_DL_CLA_COMP64
  component ${instance_name}_cla64
    port (a, b       : in std_logic_vector(63 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(63 downto 0);
          pout, gout : out std_logic);
  end component;

FHM_DL_CLA_COMP64
    }
    if ($count_b2_16 != 0){
        print <<FHM_DL_CLA_COMP16
  component ${instance_name}_cla16
    port (a, b       : in std_logic_vector(15 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(15 downto 0);
          pout, gout : out std_logic);
  end component;

FHM_DL_CLA_COMP16
    }
    if ($count_b2_4 != 0){
        print <<FHM_DL_CLA_COMP4
  component ${instance_name}_cla4
    port (a, b       : in std_logic_vector(3 downto 0);
          cin        : in std_logic;
          result     : out std_logic_vector(3 downto 0);
          pout, gout : out std_logic);
  end component;

FHM_DL_CLA_COMP4
    }
    if ($req_b2_4 >= 1){
        $tmp = $req_b2_4 - 1;
        print "  signal p, g      : std_logic_vector($tmp downto 0);\n";
        print "  signal carry     : std_logic_vector($tmp downto 0);\n";
    }
    if ($count_b2_1 != 0){
        $tmp = $count_b2_1 - 1;
        print "  signal gres,pres : std_logic_vector($tmp downto 0);\n";
    }
    if ($count_b2_1 > 1){
        $tmp = $count_b2_1 - 2;
        print "  signal carry_res : std_logic_vector($tmp downto 0);\n";
    }
 
    print "begin\n";
 
    for ($carry=0; $carry<$req_b2_4; $carry++){
        print "  carry($carry) <= g($carry) or\n";
        $tmp = $carry;

        for ($g=$carry; $g>=0; $g--,$tmp--){
            print "              (";
              
            for ($p=$carry; $p>=$tmp; $p--){
                print "p($p) and ";
            }
            if ($g == 0){
                print "cin);\n";
            }
            else{
                print "g($p)) or\n";
            }
        }
    }

    print "\n";

    $bit_tmp = 0;
    $p = 0;
    $g = 0;

    for ($loop=0,$bit_tmp_63=$bit_tmp+63; $loop<=$count_b2_64-1;
         $loop++,$bit_tmp+=64,$bit_tmp_63+=64,$p++,$g++){
        print "  u64_$loop : ${instance_name}_cla64\n";
        print "    port map (\n";
        print "      a      => a($bit_tmp_63 downto $bit_tmp),\n";
        print "      b      => b($bit_tmp_63 downto $bit_tmp),\n";

            if ($bit_tmp == 0){
                print "      cin    => cin,\n";
            }
            else{
                $tmp = $p - 1;
                print "      cin    => carry($tmp),\n";
            }
        
            print "      result => result($bit_tmp_63 downto $bit_tmp),\n";
            print "      pout   => p($p),\n";
            print "      gout   => g($g));\n\n";
        }

        for ($loop=0,$bit_tmp_15=$bit_tmp+15; $loop<=$count_b2_16-1;
             $loop++,$bit_tmp+=16,$bit_tmp_15+=16,$p++,$g++){
            print "  u16_$loop : ${instance_name}_cla16\n";
            print "    port map (\n";
            print "      a      => a($bit_tmp_15 downto $bit_tmp),\n";
            print "      b      => b($bit_tmp_15 downto $bit_tmp),\n";
            
            if ($bit_tmp == 0){
                print "      cin    => cin,\n";
            }
            else{
                $tmp = $p - 1;
                print "      cin    => carry($tmp),\n";
            }
            
            print "      result => result($bit_tmp_15 downto $bit_tmp),\n";
            print "      pout   => p($p),\n";
            print "      gout   => g($g));\n";
        }

        for ($loop=0,$bit_tmp_3=$bit_tmp+3; $loop<=$count_b2_4-1;
             $loop++,$bit_tmp+=4,$bit_tmp_3+=4,$p++,$g++){
            print "  u4_$loop : ${instance_name}_cla4\n";
            print "    port map (\n";
            print "      a      => a($bit_tmp_3 downto $bit_tmp),\n";
            print "      b      => b($bit_tmp_3 downto $bit_tmp),\n";
            
            if ($bit_tmp == 0){
                print "      cin    => cin,\n";
            }
            else{
                $tmp = $p - 1;
                print "      cin    => carry($tmp),\n";
            }
            
            print "      result => result($bit_tmp_3 downto $bit_tmp),\n";
            print "      pout   => p($p),\n";
            print "      gout   => g($g));\n\n";
        }

        for ($loop=0,$tmp=$bit_tmp; $loop<=$count_b2_1-1; $loop++,$tmp++){
            print "  gres($loop) <= a($tmp) and b($tmp);\n";
        }
        print "\n";
        for ($loop=0,$tmp=$bit_tmp; $loop<=$count_b2_1-1; $loop++,$tmp++){
            print "  pres($loop) <= a($tmp) xor b($tmp);\n";
        }
        if ($count_b2_1 == 0){
            $tmp = $req_b2_4 - 1;
            print "  cout <= carry($tmp);\n";
        }

        for ($carry=0; $carry<=$count_b2_1-1; $carry++){
            if ($carry == $count_b2_1 - 1){
                print "  cout <= gres($carry) or\n";
            }
            else{
                print "  carry_res($carry) <= gres($carry) or\n";
            }
            $tmp = $carry;
            
            for ($g=$carry; $g>=0; $g--,$tmp--){
                print "              (";
                
                for ($p=$carry; $p>=$tmp; $p--){
                    print "pres($p) and ";
                }
                
                if ($g == 0){
                    if ($req_b2_4 == 0){
                        print "cin);\n";
                    }
                    else{
                        $tmp2 = $req_b2_4 - 1;
                        print "carry($tmp2));\n";
                    }
                }
                else{
                    print "gres($p)) or\n";
                }
            }
            if ($carry == $count_b2_1-1){
                print "\n";
            }
        }

        for ($loop=0,$tmp=$bit_tmp; $loop<=$count_b2_1-1; $loop++,$tmp++){
            if ($req_b2_4 eq 0){
                if ($loop eq 0){
                    print "  result($tmp) <= pres($loop) xor cin;\n";
                }
                else{
                    $tmp2 = $loop - 1;
                    print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
                }            
            }
            else{
                if ($loop eq 0){
                    $tmp2 = $req_b2_4 - 1;
                    print "  result($tmp) <= pres($loop) xor carry($tmp2);\n";
                }
                else{
                    $tmp2 = $loop - 1;
                    print "  result($tmp) <= pres($loop) xor carry_res($tmp2);\n";
                }
            }
        }
        print "end synthesis;\n\n--%%\n\n";
    }
}

# unsigned multiplier generation
if ("$algorithm" eq "seq") {
    {
    print <<FHM_DL_SMUL0;
-- Module     : ${bit_width}-bit Edge Trigger Register
-- Feature    : positive
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   clock    : clock
--   reset    : reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg$bit_width is
  port (clock    : in std_logic;
        reset      : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic_vector($w downto 0);
        data_out : out std_logic_vector($w downto 0) );
end ${instance_name}_reg$bit_width;

architecture synthesis of ${instance_name}_reg$bit_width is
begin

  process (clock, reset, enb)
  begin
    if (reset = '1') then
      data_out <= $zeros;
    elsif (clock'event and clock = '1') then
      if (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : ${double_width}-bit Edge Trigger Register
-- Feature    : positive
-- References : Started from scratch
-- Author     : Designed by T.Morifuji (c)1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality : synthesis level
--  port
--   clock    : clock
--   reset    : reset
--   enb      : '1' then register data
--   data_in  : data to register
--   data_out : registered data


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_reg$double_width is
  port (clock    : in std_logic;
        reset      : in std_logic;
        enb      : in std_logic;
        data_in  : in std_logic_vector($w2 downto 0);
        data_out : out std_logic_vector($w2 downto 0) );
end ${instance_name}_reg$double_width;

architecture synthesis of ${instance_name}_reg$double_width is
begin

  process (clock, reset, enb)
  begin
    if (reset = '1') then
      data_out <= $zeros2;
    elsif (clock'event and clock = '1') then
      if (enb = '1') then
        data_out <= data_in;
      end if;
    end if;
  end process;

end synthesis;

--%%

-- Module     : ${bit_width}-bit Unsigned Multiplier
-- Feature    : type : shift
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997,1999.
-- Version    : 1.1  :
-- VHDL       : 87

-- Functionality :
--  port
--   clock  : clock
--   a, b   : can represent from 0 to 2^$bit_width-1 in integer
--   mode   : start multiplication when '0' after 1-clock '1'
--   result : multiplied result
--   fin    : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_smul is
  port (clock  : in std_logic;
        reset  : in std_logic;
        clear  : in std_logic;
        start  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic );
end ${instance_name}_smul;

architecture synthesis of ${instance_name}_smul is

  -- adder
  component ${instance_name_add2}
    port (a, b   : in std_logic_vector($w2 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w2 downto 0);
          cout   : out std_logic );
  end component;

  -- register: positive edge trigger
  component ${instance_name}_reg$bit_width
    port (clock    : in std_logic;
          reset      : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic_vector($w downto 0);
          data_out : out std_logic_vector($w downto 0) );
  end component;

  component ${instance_name}_reg$double_width
    port (clock    : in std_logic;
          reset      : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic_vector($w2 downto 0);
          data_out : out std_logic_vector($w2 downto 0) );
  end component;

  --
  -- signals declaration
  --

  signal add_sel, ld_ab, sft_b : std_logic;
  signal reg${double_width}_enb, reg${double_width}_reset : std_logic;
  signal from_reg_${bit_width}_a : std_logic_vector($w downto 0);
  signal to_reg_${bit_width}_b, from_reg_${bit_width}_b : std_logic_vector($w downto 0);
  signal to_add_a, to_add_b, from_add, result_tmp : std_logic_vector($w2 downto 0);
  signal zero, one : std_logic;
FHM_DL_SMUL0
    }
    print "  type s_t is (st0, st1, ";
    $i = 2;

    while ($i <= $bit_width+1) {
        print "st$i, ";
        $j = $i % 7;
        if ($j == 0) {
            print  "\n";
            print  "                 ";
        }
        $i= $i + 1;
    }
    print"st$i);\n";
    {
    print <<FHM_DL_SMUL1
  signal current_state, next_state : s_t;
begin  --  synthesis
  zero <= '0';
  one <= '1';

  add_sel <= from_reg_${bit_width}_b($w);
  to_add_a($w2 downto $bit_width) <= $zeros;
  to_add_a($w downto 0) <= from_reg_${bit_width}_a when add_sel='1' else
                           $zeros;
  to_add_b <= result_tmp($w2-1 downto 0) & '0';
  result <= result_tmp;

  reg_${bit_width}_a: ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      reset    => zero,
      enb      => ld_ab,
      data_in  => a,
      data_out => from_reg_${bit_width}_a);

  to_reg_${bit_width}_b <= b when ld_ab='1' else
                           from_reg_${bit_width}_b($w-1 downto 0) & '0' when sft_b='1' else
                           from_reg_${bit_width}_b($w downto 0);
  
  reg_${bit_width}_b: ${instance_name}_reg$bit_width
    port map (
      clock    => clock,
      reset    => zero,
      enb      => one,
      data_in  => to_reg_${bit_width}_b,
      data_out => from_reg_${bit_width}_b);
  
  add0 : ${instance_name_add2}
    port map (
      a      => to_add_a,
      b      => to_add_b,
      cin    => zero,
      result => from_add,
      cout   => open);

  reg_$double_width: ${instance_name}_reg$double_width
    port map (
      clock    => clock,
      reset    => reg${double_width}_reset,
      enb      => reg${double_width}_enb,
      data_in  => from_add,
      data_out => result_tmp);
  
  process (current_state, start, clear)
  begin
    case current_state is
      when st0 =>
        ld_ab <= '0';
        sft_b <= '0';
        reg${double_width}_enb <= '0';
        reg${double_width}_reset <= '0';
        fin <= '1' and not start;
        if (start = '1' and clear = '0') then
          next_state <= st1;
        else
          next_state <= st0;
        end if;
      when st1 =>
        if clear = '1' then
          next_state <= st0;
        else
          next_state <= st2;
        end if;
        ld_ab <= '1';
        sft_b <= '0';
        reg${double_width}_enb <= '0';
        reg${double_width}_reset <= '1';
        fin <= '0';
FHM_DL_SMUL1
    }
    $i = 2;

    while ($i <= $bit_width+1) {
        $n_i = $i + 1;
        {
        print <<FHM_DL_SMUL_STATE
      when st$i =>
        if clear = '1' then
          next_state <= st0;
        else
          next_state <= st$n_i;
        end if;
        ld_ab <= '0';
        sft_b <= '1';
        reg${double_width}_enb <= '1';
        reg${double_width}_reset <= '0';
        fin <= '0';
FHM_DL_SMUL_STATE
        }
        $i = $n_i;
    }
    {
    print <<FHM_DL_SMUL2
      when st$i =>
        next_state <= st0;
        ld_ab <= '0';
        sft_b <= '0';
        reg${double_width}_enb <= '0';
        reg${double_width}_reset <= '0';
        fin <= '1';
    end case;
  end process;

  process (clock, reset)
  begin
    if (reset = '1') then
      current_state <= st0;
    elsif (clock'event and clock = '1') then
      current_state <= next_state;
    end if;
  end process;  
end synthesis;

--%%

FHM_DL_SMUL2
    }
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_AMUL;
-- Module     : ${bit_width}-bit Unsigned Multiplier
-- Feature    : type : array
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997.
-- Version    : 1.0  :
-- VHDL       : 87

-- Functionality :
--  port
--   W      : bit width. boundary of input
--   a, b   : can represent from 0 to 2^$bit_width-1 in integer
--   result : multiplied result

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_amul is
  port (a, b   : in std_logic_vector($w downto 0);
        result : out std_logic_vector($w2 downto 0));
end ${instance_name}_amul;

architecture synthesis of ${instance_name}_amul is

  -- component declaration
  -- adder
  component ${instance_name_add}
    port (a, b   : in std_logic_vector($w downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w downto 0);
          cout   : out std_logic);
  end component;

  --  type definition
  type vectors is array (Natural range <>) of std_logic_vector($w downto 0);

  --  signal declaration
  signal qout   : std_logic_vector($w downto 0);
  signal add_a	: vectors($w downto 0);
  signal add_b	: vectors($w downto 0);
  signal add_s	: vectors($w downto 0);
  signal s	: vectors($w downto 0);
  signal c	: std_logic_vector($w downto 0);
 
  signal zero	: std_logic;

begin

  zero <= '0';

  a_connect : for i in 0 to $w generate
    add_a0 : if (i = 0) generate
      input_0 : for j in $w downto 0 generate
        s(i)(j) <= a(j) and b(0);
      end generate input_0;
    c(0) <= zero;

    end generate add_a0;
    
    add_as : if (0 < i and i <= $w) generate
      input_0 : for j in $w downto 0 generate
        add_a(i)(j) <= a(j) and b(i);
        b_carry : if (j = $w) generate
	  add_b(i)(j) <= c(i-1);
	end generate b_carry;

  b_other : if (j /= $w) generate
	  add_b(i)(j) <= s(i-1)(j+1);
	end generate b_other;

      end generate input_0;

    end generate add_as;

  end generate a_connect;

  -- make result
  s_conv : for i in 1 to $w3 generate
    result(i) <= s(i)(0);
  end generate s_conv;

  s_conv2 : for i in $w to $w4 generate
    result(i) <= s($w)(i-$w);
  end generate s_conv2;

  result(0) <= a(0) and b(0);
  result($w2) <= c($w);

  -- port mapping : adder
  add_connect : for i in 1 to $w generate
   adds : ${instance_name_add}
      port map (add_a(i), add_b(i),
                zero, s(i), c(i) );
  end generate add_connect;

end synthesis;

--%%

FHM_DL_AMUL
}

if ("$data_type" eq "two_complement" || "$data_type" eq "abs") {
    print <<FHM_DL_TWO;
-- Module     : ${bit_width}-bit 2's complement converter
-- Feature    : ${bit_width}-bit
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.
-- Version : 1.0  :
-- VHDL    : 87

-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_tconv$bit_width is
    port (data_in  : in  std_logic_vector($w downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w downto 0));
end ${instance_name}_tconv$bit_width;

architecture synthesis of ${instance_name}_tconv$bit_width is

  component ${instance_name_add}
    port (a, b   : in std_logic_vector($w downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector($w downto 0);
  signal zero         : std_logic_vector($w downto 0);
  signal tmp_data_out : std_logic_vector($w downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= $zeros;

  two_conv : ${instance_name_add}
    port map (not_data_in, zero, conv,
              tmp_data_out, tmp_cout);

  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

FHM_DL_TWO
}
if ("$data_type" eq "two_complement") {
    print <<FHM_DL_TWO;
-- Module     : ${double_width}-bit 2's complement converter
-- Feature    : ${double_width}-bit
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996.

-- Version : 1.0  :
-- VHDL    : 87
-- Functionality :
--  port
--   data_in  : data for convert
--   conv     : '1' then convert data
--   data_out : converted data


library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity ${instance_name}_tconv$double_width is
    port (data_in  : in  std_logic_vector($w2 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w2 downto 0));
end ${instance_name}_tconv$double_width;

architecture synthesis of ${instance_name}_tconv$double_width is

  component ${instance_name_add2}
    port (a, b   : in std_logic_vector($w2 downto 0);
          cin    : in std_logic;
          result : out std_logic_vector($w2 downto 0);
          cout   : out std_logic);
  end component;

  signal not_data_in  : std_logic_vector($w2 downto 0);
  signal zero         : std_logic_vector($w2 downto 0);
  signal tmp_data_out : std_logic_vector($w2 downto 0);
  signal tmp_cout     : std_logic;

begin

  not_data_in <= not data_in;
  zero <= $zeros2;

  two_conv : ${instance_name_add2}
    port map (not_data_in, zero, conv,
              tmp_data_out, tmp_cout);

  data_out <= data_in when conv = '0' else
              tmp_data_out;

end synthesis;

--%%

FHM_DL_TWO
}

print <<FHM_DL_INSTANCE2;
-- Module     : ${bit_width}-bit Multiplier
-- Feature    : $algorithm $add_algo $data_type
-- References : Start from scratch
-- Author     : Designed by T.Morifuji (c)1996,1997,1999.
-- Version    : 1.1  :
-- VHDL       : 87
-- Functionality :
--  port
--   W       : bit width. boundary of input
--   clock   : clock
--   a, b    : can represent from 0 to 2^$bit_width-1 in integer
FHM_DL_INSTANCE2
if ($data_type eq "two_complement") {
    print "--   mode    : '0' when data type is unsigned\n";
    print "--             '1' when data type is two_complement\n";
}
else {
    print "--   mode    : (ignore)\n";
}
if ($algorithm eq "seq") {
  print "--   start   : '1' when operation starts\n";
}
else {
  print "--   start   : (ignore)\n";
}
print <<FHM_DL_INSTANCE3;
--   result  : multiplied result
--   fin     : '1' when operation is over

-- Comment :

library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.std_logic_unsigned.all;

entity $instance_name is
  port (clock  : in std_logic;
        reset  : in std_logic;
        a, b   : in std_logic_vector($w downto 0);
        mode   : in std_logic;
        start  : in std_logic;
        clear  : in std_logic;
        result : out std_logic_vector($w2 downto 0);
        fin    : out std_logic);
end $instance_name;

architecture synthesis of $instance_name is

FHM_DL_INSTANCE3
if ("$algorithm" eq "seq") {
  print <<FHM_DL_SEQ;
  component ${instance_name}_smul
    port (clock  : in std_logic;
          reset  : in std_logic;
          clear  : in std_logic;
          start  : in std_logic;
          a, b   : in std_logic_vector($w downto 0);
          result : out std_logic_vector($w2 downto 0);
          fin    : out std_logic );
  end component;
FHM_DL_SEQ
}
elsif ("$algorithm" eq "array") {
    print <<FHM_DL_SEQ2;
  component ${instance_name}_amul
    port (a, b   : in std_logic_vector($w downto 0);
          result : out std_logic_vector($w2 downto 0));
  end component;

FHM_DL_SEQ2
}


if ("$data_type" eq "unsigned") {
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ3;
signal smul_fin              : std_logic;

begin

  smul0 : ${instance_name}_smul
    port map (clock, reset, clear, start, a, b, result, smul_fin);

  fin <= smul_fin and (not start);
FHM_DL_SEQ3
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY;
begin

  fin <= '1';

  amul0 : ${instance_name}_amul
    port map (a, b, result);
FHM_DL_ARRAY
    }
    print "end synthesis;\n";
}

if ("$data_type" eq "two_complement") {
    print <<FHM_DL_TWO2;
  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w downto 0));
  end component;

  component ${instance_name}_tconv${double_width}
    port (data_in  : in std_logic_vector($w2 downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w2 downto 0));
  end component;

FHM_DL_TWO2
    if ("$algorithm" eq "seq") {
        print <<FHM_DL_SEQ4;
  component ${instance_name}_reg1
    port (clock    : in std_logic;
          reset      : in std_logic;
          enb      : in std_logic;
          data_in  : in std_logic;
          data_out : out std_logic );
  end component;
FHM_DL_SEQ4
    }
    print <<FHM_DL_TWO3;
  signal conved_a          : std_logic_vector($w downto 0);
  signal conved_b          : std_logic_vector($w downto 0);
  signal conved_result     : std_logic_vector($w2 downto 0);

  signal tmp_a             : std_logic_vector($w downto 0);
  signal tmp_b             : std_logic_vector($w downto 0);
  signal tmp_result        : std_logic_vector($w2 downto 0);

FHM_DL_TWO3
    if ("$algorithm" eq "seq") {
        print <<FHM_DL_SEQ5;
  signal in_result_tconv_conv  : std_logic;
  signal out_result_tconv_conv : std_logic;
  signal mode_tmp : std_logic;

  signal smul_fin              : std_logic;
  signal vss                   : std_logic := '0';

FHM_DL_SEQ5
    }
    print <<FHM_DL_TWO4;
  signal result_tconv_conv     : std_logic;

begin

  result_tconv_conv <= a($w) xor b($w);
FHM_DL_TWO4
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ6;
  in_result_tconv_conv <= result_tconv_conv;

  tconv_reg : ${instance_name}_reg1
    port map (
      clock    => clock,
      reset      => vss,
      enb      => start,
      data_in  => in_result_tconv_conv,
      data_out => out_result_tconv_conv);

  mode_reg : ${instance_name}_reg1
    port map (
      clock    => clock,
      reset    => reset,
      enb      => start,
      data_in  => mode,
      data_out => mode_tmp);
FHM_DL_SEQ6
    }
    print <<FHM_DL_TWO5;

  conv_a : ${instance_name}_tconv${bit_width}
    port map (a, a($w), conved_a);

  conv_b : ${instance_name}_tconv${bit_width}
    port map (b, b($w), conved_b);
FHM_DL_TWO5

    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ6;

  tmp_a <= a when mode_tmp = '0' else
           conved_a;

  tmp_b <= b when mode_tmp = '0' else
           conved_b;

  mulu : ${instance_name}_smul
    port map (clock, reset, clear, start, tmp_a, tmp_b, tmp_result, smul_fin);
FHM_DL_SEQ6
    }
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY2;
  fin <= '1';

  tmp_a <= a when mode = '0' else
           conved_a;

  tmp_b <= b when mode = '0' else
           conved_b;

  mulu : ${instance_name}_amul
    port map (tmp_a, tmp_b, tmp_result);
FHM_DL_ARRAY2
    }
    print "  conv_result : ${instance_name}_tconv${double_width}\n";

    if ("$algorithm" eq "seq") {
	print "    port map (tmp_result, out_result_tconv_conv, conved_result);\n\n";
	print "  result <= tmp_result when mode_tmp = '0' else\n";
	print "            conved_result;\n\n";
    }
    else {
        print "    port map (tmp_result, result_tconv_conv, conved_result);\n\n";
	print "  result <= tmp_result when mode = '0' else\n";
	print "            conved_result;\n\n";
    }

    if ("$algorithm" eq "seq") {
	print "    fin <= smul_fin and (not start);\n\n";
    }

    print "end synthesis;\n";
}

if ("$data_type" eq "abs") {
    print <<FHM_DL_ABS;

  component ${instance_name}_tconv$bit_width
    port (data_in  : in std_logic_vector($w downto 0);
          conv     : in std_logic;
          data_out : out std_logic_vector($w downto 0));
  end component;

FHM_DL_ABS

    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ7;
  signal smul_fin  : std_logic;
  signal vss       : std_logic := '0';

FHM_DL_SEQ7
    }
    print <<FHM_DL_ABS;
  signal conved_a          : std_logic_vector($w downto 0);
  signal conved_b          : std_logic_vector($w downto 0);
  signal to_result : std_logic_vector($w2 downto 0);

begin

  conv_a : ${instance_name}_tconv${bit_width}
    port map (a, a($w), conved_a);

  conv_b : ${instance_name}_tconv${bit_width}
    port map (b, b($w), conved_b);

  result($w2 downto 0) <= to_result($w2 downto 0);

FHM_DL_ABS
  
    if ("$algorithm" eq "seq") {
	print <<FHM_DL_SEQ9;

  mulu : ${instance_name}_smul
    port map (clock, reset, clear, start, conved_a, conved_b, to_result, smul_fin);

  fin <= smul_fin and (not start);
FHM_DL_SEQ9
    } 
    elsif ("$algorithm" eq "array") {
	print <<FHM_DL_ARRAY3;
  fin <= '1';

  mulu : ${instance_name}_amul
    port map (conved_a, conved_b, to_result);

FHM_DL_ARRAY3
    }
    print "end synthesis;\n";
}

exit (0);
          ]]>
        </script>
      </instance>

      <entity>
        <script>
          <![CDATA[
#!/usr/bin/perl
# this script generates entity for multiplier in synthesis level
# parameter : instance_name bit_width algorithm adder_algorithm data_type

if ($#ARGV != 4){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$bit_width     = $ARGV[1];
$algorithm     = $ARGV[2];
$add_algo      = $ARGV[3];
$data_type     = $ARGV[4];

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" ne "seq" && "$algorithm" ne "array"){
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

$w = $bit_width - 1;

{
print <<FHM_DL_ENTITY
entity $instance_name is
  port (clock    : in std_logic;
	reset    : in std_logic;
        a, b     : in std_logic_vector($w downto 0);
        mode     : in std_logic;
        start    : in std_logic;
        clear    : in std_logic;
        result   : out std_logic_vector($w downto 0);
        fin      : out std_logic );
end $instance_name;
FHM_DL_ENTITY
}
exit (0);
          ]]>
        </script>
      </entity>

      <testvector>
        <testvector_script>
          <![CDATA[ ]]>
        </testvector_script>
      </testvector>

      <synthesis>
        <parameter></parameter>
        <synthesis_script>
          <script>
            <![CDATA[
#!/usr/bin/perl
# this script generates synthesis script for multiplier in synthesis level
# parameter : instance_name priority bit_width algorithm adder_algorithm data_type

if ($#ARGV != 5){
    print "number of parameters is wrong.\n";
    print "usage : this_script instance_name priority bit_width algorithm adder_algorithm data_type\n";
    exit (100);
}

$instance_name = $ARGV[0];
$priority      = $ARGV[1];
$bit_width     = $ARGV[2];
$algorithm     = $ARGV[3];
$add_algo      = $ARGV[4];
$data_type     = $ARGV[5];

if ($priority eq "area"){
  $priority_const = "set_max_area 0";
}
elsif ($priority eq "performance"){
  $priority_const = "set_max_delay -from all_inputs() -to all_outputs() 0";
}
elsif ($priority eq "power"){
  $priority_const = "";
}
elsif ($priority eq "none"){
  $priority_const = "";
}
else{
  print "priority $priority is not supported.\n";
  exit (100);
}

@bit_widths = (4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 128);
if (! grep($_ eq $bit_width, @bit_widths)){
    print "bit_width $bit_width is not supported.\n";
    exit (100);
}

if ("$algorithm" eq "seq"){
    $create_clock = "create_clock -period 10 -waveform{0 5} clock";
}
elsif ("$algorithm" eq "array"){
    $create_clock = "";
}
else{
    print "algorithm $algorithm is not supported.\n";
    exit (100);
}

if ("$add_algo" ne "rca" && "$add_algo" ne "cla"){
    print "adder_algorithm $add_algo is not supported.\n";
    exit (100);
}

if ("$data_type" ne "two_complement" && "$data_type" ne "abs" && "$data_type" ne "unsigned"){
    print "data_type $data_type is not supported.\n";
    exit (100);
}

{
print <<FHM_DL_SCRIPT
hdlin_auto_save_templates = TRUE

analyze -f vhdl $instance_name.vhd

elaborate $instance_name
uniquify

$priority_const

$create_clock

compile 

write -hierarchy -output $instance_name.db

report_area
report_timing

quit
FHM_DL_SCRIPT
}
exit (0);
            ]]>
          </script>
        </synthesis_script>
      </synthesis>
    </design>

    <estimation>
      <estimation_data>
     
        <library name="OSAKA">
    
          <est_type name="shape">

            <est_index name="area">
              <unit> mm2 </unit>
              <translate>
                <translate_value key="gate"> 4201.68 </translate_value>
                <translate_value key="mm2">  1 </translate_value>
              </translate>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4"> 0.068745 </data>
                  <data bit_width="8"> 0.113125 </data>
                  <data bit_width="16"> 0.219021 </data>
                  <data bit_width="32"> 0.472089 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.041999 </data>
                  <data bit_width="8"> 0.068752 </data>
                  <data bit_width="16"> 0.132097 </data>
                  <data bit_width="32"> 0.253786 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.041999 </data>
                    <data bit_width="8"> 0.068752 </data>
                    <data bit_width="16"> 0.132097 </data>
                    <data bit_width="32"> 0.253786 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.068745 </data>
                    <data bit_width="8"> 0.113125 </data>
                    <data bit_width="16"> 0.219021 </data>
                    <data bit_width="32"> 0.472089 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.048109 </data>
                    <data bit_width="8"> 0.079549 </data>
                    <data bit_width="16"> 0.144874 </data>
                    <data bit_width="32"> 0.271024 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4"> 0.062475 </data>
                  <data bit_width="8"> 0.111057 </data>
                  <data bit_width="16"> 0.234107 </data>
                  <data bit_width="32"> 0.457655 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.038664 </data>
                  <data bit_width="8"> 0.067082 </data>
                  <data bit_width="16"> 0.129160 </data>
                  <data bit_width="32"> 0.251008 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.038664 </data>
                    <data bit_width="8"> 0.067082 </data>
                    <data bit_width="16"> 0.129160 </data>
                    <data bit_width="32"> 0.251008 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.062475 </data>
                    <data bit_width="8"> 0.111057 </data>
                    <data bit_width="16"> 0.234107 </data>
                    <data bit_width="32"> 0.457655 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.044533 </data>
                    <data bit_width="8"> 0.075423 </data>
                    <data bit_width="16"> 0.144315 </data>
                    <data bit_width="32"> 0.267066 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4"> 0.099159 </data>
                  <data bit_width="8"> 0.200534 </data>
                  <data bit_width="16"> 0.461015 </data>
                  <data bit_width="32"> 0.884365 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.056846 </data>
                  <data bit_width="8"> 0.108146 </data>
                  <data bit_width="16"> 0.220104 </data>
                  <data bit_width="32"> 0.442109 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.056846 </data>
                    <data bit_width="8"> 0.108146 </data>
                    <data bit_width="16"> 0.220104 </data>
                    <data bit_width="32"> 0.442109 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.099159 </data>
                    <data bit_width="8"> 0.200534 </data>
                    <data bit_width="16"> 0.461015 </data>
                    <data bit_width="32"> 0.884365 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.067324 </data>
                    <data bit_width="8"> 0.120606 </data>
                    <data bit_width="16"> 0.248370 </data>
                    <data bit_width="32"> 0.478802 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4"> 0.068268 </data>
                  <data bit_width="8"> 0.128207 </data>
                  <data bit_width="16"> 0.213865 </data>
                  <data bit_width="32"> 0.433352 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.040652 </data>
                  <data bit_width="8"> 0.073684 </data>
                  <data bit_width="16"> 0.137282 </data>
                  <data bit_width="32"> 0.269239 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.040652 </data>
                    <data bit_width="8"> 0.073684 </data>
                    <data bit_width="16"> 0.137282 </data>
                    <data bit_width="32"> 0.269239 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.068268 </data>
                    <data bit_width="8"> 0.128207 </data>
                    <data bit_width="16"> 0.213865 </data>
                    <data bit_width="32"> 0.433352 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.048351 </data>
                    <data bit_width="8"> 0.081060 </data>
                    <data bit_width="16"> 0.148062 </data>
                    <data bit_width="32"> 0.293408 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4"> 0.063347 </data>
                  <data bit_width="8"> 0.121614 </data>
                  <data bit_width="16"> 0.206003 </data>
                  <data bit_width="32"> 0.411283 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.038190 </data>
                  <data bit_width="8"> 0.067810 </data>
                  <data bit_width="16"> 0.134344 </data>
                  <data bit_width="32"> 0.265109 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.038190 </data>
                    <data bit_width="8"> 0.067810 </data>
                    <data bit_width="16"> 0.134344 </data>
                    <data bit_width="32"> 0.265109 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.063347 </data>
                    <data bit_width="8"> 0.121614 </data>
                    <data bit_width="16"> 0.206003 </data>
                    <data bit_width="32"> 0.411283 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.045330 </data>
                    <data bit_width="8"> 0.075982 </data>
                    <data bit_width="16"> 0.149252 </data>
                    <data bit_width="32"> 0.290004 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4"> 0.089393 </data>
                  <data bit_width="8"> 0.207596 </data>
                  <data bit_width="16"> 0.421614 </data>
                  <data bit_width="32"> 0.843904 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.056770 </data>
                  <data bit_width="8"> 0.108306 </data>
                  <data bit_width="16"> 0.223912 </data>
                  <data bit_width="32"> 0.454011 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.056770 </data>
                    <data bit_width="8"> 0.108306 </data>
                    <data bit_width="16"> 0.223912 </data>
                    <data bit_width="32"> 0.454011 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.089393 </data>
                    <data bit_width="8"> 0.207596 </data>
                    <data bit_width="16"> 0.421614 </data>
                    <data bit_width="32"> 0.843904 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.069549 </data>
                    <data bit_width="8"> 0.127277 </data>
                    <data bit_width="16"> 0.262573 </data>
                    <data bit_width="32"> 0.534340 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4"> 0.022468 </data>
                  <data bit_width="8"> 0.196728 </data>
                  <data bit_width="16"> 0.881694 </data>
                  <data bit_width="32"> 3.731350 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.011037 </data>
                  <data bit_width="8"> 0.082802 </data>
                  <data bit_width="16"> 0.423968 </data>
                  <data bit_width="32"> 1.874228 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.011037 </data>
                    <data bit_width="8"> 0.082802 </data>
                    <data bit_width="16"> 0.423968 </data>
                    <data bit_width="32"> 1.874228 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.022468 </data>
                    <data bit_width="8"> 0.196728 </data>
                    <data bit_width="16"> 0.881694 </data>
                    <data bit_width="32"> 3.731350 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.013893 </data>
                    <data bit_width="8"> 0.106770 </data>
                    <data bit_width="16"> 0.534716 </data>
                    <data bit_width="32"> 2.337389 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4"> 0.058116 </data>
                  <data bit_width="8"> 0.245155 </data>
                  <data bit_width="16"> 0.979986 </data>
                  <data bit_width="32"> 3.983865 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.022627 </data>
                  <data bit_width="8"> 0.111619 </data>
                  <data bit_width="16"> 0.483973 </data>
                  <data bit_width="32"> 2.001754 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.022627 </data>
                    <data bit_width="8"> 0.111619 </data>
                    <data bit_width="16"> 0.483973 </data>
                    <data bit_width="32"> 2.001754 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.058116 </data>
                    <data bit_width="8"> 0.245155 </data>
                    <data bit_width="16"> 0.979986 </data>
                    <data bit_width="32"> 3.983865 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.029611 </data>
                    <data bit_width="8"> 0.145113 </data>
                    <data bit_width="16"> 0.606157 </data>
                    <data bit_width="32"> 2.484950 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4"> 0.087970 </data>
                  <data bit_width="8"> 0.360277 </data>
                  <data bit_width="16"> 1.333726 </data>
                  <data bit_width="32"> 4.836195 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.040492 </data>
                  <data bit_width="8"> 0.150773 </data>
                  <data bit_width="16"> 0.584520 </data>
                  <data bit_width="32"> 2.383829 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.040492 </data>
                    <data bit_width="8"> 0.150773 </data>
                    <data bit_width="16"> 0.584520 </data>
                    <data bit_width="32"> 2.383829 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.087970 </data>
                    <data bit_width="8"> 0.360277 </data>
                    <data bit_width="16"> 1.333726 </data>
                    <data bit_width="32"> 4.836195 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.052313 </data>
                    <data bit_width="8"> 0.197750 </data>
                    <data bit_width="16"> 0.757197 </data>
                    <data bit_width="32"> 3.050802 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4"> 0.038189 </data>
                  <data bit_width="8"> 0.198722 </data>
                  <data bit_width="16"> 0.940598 </data>
                  <data bit_width="32"> 4.011024 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.011118 </data>
                  <data bit_width="8"> 0.084565 </data>
                  <data bit_width="16"> 0.478584 </data>
                  <data bit_width="32"> 2.381973 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.011118 </data>
                    <data bit_width="8"> 0.084565 </data>
                    <data bit_width="16"> 0.478584 </data>
                    <data bit_width="32"> 2.381973 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.038189 </data>
                    <data bit_width="8"> 0.198722 </data>
                    <data bit_width="16"> 0.940598 </data>
                    <data bit_width="32"> 4.011024 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.013895 </data>
                    <data bit_width="8"> 0.102352 </data>
                    <data bit_width="16"> 0.575949 </data>
                    <data bit_width="32"> 2.890349 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4"> 0.051998 </data>
                  <data bit_width="8"> 0.272866 </data>
                  <data bit_width="16"> 1.116531 </data>
                  <data bit_width="32"> 4.509811 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.023186 </data>
                  <data bit_width="8"> 0.117272 </data>
                  <data bit_width="16"> 0.603924 </data>
                  <data bit_width="32"> 2.558484 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.023186 </data>
                    <data bit_width="8"> 0.117272 </data>
                    <data bit_width="16"> 0.603924 </data>
                    <data bit_width="32"> 2.558484 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.051998 </data>
                    <data bit_width="8"> 0.272866 </data>
                    <data bit_width="16"> 1.116531 </data>
                    <data bit_width="32"> 4.509811 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.032549 </data>
                    <data bit_width="8"> 0.131818 </data>
                    <data bit_width="16"> 0.704485 </data>
                    <data bit_width="32"> 3.219139 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4"> 0.079395 </data>
                  <data bit_width="8"> 0.343696 </data>
                  <data bit_width="16"> 1.399553 </data>
                  <data bit_width="32"> 5.183344 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.038195 </data>
                  <data bit_width="8"> 0.159754 </data>
                  <data bit_width="16"> 0.707423 </data>
                  <data bit_width="32"> 3.097429 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 0.038195 </data>
                    <data bit_width="8"> 0.159754 </data>
                    <data bit_width="16"> 0.707423 </data>
                    <data bit_width="32"> 3.097429 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.079395 </data>
                    <data bit_width="8"> 0.343696 </data>
                    <data bit_width="16"> 1.399553 </data>
                    <data bit_width="32"> 5.183344 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 0.046927 </data>
                    <data bit_width="8"> 0.205618 </data>
                    <data bit_width="16"> 0.865650 </data>
                    <data bit_width="32"> 3.591365 </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

            <est_index name="aspect_ratio">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="height">

              <!-- Dummy yet -->

            </est_index>

            <est_index name="width">

              <!-- Dummy yet -->

            </est_index>

          </est_type>


          <est_type name="timing">

            <est_index name="delay">
              <unit> ns </unit>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4"> 1.69 </data>
                  <data bit_width="8"> 1.66 </data>
                  <data bit_width="16"> 2.17 </data>
                  <data bit_width="32"> 2.90 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.19 </data>
                  <data bit_width="8"> 1.38 </data>
                  <data bit_width="16"> 1.81 </data>
                  <data bit_width="32"> 1.81 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 1.69 </data>
                    <data bit_width="8"> 1.66 </data>
                    <data bit_width="16"> 1.81 </data>
                    <data bit_width="32"> 1.81 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.19 </data>
                    <data bit_width="8"> 1.38 </data>
                    <data bit_width="16"> 2.17 </data>
                    <data bit_width="32"> 2.90 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.58 </data>
                    <data bit_width="8"> 1.66 </data>
                    <data bit_width="16"> 2.01 </data>
                    <data bit_width="32"> 2.01 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4"> 1.47 </data>
                  <data bit_width="8"> 1.53 </data>
                  <data bit_width="16"> 1.97 </data>
                  <data bit_width="32"> 3.33 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.18 </data>
                  <data bit_width="8"> 1.12 </data>
                  <data bit_width="16"> 1.41 </data>
                  <data bit_width="32"> 1.49 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 1.47 </data>
                    <data bit_width="8"> 1.12 </data>
                    <data bit_width="16"> 1.48 </data>
                    <data bit_width="32"> 1.49 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.18 </data>
                    <data bit_width="8"> 1.53 </data>
                    <data bit_width="16"> 1.97 </data>
                    <data bit_width="32"> 3.33 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.45 </data>
                    <data bit_width="8"> 1.24 </data>
                    <data bit_width="16"> 1.41 </data>
                    <data bit_width="32"> 1.81 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4"> 2.30 </data>
                  <data bit_width="8"> 5.82 </data>
                  <data bit_width="16"> 12.90 </data>
                  <data bit_width="32"> 24.61 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.25 </data>
                  <data bit_width="8"> 1.59 </data>
                  <data bit_width="16"> 2.40 </data>
                  <data bit_width="32"> 3.70 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.08 </data>
                    <data bit_width="8"> 5.82 </data>
                    <data bit_width="16"> 12.07 </data>
                    <data bit_width="32"> 24.51 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.25 </data>
                    <data bit_width="8"> 1.59 </data>
                    <data bit_width="16"> 2.40 </data>
                    <data bit_width="32"> 3.70 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.30 </data>
                    <data bit_width="8"> 5.79 </data>
                    <data bit_width="16"> 12.90 </data>
                    <data bit_width="32"> 24.61 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4"> 1.76 </data>
                  <data bit_width="8"> 1.85 </data>
                  <data bit_width="16"> 1.93 </data>
                  <data bit_width="32"> 2.38 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.18 </data>
                  <data bit_width="8"> 1.42 </data>
                  <data bit_width="16"> 1.78 </data>
                  <data bit_width="32"> 1.81 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 1.69 </data>
                    <data bit_width="8"> 1.85 </data>
                    <data bit_width="16"> 1.81 </data>
                    <data bit_width="32"> 1.81 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.18 </data>
                    <data bit_width="8"> 1.42 </data>
                    <data bit_width="16"> 1.93 </data>
                    <data bit_width="32"> 2.38 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.76 </data>
                    <data bit_width="8"> 1.58 </data>
                    <data bit_width="16"> 1.78 </data>
                    <data bit_width="32"> 1.81 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4"> 1.18 </data>
                  <data bit_width="8"> 1.54 </data>
                  <data bit_width="16"> 1.97 </data>
                  <data bit_width="32"> 2.49 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.09 </data>
                  <data bit_width="8"> 0.64 </data>
                  <data bit_width="16"> 1.23 </data>
                  <data bit_width="32"> 1.49 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 1.12 </data>
                    <data bit_width="8"> 1.54 </data>
                    <data bit_width="16"> 1.47 </data>
                    <data bit_width="32"> 1.49 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.18 </data>
                    <data bit_width="8"> 1.37 </data>
                    <data bit_width="16"> 1.97 </data>
                    <data bit_width="32"> 2.49 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.09 </data>
                    <data bit_width="8"> 0.64 </data>
                    <data bit_width="16"> 1.23 </data>
                    <data bit_width="32"> 1.81 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4"> 2.65 </data>
                  <data bit_width="8"> 5.51 </data>
                  <data bit_width="16"> 10.64 </data>
                  <data bit_width="32"> 11.47 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.20 </data>
                  <data bit_width="8"> 1.44 </data>
                  <data bit_width="16"> 2.04 </data>
                  <data bit_width="32"> 2.36 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.34 </data>
                    <data bit_width="8"> 5.49 </data>
                    <data bit_width="16"> 9.85 </data>
                    <data bit_width="32"> 11.25 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.20 </data>
                    <data bit_width="8"> 1.44 </data>
                    <data bit_width="16"> 2.04 </data>
                    <data bit_width="32"> 2.36 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.65 </data>
                    <data bit_width="8"> 5.51 </data>
                    <data bit_width="16"> 10.64 </data>
                    <data bit_width="32"> 11.47 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4"> 1.99 </data>
                  <data bit_width="8"> 8.73 </data>
                  <data bit_width="16"> 22.08 </data>
                  <data bit_width="32"> 49.02 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.99 </data>
                  <data bit_width="8"> 4.54 </data>
                  <data bit_width="16"> 12.65 </data>
                  <data bit_width="32"> 29.18 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 1.90 </data>
                    <data bit_width="8"> 8.70 </data>
                    <data bit_width="16"> 22.08 </data>
                    <data bit_width="32"> 49.02 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.99 </data>
                    <data bit_width="8"> 4.54 </data>
                    <data bit_width="16"> 12.65 </data>
                    <data bit_width="32"> 29.18 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 1.99 </data>
                    <data bit_width="8"> 8.73 </data>
                    <data bit_width="16"> 19.92 </data>
                    <data bit_width="32"> 46.51 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4"> 3.64 </data>
                  <data bit_width="8"> 10.68 </data>
                  <data bit_width="16"> 24.24 </data>
                  <data bit_width="32"> 50.41 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.03 </data>
                  <data bit_width="8"> 5.52 </data>
                  <data bit_width="16"> 13.26 </data>
                  <data bit_width="32"> 30.23 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 3.26 </data>
                    <data bit_width="8"> 10.52 </data>
                    <data bit_width="16"> 24.24 </data>
                    <data bit_width="32"> 50.41 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 2.03 </data>
                    <data bit_width="8"> 5.52 </data>
                    <data bit_width="16"> 13.26 </data>
                    <data bit_width="32"> 30.23 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 3.64 </data>
                    <data bit_width="8"> 10.68 </data>
                    <data bit_width="16"> 22.08 </data>
                    <data bit_width="32"> 49.18 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4"> 5.20 </data>
                  <data bit_width="8"> 12.37 </data>
                  <data bit_width="16"> 26.37 </data>
                  <data bit_width="32"> 52.82 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.61 </data>
                  <data bit_width="8"> 6.35 </data>
                  <data bit_width="16"> 14.33 </data>
                  <data bit_width="32"> 32.95 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 4.79 </data>
                    <data bit_width="8"> 12.37 </data>
                    <data bit_width="16"> 26.37 </data>
                    <data bit_width="32"> 52.82 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 2.61 </data>
                    <data bit_width="8"> 6.35 </data>
                    <data bit_width="16"> 14.33 </data>
                    <data bit_width="32"> 32.95 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 5.20 </data>
                    <data bit_width="8"> 11.76 </data>
                    <data bit_width="16"> 23.69 </data>
                    <data bit_width="32"> 51.87 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4"> 2.09 </data>
                  <data bit_width="8"> 8.30 </data>
                  <data bit_width="16"> 24.83 </data>
                  <data bit_width="32"> 57.04 </data>
                </max>
                <min>
                  <data bit_width="4"> 0.93 </data>
                  <data bit_width="8"> 4.53 </data>
                  <data bit_width="16"> 11.83 </data>
                  <data bit_width="32"> 27.78 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 2.09 </data>
                    <data bit_width="8"> 8.17 </data>
                    <data bit_width="16"> 24.83 </data>
                    <data bit_width="32"> 55.17 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 0.93 </data>
                    <data bit_width="8"> 4.53 </data>
                    <data bit_width="16"> 11.83 </data>
                    <data bit_width="32"> 27.78 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 2.01 </data>
                    <data bit_width="8"> 8.30 </data>
                    <data bit_width="16"> 22.41 </data>
                    <data bit_width="32"> 57.04 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4"> 3.93 </data>
                  <data bit_width="8"> 9.86 </data>
                  <data bit_width="16"> 27.53 </data>
                  <data bit_width="32"> 61.12 </data>
                </max>
                <min>
                  <data bit_width="4"> 1.75 </data>
                  <data bit_width="8"> 5.39 </data>
                  <data bit_width="16"> 13.06 </data>
                  <data bit_width="32"> 28.44 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 3.65 </data>
                    <data bit_width="8"> 9.71 </data>
                    <data bit_width="16"> 27.09 </data>
                    <data bit_width="32"> 58.41 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 1.75 </data>
                    <data bit_width="8"> 5.39 </data>
                    <data bit_width="16"> 13.06 </data>
                    <data bit_width="32"> 28.44 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 3.93 </data>
                    <data bit_width="8"> 9.86 </data>
                    <data bit_width="16"> 27.53 </data>
                    <data bit_width="32"> 61.12 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4"> 5.44 </data>
                  <data bit_width="8"> 12.25 </data>
                  <data bit_width="16"> 32.02 </data>
                  <data bit_width="32"> 63.58 </data>
                </max>
                <min>
                  <data bit_width="4"> 2.72 </data>
                  <data bit_width="8"> 6.11 </data>
                  <data bit_width="16"> 13.44 </data>
                  <data bit_width="32"> 29.25 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 5.31 </data>
                    <data bit_width="8"> 11.20 </data>
                    <data bit_width="16"> 30.83 </data>
                    <data bit_width="32"> 63.58 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 2.72 </data>
                    <data bit_width="8"> 6.11 </data>
                    <data bit_width="16"> 13.44 </data>
                    <data bit_width="32"> 29.25 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 5.44 </data>
                    <data bit_width="8"> 12.25 </data>
                    <data bit_width="16"> 32.02 </data>
                    <data bit_width="32"> 62.02 </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

            <est_index name="delay_fullpath">
              <unit> ns </unit>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.22
                    internal	 2.75
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.25
                    internal	 4.01
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.41
                    internal	 7.66
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.40
                    internal	 12.92
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.22
                    internal	 2.75
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.25
                    internal	 4.01
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.41
                    internal	 7.66
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.40
                    internal	 12.92
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.47
                      internal	 2.81
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.12
                      internal	 4.21
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.48
                      internal	 7.99
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.49
                      internal	 14.95
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.68
                      internal	 1.19
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.75
                      internal	 1.38
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 1.14
                      internal	 2.17
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.84
                      internal	 2.90
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.22
                      internal	 2.75
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.25
                      internal	 4.01
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.41
                      internal	 7.66
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.47
                      inport	 b	 0.46
                      outport	 mulu	 1.40
                      internal	 12.92
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.45
                    internal	 2.68
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.24
                    internal	 3.95
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.41
                    internal	 7.79
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.81
                    internal	 12.96
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.45
                    internal	 2.68
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.24
                    internal	 3.95
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.41
                    internal	 7.79
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.81
                    internal	 12.96
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.47
                      internal	 2.95
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.12
                      internal	 4.23
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.48
                      internal	 8.01
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.49
                      internal	 14.96
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.79
                      internal	 1.18
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 1.03
                      internal	 1.53
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 1.22
                      internal	 1.97
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.86
                      internal	 3.33
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.45
                      internal	 2.68
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.24
                      internal	 3.95
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.41
                      internal	 7.79
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.81
                      internal	 12.96
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.96
                    inport	 b	 0.93
                    outport	 mulu	 2.30
                    internal	 2.78
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 2.14
                    outport	 mulu	 5.79
                    internal	 5.79
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.62
                    outport	 mulu	 12.90
                    internal	 12.90
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.48
                    inport	 b	 10.40
                    outport	 mulu	 24.61
                    internal	 24.61
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.96
                    inport	 b	 0.93
                    outport	 mulu	 2.30
                    internal	 2.78
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 2.14
                    outport	 mulu	 5.79
                    internal	 5.79
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.62
                    outport	 mulu	 12.90
                    internal	 12.90
                  </data>
                  <data bit_width="32">
                    inport	 a	 10.48
                    inport	 b	 10.40
                    outport	 mulu	 24.61
                    internal	 24.61
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.82
                      inport	 b	 0.93
                      outport	 mulu	 2.08
                      internal	 2.54
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.35
                      inport	 b	 2.15
                      outport	 mulu	 5.82
                      internal	 5.82
                    </data>
                    <data bit_width="16">
                      inport	 a	 5.07
                      inport	 b	 5.36
                      outport	 mulu	 12.07
                      internal	 12.07
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.94
                      inport	 b	 11.24
                      outport	 mulu	 24.51
                      internal	 24.51
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.72
                      inport	 b	 0.73
                      outport	 mulu	 1.37
                      internal	 1.25
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.12
                      inport	 b	 1.13
                      outport	 mulu	 1.67
                      internal	 1.59
                    </data>
                    <data bit_width="16">
                      inport	 a	 2.11
                      inport	 b	 2.20
                      outport	 mulu	 2.32
                      internal	 2.40
                    </data>
                    <data bit_width="32">
                      inport	 a	 3.23
                      inport	 b	 3.30
                      outport	 mulu	 3.00
                      internal	 3.70
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.96
                      inport	 b	 0.93
                      outport	 mulu	 2.30
                      internal	 2.78
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.39
                      inport	 b	 2.14
                      outport	 mulu	 5.79
                      internal	 5.79
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.60
                      inport	 b	 4.62
                      outport	 mulu	 12.90
                      internal	 12.90
                    </data>
                    <data bit_width="32">
                      inport	 a	 10.48
                      inport	 b	 10.40
                      outport	 mulu	 24.61
                      internal	 24.61
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 0.87
                    internal	 2.77
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 0.65
                    internal	 3.62
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.23
                    internal	 5.10
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.81
                    internal	 8.67
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 0.87
                    internal	 2.77
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 0.65
                    internal	 3.62
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.48
                    inport	 b	 0.47
                    outport	 mulu	 1.23
                    internal	 5.10
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.47
                    inport	 b	 0.46
                    outport	 mulu	 1.81
                    internal	 8.67
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.12
                      internal	 2.47
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.54
                      internal	 4.35
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.47
                      internal	 5.11
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.49
                      internal	 6.67
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.81
                      internal	 1.18
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.85
                      internal	 1.42
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.89
                      internal	 1.93
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.46
                      inport	 b	 0.47
                      outport	 mulu	 0.78
                      internal	 2.38
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 0.87
                      internal	 2.77
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 0.65
                      internal	 3.62
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.48
                      inport	 b	 0.47
                      outport	 mulu	 1.23
                      internal	 5.10
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.47
                      inport	 b	 0.46
                      outport	 mulu	 1.81
                      internal	 8.67
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.09
                    internal	 2.79
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 0.64
                    internal	 3.65
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.23
                    internal	 5.26
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0
                    outport	 smul0	 1.81
                    internal	 8.64
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.09
                    internal	 2.79
                  </data>
                  <data bit_width="8">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 0.64
                    internal	 3.65
                  </data>
                  <data bit_width="16">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.23
                    internal	 5.26
                  </data>
                  <data bit_width="32">
                    inport	 a	 0.23
                    inport	 b	 0.00
                    outport	 smul0	 1.81
                    internal	 8.64
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.12
                      internal	 2.95
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.54
                      internal	 4.35
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.47
                      internal	 5.11
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.23
                      outport	 smul0	 1.49
                      internal	 6.67
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.34
                      inport	 b	 0.42
                      outport	 smul0	 0.68
                      internal	 1.18
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.91
                      internal	 1.37
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 1.28
                      internal	 1.97
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.34
                      inport	 b	 0.41
                      outport	 smul0	 0.78
                      internal	 2.49
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.09
                      internal	 2.79
                    </data>
                    <data bit_width="8">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 0.64
                      internal	 3.65
                    </data>
                    <data bit_width="16">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.23
                      internal	 5.26
                    </data>
                    <data bit_width="32">
                      inport	 a	 0.23
                      inport	 b	 0.00
                      outport	 smul0	 1.81
                      internal	 8.64
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4">
                    inport	 a	 0.94
                    inport	 b	 0.89
                    outport	 mulu	 2.65
                    internal	 2.91
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 1.62
                    outport	 mulu	 5.51
                    internal	 5.51
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.12
                    outport	 mulu	 10.64
                    internal	 10.64
                  </data>
                  <data bit_width="32">
                    inport	 a	 8.68
                    inport	 b	 7.13
                    outport	 mulu	 11.47
                    internal	 11.47
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    inport	 a	 0.94
                    inport	 b	 0.89
                    outport	 mulu	 2.65
                    internal	 2.91
                  </data>
                  <data bit_width="8">
                    inport	 a	 2.39
                    inport	 b	 1.62
                    outport	 mulu	 5.51
                    internal	 5.51
                  </data>
                  <data bit_width="16">
                    inport	 a	 4.60
                    inport	 b	 4.12
                    outport	 mulu	 10.64
                    internal	 10.64
                  </data>
                  <data bit_width="32">
                    inport	 a	 8.68
                    inport	 b	 7.13
                    outport	 mulu	 11.47
                    internal	 11.47
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      inport	 a	 0.85
                      inport	 b	 0.80
                      outport	 mulu	 2.34
                      internal	 2.88
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.35
                      inport	 b	 1.52
                      outport	 mulu	 5.49
                      internal	 5.49
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.62
                      inport	 b	 4.63
                      outport	 mulu	 9.85
                      internal	 9.85
                    </data>
                    <data bit_width="32">
                      inport	 a	 8.60
                      inport	 b	 10.13
                      outport	 mulu	 11.25
                      internal	 11.25
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      inport	 a	 0.72
                      inport	 b	 0.77
                      outport	 mulu	 1.33
                      internal	 1.20
                    </data>
                    <data bit_width="8">
                      inport	 a	 1.09
                      inport	 b	 1.14
                      outport	 mulu	 1.53
                      internal	 1.44
                    </data>
                    <data bit_width="16">
                      inport	 a	 1.78
                      inport	 b	 1.95
                      outport	 mulu	 2.13
                      internal	 2.04
                    </data>
                    <data bit_width="32">
                      inport	 a	 2.18
                      inport	 b	 2.25
                      outport	 mulu	 2.46
                      internal	 2.36
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      inport	 a	 0.94
                      inport	 b	 0.89
                      outport	 mulu	 2.65
                      internal	 2.91
                    </data>
                    <data bit_width="8">
                      inport	 a	 2.39
                      inport	 b	 1.62
                      outport	 mulu	 5.51
                      internal	 5.51
                    </data>
                    <data bit_width="16">
                      inport	 a	 4.60
                      inport	 b	 4.12
                      outport	 mulu	 10.64
                      internal	 10.64
                    </data>
                    <data bit_width="32">
                      inport	 a	 8.68
                      inport	 b	 7.13
                      outport	 mulu	 11.47
                      internal	 11.47
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 1.99
                    path	 b	 result	 1.95
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 8.72
                    path	 b	 result	 8.73
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 19.90
                    path	 b	 result	 19.92
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 46.48
                    path	 b	 result	 46.51
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 1.99
                    path	 b	 result	 1.95
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 8.72
                    path	 b	 result	 8.73
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 19.90
                    path	 b	 result	 19.92
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 46.48
                    path	 b	 result	 46.51
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 1.86
                      path	 b	 result	 1.90
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 8.68
                      path	 b	 result	 8.70
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 22.08
                      path	 b	 result	 22.04
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 48.99
                      path	 b	 result	 49.02
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 0.99
                      path	 b	 result	 0.99
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 4.54
                      path	 b	 result	 4.52
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 12.64
                      path	 b	 result	 12.65
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 29.16
                      path	 b	 result	 29.18
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 1.99
                      path	 b	 result	 1.95
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 8.72
                      path	 b	 result	 8.73
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 19.90
                      path	 b	 result	 19.92
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 46.48
                      path	 b	 result	 46.51
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 3.61
                    path	 b	 result	 3.64
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 10.68
                    path	 b	 result	 10.65
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 22.05
                    path	 b	 result	 22.08
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 49.15
                    path	 b	 result	 49.18
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 3.61
                    path	 b	 result	 3.64
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 10.68
                    path	 b	 result	 10.65
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 22.05
                    path	 b	 result	 22.08
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 49.15
                    path	 b	 result	 49.18
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 3.23
                      path	 b	 result	 3.26
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 10.52
                      path	 b	 result	 10.50
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 24.24
                      path	 b	 result	 24.00
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 50.38
                      path	 b	 result	 50.41
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.02
                      path	 b	 result	 2.03
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 5.52
                      path	 b	 result	 5.52
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 13.26
                      path	 b	 result	 13.26
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 30.23
                      path	 b	 result	 30.23
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 3.61
                      path	 b	 result	 3.64
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 10.68
                      path	 b	 result	 10.65
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 22.05
                      path	 b	 result	 22.08
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 49.15
                      path	 b	 result	 49.18
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 4.66
                    path	 b	 result	 5.17
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 11.60
                    path	 b	 result	 11.76
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 23.69
                    path	 b	 result	 23.38
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 51.62
                    path	 b	 result	 51.87
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 4.66
                    path	 b	 result	 5.17
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 11.60
                    path	 b	 result	 11.76
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 23.69
                    path	 b	 result	 23.38
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 51.62
                    path	 b	 result	 51.87
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 4.51
                      path	 b	 result	 4.77
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 12.37
                      path	 b	 result	 12.25
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 26.03
                      path	 b	 result	 26.37
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 52.82
                      path	 b	 result	 52.05
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.61
                      path	 b	 result	 2.61
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 6.35
                      path	 b	 result	 6.34
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 14.32
                      path	 b	 result	 14.33
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 32.95
                      path	 b	 result	 32.93
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 4.66
                      path	 b	 result	 5.17
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 11.60
                      path	 b	 result	 11.76
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 23.69
                      path	 b	 result	 23.38
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 51.62
                      path	 b	 result	 51.87
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 2.00
                    path	 b	 result	 2.01
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 8.30
                    path	 b	 result	 8.29
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 22.40
                    path	 b	 result	 22.41
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 57.04
                    path	 b	 result	 56.94
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 2.00
                    path	 b	 result	 2.01
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 8.30
                    path	 b	 result	 8.29
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 22.40
                    path	 b	 result	 22.41
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 57.04
                    path	 b	 result	 56.94
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 2.07
                      path	 b	 result	 2.09
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 8.13
                      path	 b	 result	 8.17
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 24.77
                      path	 b	 result	 24.83
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 55.17
                      path	 b	 result	 55.15
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 0.93
                      path	 b	 result	 0.93
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 4.53
                      path	 b	 result	 4.53
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 11.83
                      path	 b	 result	 11.82
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 27.78
                      path	 b	 result	 27.78
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 2.00
                      path	 b	 result	 2.01
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 8.30
                      path	 b	 result	 8.29
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 22.40
                      path	 b	 result	 22.41
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 57.04
                      path	 b	 result	 56.94
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 3.91
                    path	 b	 result	 3.93
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 9.86
                    path	 b	 result	 9.85
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 27.51
                    path	 b	 result	 27.53
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 61.12
                    path	 b	 result	 60.79
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 3.91
                    path	 b	 result	 3.93
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 9.86
                    path	 b	 result	 9.85
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 27.51
                    path	 b	 result	 27.53
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 61.12
                    path	 b	 result	 60.79
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 3.63
                      path	 b	 result	 3.65
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 9.71
                      path	 b	 result	 9.54
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 27.09
                      path	 b	 result	 27.08
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 58.41
                      path	 b	 result	 58.39
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 1.75
                      path	 b	 result	 1.75
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 5.39
                      path	 b	 result	 5.39
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 13.06
                      path	 b	 result	 13.06
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 28.44
                      path	 b	 result	 28.44
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 3.91
                      path	 b	 result	 3.93
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 9.86
                      path	 b	 result	 9.85
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 27.51
                      path	 b	 result	 27.53
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 61.12
                      path	 b	 result	 60.79
                    </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4">
                    path	 a	 result	 5.33
                    path	 b	 result	 5.41
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 12.25
                    path	 b	 result	 11.77
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 31.70
                    path	 b	 result	 32.02
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 62.02
                    path	 b	 result	 61.89
                  </data>
                </max>
                <min>
                  <data bit_width="4">
                    path	 a	 result	 5.33
                    path	 b	 result	 5.41
                  </data>
                  <data bit_width="8">
                    path	 a	 result	 12.25
                    path	 b	 result	 11.77
                  </data>
                  <data bit_width="16">
                    path	 a	 result	 31.70
                    path	 b	 result	 32.02
                  </data>
                  <data bit_width="32">
                    path	 a	 result	 62.02
                    path	 b	 result	 61.89
                  </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4">
                      path	 a	 result	 5.31
                      path	 b	 result	 5.29
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 11.20
                      path	 b	 result	 10.52
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 30.83
                      path	 b	 result	 30.18
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 63.58
                      path	 b	 result	 62.67
                    </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4">
                      path	 a	 result	 2.70
                      path	 b	 result	 2.69
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 6.11
                      path	 b	 result	 6.11
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 13.43
                      path	 b	 result	 13.44
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 29.24
                      path	 b	 result	 29.25
                    </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4">
                      path	 a	 result	 5.33
                      path	 b	 result	 5.41
                    </data>
                    <data bit_width="8">
                      path	 a	 result	 12.25
                      path	 b	 result	 11.77
                    </data>
                    <data bit_width="16">
                      path	 a	 result	 31.70
                      path	 b	 result	 32.02
                    </data>
                    <data bit_width="32">
                      path	 a	 result	 62.02
                      path	 b	 result	 61.89
                    </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="power">
          
            <est_index name="static_power">
              <unit> mW </unit>

              <parameters name="seq,rca,abs">
                <max>
                  <data bit_width="4"> 323.2213 </data>
                  <data bit_width="8"> 510.4671 </data>
                  <data bit_width="16"> 789.8358 </data>
                  <data bit_width="32"> 947.2614 </data>
                </max>
                <min>
                  <data bit_width="4"> 303.8337 </data>
                  <data bit_width="8"> 465.7112 </data>
                  <data bit_width="16"> 695.6887 </data>
                  <data bit_width="32"> 916.0902 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 323.2213 </data>
                    <data bit_width="8"> 465.7112 </data>
                    <data bit_width="16"> 789.8358 </data>
                    <data bit_width="32"> 947.2614 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 303.8337 </data>
                    <data bit_width="8"> 489.0250 </data>
                    <data bit_width="16"> 695.6887 </data>
                    <data bit_width="32"> 916.0902 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 307.9786 </data>
                    <data bit_width="8"> 510.4671 </data>
                    <data bit_width="16"> 783.8742 </data>
                    <data bit_width="32"> 935.8000 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,unsigned">
                <max>
                  <data bit_width="4"> 282.1592 </data>
                  <data bit_width="8"> 453.5054 </data>
                  <data bit_width="16"> 759.8872 </data>
                  <data bit_width="32"> 942.6606 </data>
                </max>
                <min>
                  <data bit_width="4"> 262.8941 </data>
                  <data bit_width="8"> 427.6340 </data>
                  <data bit_width="16"> 665.7615 </data>
                  <data bit_width="32"> 911.1910 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 268.2472 </data>
                    <data bit_width="8"> 427.6340 </data>
                    <data bit_width="16"> 759.8872 </data>
                    <data bit_width="32"> 942.6606 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 262.8941 </data>
                    <data bit_width="8"> 432.9040 </data>
                    <data bit_width="16"> 665.7615 </data>
                    <data bit_width="32"> 911.1910 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 282.1592 </data>
                    <data bit_width="8"> 453.5054 </data>
                    <data bit_width="16"> 755.1883 </data>
                    <data bit_width="32"> 932.2643 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <max>
                  <data bit_width="4"> 372.3671 </data>
                  <data bit_width="8"> 583.0257 </data>
                  <data bit_width="16"> 1013.2 </data>
                  <data bit_width="32"> 1625.7 </data>
                </max>
                <min>
                  <data bit_width="4"> 328.9825 </data>
                  <data bit_width="8"> 424.6467 </data>
                  <data bit_width="16"> 914.1110 </data>
                  <data bit_width="32"> 1241.1 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 331.9344 </data>
                    <data bit_width="8"> 424.6467 </data>
                    <data bit_width="16"> 984.3083 </data>
                    <data bit_width="32"> 1625.7 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 372.3671 </data>
                    <data bit_width="8"> 583.0257 </data>
                    <data bit_width="16"> 914.1110 </data>
                    <data bit_width="32"> 1241.1 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 328.9825 </data>
                    <data bit_width="8"> 504.7635 </data>
                    <data bit_width="16"> 1013.2 </data>
                    <data bit_width="32"> 1585.2 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,abs">
                <max>
                  <data bit_width="4"> 311.8853 </data>
                  <data bit_width="8"> 510.2655 </data>
                  <data bit_width="16"> 789.5388 </data>
                  <data bit_width="32"> 950.2491 </data>
                </max>
                <min>
                  <data bit_width="4"> 305.0171 </data>
                  <data bit_width="8"> 489.2275 </data>
                  <data bit_width="16"> 779.3991 </data>
                  <data bit_width="32"> 910.3955 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 311.8853 </data>
                    <data bit_width="8"> 489.2275 </data>
                    <data bit_width="16"> 789.5388 </data>
                    <data bit_width="32"> 950.2491 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 305.0171 </data>
                    <data bit_width="8"> 489.8456 </data>
                    <data bit_width="16"> 779.3991 </data>
                    <data bit_width="32"> 910.3955 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 307.8217 </data>
                    <data bit_width="8"> 510.2655 </data>
                    <data bit_width="16"> 783.6043 </data>
                    <data bit_width="32"> 935.5323 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <max>
                  <data bit_width="4"> 282.0166 </data>
                  <data bit_width="8"> 453.2739 </data>
                  <data bit_width="16"> 759.6111 </data>
                  <data bit_width="32"> 942.3607 </data>
                </max>
                <min>
                  <data bit_width="4"> 262.4604 </data>
                  <data bit_width="8"> 408.0370 </data>
                  <data bit_width="16"> 667.2924 </data>
                  <data bit_width="32"> 909.7382 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 267.8774 </data>
                    <data bit_width="8"> 408.0370 </data>
                    <data bit_width="16"> 759.6111 </data>
                    <data bit_width="32"> 942.3607 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 262.4604 </data>
                    <data bit_width="8"> 432.2610 </data>
                    <data bit_width="16"> 667.2924 </data>
                    <data bit_width="32"> 909.7382 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 282.0166 </data>
                    <data bit_width="8"> 453.2739 </data>
                    <data bit_width="16"> 754.9366 </data>
                    <data bit_width="32"> 932.0092 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <max>
                  <data bit_width="4"> 372.9726 </data>
                  <data bit_width="8"> 605.4647 </data>
                  <data bit_width="16"> 1034.8 </data>
                  <data bit_width="32"> 1654.5 </data>
                </max>
                <min>
                  <data bit_width="4"> 332.4337 </data>
                  <data bit_width="8"> 452.7679 </data>
                  <data bit_width="16"> 937.4893 </data>
                  <data bit_width="32"> 1321 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 334.7431 </data>
                    <data bit_width="8"> 452.7679 </data>
                    <data bit_width="16"> 1003.9 </data>
                    <data bit_width="32"> 1654.5 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 372.9726 </data>
                    <data bit_width="8"> 605.4647 </data>
                    <data bit_width="16"> 937.4893 </data>
                    <data bit_width="32"> 1321 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 332.4337 </data>
                    <data bit_width="8"> 499.3257 </data>
                    <data bit_width="16"> 1034.8 </data>
                    <data bit_width="32"> 1626 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,abs">
                <max>
                  <data bit_width="4"> 109.8952 </data>
                  <data bit_width="8"> 1617 </data>
                  <data bit_width="16"> 9176.1 </data>
                  <data bit_width="32"> 63637.8 </data>
                </max>
                <min>
                  <data bit_width="4"> 20.4679 </data>
                  <data bit_width="8"> 556.9493 </data>
                  <data bit_width="16"> 6856.9 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 21.4443 </data>
                    <data bit_width="8"> 571.0283 </data>
                    <data bit_width="16"> 6856.9 </data>
                    <data bit_width="32"> 23190.4 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 109.8952 </data>
                    <data bit_width="8"> 1617 </data>
                    <data bit_width="16"> 9176.1 </data>
                    <data bit_width="32"> 63637.8 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 20.4679 </data>
                    <data bit_width="8"> 556.9493 </data>
                    <data bit_width="16"> 7021.4 </data>
                    <data bit_width="32"> 46462.9 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,unsigned">
                <max>
                  <data bit_width="4"> 296.4183 </data>
                  <data bit_width="8"> 1477.9 </data>
                  <data bit_width="16"> 10177.8 </data>
                  <data bit_width="32"> 65986.5 </data>
                </max>
                <min>
                  <data bit_width="4"> 96.9995 </data>
                  <data bit_width="8"> 843.7167 </data>
                  <data bit_width="16"> 8460.9 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 101.3923 </data>
                    <data bit_width="8"> 866.0886 </data>
                    <data bit_width="16"> 8460.9 </data>
                    <data bit_width="32"> 48393.9 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 296.4183 </data>
                    <data bit_width="8"> 1477.9 </data>
                    <data bit_width="16"> 10177.8 </data>
                    <data bit_width="32"> 65986.5 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 96.9995 </data>
                    <data bit_width="8"> 843.7167 </data>
                    <data bit_width="16"> 8548.1 </data>
                    <data bit_width="32"> 48019 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,rca,two_complement">
                <max>
                  <data bit_width="4"> 264.7732 </data>
                  <data bit_width="8"> 1196.9 </data>
                  <data bit_width="16"> 4619.9 </data>
                  <data bit_width="32"> 15738.8 </data>
                </max>
                <min>
                  <data bit_width="4"> 161.7144 </data>
                  <data bit_width="8"> 765.7183 </data>
                  <data bit_width="16"> 2464.3 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 169.0015 </data>
                    <data bit_width="8"> 765.7183 </data>
                    <data bit_width="16"> 2464.3 </data>
                    <data bit_width="32"> 13933.4 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 264.7732 </data>
                    <data bit_width="8"> 1196.9 </data>
                    <data bit_width="16"> 4619.9 </data>
                    <data bit_width="32"> 15738.8 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 161.7144 </data>
                    <data bit_width="8"> 868.5984 </data>
                    <data bit_width="16"> 3178.2 </data>
                    <data bit_width="32"> 15386.3 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,abs">
                <max>
                  <data bit_width="4"> 505.2987 </data>
                  <data bit_width="8"> 1256.1 </data>
                  <data bit_width="16"> 10797.6 </data>
                  <data bit_width="32"> 63954.7 </data>
                </max>
                <min>
                  <data bit_width="4"> 22.4508 </data>
                  <data bit_width="8"> 565.9814 </data>
                  <data bit_width="16"> 6754.9 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 22.8627 </data>
                    <data bit_width="8"> 565.9814 </data>
                    <data bit_width="16"> 6754.9 </data>
                    <data bit_width="32"> 49810.2 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 505.2987 </data>
                    <data bit_width="8"> 1249 </data>
                    <data bit_width="16"> 10797.6 </data>
                    <data bit_width="32"> 63954.7 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 22.4508 </data>
                    <data bit_width="8"> 1256.1 </data>
                    <data bit_width="16"> 9961.7 </data>
                    <data bit_width="32"> 50331.9 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,unsigned">
                <max>
                  <data bit_width="4"> 308.1632 </data>
                  <data bit_width="8"> 2262.6 </data>
                  <data bit_width="16"> 11741.5 </data>
                  <data bit_width="32"> 66751.8 </data>
                </max>
                <min>
                  <data bit_width="4"> 96.5825 </data>
                  <data bit_width="8"> 847.3462 </data>
                  <data bit_width="16"> 8502.6 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 96.5825 </data>
                    <data bit_width="8"> 847.3462 </data>
                    <data bit_width="16"> 8502.6 </data>
                    <data bit_width="32"> 52626.8 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 308.1632 </data>
                    <data bit_width="8"> 2262.6 </data>
                    <data bit_width="16"> 11741.5 </data>
                    <data bit_width="32"> 66751.8 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 96.9198 </data>
                    <data bit_width="8"> 2253.1 </data>
                    <data bit_width="16"> 11008.4 </data>
                    <data bit_width="32"> 65153.3 </data>
                  </priority>
                </typ>
              </parameters>

              <parameters name="array,cla,two_complement">
                <max>
                  <data bit_width="4"> 250.5983 </data>
                  <data bit_width="8"> 1231.2 </data>
                  <data bit_width="16"> 5477.4 </data>
                  <data bit_width="32"> 26088.5 </data>
                </max>
                <min>
                  <data bit_width="4"> 140.9322 </data>
                  <data bit_width="8"> 978.1868 </data>
                  <data bit_width="16"> 3936.3 </data>
                  <data bit_width="32"> 10000 </data>
                </min>
                <typ>
                  <priority name="area">
                    <data bit_width="4"> 140.9322 </data>
                    <data bit_width="8"> 978.1868 </data>
                    <data bit_width="16"> 3936.3 </data>
                    <data bit_width="32"> 25067.9 </data>
                  </priority>
                  <priority name="delay">
                    <data bit_width="4"> 250.5983 </data>
                    <data bit_width="8"> 1225.6 </data>
                    <data bit_width="16"> 4814.1 </data>
                    <data bit_width="32"> 17644.5 </data>
                  </priority>
                  <priority name="power">
                    <data bit_width="4"> 168.0735 </data>
                    <data bit_width="8"> 1231.2 </data>
                    <data bit_width="16"> 5477.4 </data>
                    <data bit_width="32"> 26088.5 </data>
                  </priority>
                </typ>
              </parameters>

            </est_index>

          </est_type>

          <est_type name="function_cycle">
            <unit> cycle </unit>

            <est_index name="cycle">
              <parameters name="seq,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="latency">
              <parameters name="seq,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>
            </est_index>

            <est_index name="throughput">
              <parameters name="seq,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="seq,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,rca,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,unsigned">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,abs">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>

              <parameters name="array,cla,two_complement">
                <function name="nop">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="reset">
                  <priority name="area"><data bit_width="1">0</data></priority>
                  <priority name="delay"><data bit_width="1">0</data></priority>
                  <priority name="power"><data bit_width="1">0</data></priority>
                </function>

                <function name="mul">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mulu">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>

                <function name="mula">
                  <priority name="area"><data bit_width="1">1</data></priority>
                  <priority name="delay"><data bit_width="1">1</data></priority>
                  <priority name="power"><data bit_width="1">1</data></priority>
                </function>
              </parameters>
            </est_index>

          </est_type>

          <est_type name="function_power">

            <!-- Dummy yet -->

          </est_type>

        </library>     

      </estimation_data>

      <estimation_method>
         
        <est_type name="shape">

          <est_index name="area">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of area for multiplier(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 4);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

           <est_index name="aspect_ratio">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="height">

             <!-- Dummy yet -->

           </est_index>
		
           <est_index name="width">

             <!-- Dummy yet -->

           </est_index>
		
        </est_type>

        <est_type name="timing">

          <est_index name="delay">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of delay for multiplier(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 2);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

          <est_index name="delay_fullpath">

          </est_index>

        </est_type>

        <est_type name="power">

          <est_index name="static_power">

            <parameters name="seq,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(seq,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,rca,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,abs) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,unsigned) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
               <script>
                 <![CDATA[
#!/usr/bin/perl
# -------------------------------------------------------------------#
# Estimation method of power for multiplier(array,cla,two_complement) .
#
# Author : PEAS Project
# Date   : 2001/12
# -------------------------------------------------------------------#

if (! open(TMP, "<$ARGV[5]")) {
    print STDOUT ("Data file '$ARGV[5]' not found.\n");
    exit(100);
}

#--------------------------------------------------------------------------#
# Type: Table lookup
#--------------------------------------------------------------------------#
$i = 0;
while (<TMP>) {
    if ( /\<\s*data\s+bit\_width\=\"(\d+)\"\s*\>\s*(\d+\.?\d+)\s*\<\s*\/data\s*\>/ ) {
	$bit[$i]  = $1;
	$data[$i] = $2;
	$i++;
    }
}
close(TMP);

$bit_width = $ARGV[1];


for ($j = 0; $j < $i; $j++) {
    if ($bit_width == $bit[$j]) {
	$ret_data = $data[$j];
	goto END;
    }
}

if ($bit_width < $bit[0]) {
    
    # divide by zero
    if ($bit[1] == $bit[0]) {
	exit(100);
    }    

    $ret_data = $data[0] - (($data[1] - $data[0]) / ($bit[1] - $bit[0])) * ($bit[0] - $bit_width);
}

elsif ($bit[$i-1] < $bit_width) {

    # divide by zero
    if ($bit[$i-1] == $bit[$i-2]) {
	exit(100);
    }

    $ret_data = $data[$i-1] + (($data[$i-1] - $data[$i-2]) / ($bit[$i-1] - $bit[$i-2])) * ($bit_width - $bit[$i-1]);
}

else {
    $j = 0;
    while ($bit[$j] < $bit_width) {
	$j++;
    }

    # divide by zero
    if ($bit[$j] == $bit[$j-1]) {
	exit(100);
    }

    $ret_data = $data[$j-1] + (($data[$j] - $data[$j-1]) / ($bit[$j] - $bit[$j-1])) * ($bit_width - $bit[$j-1]);
}
    

END:

$ret_data = &data_round($ret_data, 1);

print "$ret_data\n";
exit(0);


sub data_round 
{
    my ( $input_data, $decimals ) = @_;
    my ( $format, $magic, $output_data );

    $format = '%.' . $decimals . 'f';
    $magic = ($input_data > 0) ? 0.5 : -0.5;
    
    $output_data = sprintf($format, int(($input_data * (10 ** $decimals)) + $magic) / (10 ** $decimals));

    return($output_data);
}

                ]]>
              </script>
            </parameters>

          </est_index>

        </est_type>

        <est_type name="function_cycle">
          <est_index name="cycle">
            <parameters name="seq,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>
          <est_index name="latency">
            <parameters name="seq,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

          <est_index name="throughput">
            <parameters name="seq,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="seq,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
if(!open(TMP,"<$ARGV[4]")){
    exit(100);
}
$tmp = <TMP>;
$tmp =~ s/<data bit_width="1">//;
$tmp =~ s/<\/data>//;

if ($tmp == 0){
   print "0";
}
else{
   print $ARGV[0]+1;
}
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,rca,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,unsigned">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,abs">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>

            <parameters name="array,cla,two_complement">
              <script>
                <![CDATA[
#!/usr/bin/perl
print "0";
exit(0);
                ]]>
              </script>
            </parameters>
          </est_index>

        </est_type>

        <est_type name="function_power">

        </est_type>

    
      </estimation_method>

    </estimation>


  </model>
</FHM>
